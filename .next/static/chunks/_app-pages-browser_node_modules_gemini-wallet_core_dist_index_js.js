/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_gemini-wallet_core_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2RjNTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcz8yYjRmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5cbnZhciBMSU1JVF9SRVBMQUNFX05PREUgPSAnWy4uLl0nXG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gJ1tDaXJjdWxhcl0nXG5cbnZhciBhcnIgPSBbXVxudmFyIHJlcGxhY2VyU3RhY2sgPSBbXVxuXG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucyAoKSB7XG4gIHJldHVybiB7XG4gICAgZGVwdGhMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgfVxufVxuXG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICBkZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucylcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKClcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc2V0UmVwbGFjZSAocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKVxuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSlcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRba10gPSByZXBsYWNlXG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNpcmMgKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWwpXG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKVxuICB9XG5cbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqXG4gIHZhciByZXNcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKVxuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpXG4gIH0gZmluYWxseSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cbiAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKClcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0RlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICB2YXIgdG1wID0ge31cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbilcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICAgICAgICBwYXJlbnRba10gPSB0bXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXBcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyB3cmFwcyByZXBsYWNlciBmdW5jdGlvbiB0byBoYW5kbGUgdmFsdWVzIHdlIGNvdWxkbid0IHJlcGxhY2Vcbi8vIGFuZCBtYXJrIHRoZW0gYXMgcmVwbGFjZWQgdmFsdWVcbmZ1bmN0aW9uIHJlcGxhY2VHZXR0ZXJWYWx1ZXMgKHJlcGxhY2VyKSB7XG4gIHJlcGxhY2VyID1cbiAgICB0eXBlb2YgcmVwbGFjZXIgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHJlcGxhY2VyXG4gICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHJldHVybiB2XG4gICAgICB9XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldXG4gICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgdmFsID0gcGFydFsyXVxuICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-safe-stringify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@gemini-wallet/core/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Communicator: function() { return /* binding */ Communicator; },\n/* harmony export */   DEFAULT_CHAIN_ID: function() { return /* binding */ DEFAULT_CHAIN_ID; },\n/* harmony export */   GeminiSdkEvent: function() { return /* binding */ GeminiSdkEvent; },\n/* harmony export */   GeminiStorage: function() { return /* binding */ GeminiStorage; },\n/* harmony export */   GeminiWallet: function() { return /* binding */ GeminiWallet; },\n/* harmony export */   GeminiWalletProvider: function() { return /* binding */ GeminiWalletProvider; },\n/* harmony export */   POPUP_HEIGHT: function() { return /* binding */ POPUP_HEIGHT; },\n/* harmony export */   POPUP_WIDTH: function() { return /* binding */ POPUP_WIDTH; },\n/* harmony export */   PlatformType: function() { return /* binding */ PlatformType; },\n/* harmony export */   ProviderEventEmitter: function() { return /* binding */ ProviderEventEmitter; },\n/* harmony export */   SDK_BACKEND_URL: function() { return /* binding */ SDK_BACKEND_URL; },\n/* harmony export */   SDK_VERSION: function() { return /* binding */ SDK_VERSION; },\n/* harmony export */   STORAGE_CALL_BATCHES_KEY: function() { return /* binding */ STORAGE_CALL_BATCHES_KEY; },\n/* harmony export */   STORAGE_ETH_ACCOUNTS_KEY: function() { return /* binding */ STORAGE_ETH_ACCOUNTS_KEY; },\n/* harmony export */   STORAGE_ETH_ACTIVE_CHAIN_KEY: function() { return /* binding */ STORAGE_ETH_ACTIVE_CHAIN_KEY; },\n/* harmony export */   STORAGE_PASSKEY_CREDENTIAL_KEY: function() { return /* binding */ STORAGE_PASSKEY_CREDENTIAL_KEY; },\n/* harmony export */   STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY: function() { return /* binding */ STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY; },\n/* harmony export */   STORAGE_SETTINGS_KEY: function() { return /* binding */ STORAGE_SETTINGS_KEY; },\n/* harmony export */   STORAGE_SMART_ACCOUNT_KEY: function() { return /* binding */ STORAGE_SMART_ACCOUNT_KEY; },\n/* harmony export */   STORAGE_WC_REQUESTS_KEY: function() { return /* binding */ STORAGE_WC_REQUESTS_KEY; },\n/* harmony export */   base64ToHex: function() { return /* binding */ base64ToHex; },\n/* harmony export */   bufferToBase64URLString: function() { return /* binding */ bufferToBase64URLString; },\n/* harmony export */   calculateV1Address: function() { return /* binding */ calculateV1Address; },\n/* harmony export */   calculateWalletAddress: function() { return /* binding */ calculateWalletAddress; },\n/* harmony export */   closePopup: function() { return /* binding */ closePopup; },\n/* harmony export */   convertSendValuesToBigInt: function() { return /* binding */ convertSendValuesToBigInt; },\n/* harmony export */   decodeBase64: function() { return /* binding */ decodeBase64; },\n/* harmony export */   encodeBase64: function() { return /* binding */ encodeBase64; },\n/* harmony export */   fetchRpcRequest: function() { return /* binding */ fetchRpcRequest; },\n/* harmony export */   generateAuthenticatorIdHash: function() { return /* binding */ generateAuthenticatorIdHash; },\n/* harmony export */   hexStringFromNumber: function() { return /* binding */ hexStringFromNumber; },\n/* harmony export */   isChainSupportedByGeminiSw: function() { return /* binding */ isChainSupportedByGeminiSw; },\n/* harmony export */   openPopup: function() { return /* binding */ openPopup; },\n/* harmony export */   reverseResolveEns: function() { return /* binding */ reverseResolveEns; },\n/* harmony export */   safeJsonStringify: function() { return /* binding */ safeJsonStringify; },\n/* harmony export */   utf8StringToBuffer: function() { return /* binding */ utf8StringToBuffer; },\n/* harmony export */   validateRpcRequestArgs: function() { return /* binding */ validateRpcRequestArgs; },\n/* harmony export */   validateWebAuthnKey: function() { return /* binding */ validateWebAuthnKey; }\n/* harmony export */ });\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/errors.mjs\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/mainnet.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/arbitrum.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/optimism.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/base.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/polygon.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/optimismSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/polygonAmoy.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/abi/encodePacked.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/address/getContractAddress.js\");\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs\");\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/utils.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/isHex.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n// src/communicator.ts\n\n\n// src/constants.ts\n\n\n// package.json\nvar package_default = {\n  name: \"@gemini-wallet/core\",\n  version: \"0.3.2\",\n  description: \"Core SDK for Gemini Wallet integration with popup communication\",\n  main: \"./dist/index.cjs\",\n  types: \"./dist/index.d.ts\",\n  type: \"module\",\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/gemini/gemini-wallet-core.git\"\n  },\n  homepage: \"https://keys.gemini.com\",\n  bugs: {\n    url: \"https://github.com/gemini/gemini-wallet-core/issues\"\n  },\n  license: \"MIT\",\n  author: \"Gemini\",\n  files: [\n    \"dist\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  exports: {\n    \".\": {\n      types: \"./dist/index.d.ts\",\n      import: \"./dist/index.js\",\n      require: \"./dist/index.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  scripts: {\n    build: \"dotenv -e .env.production -- tsup\",\n    dev: \"dotenv -e .env.local -- tsup --watch\",\n    typecheck: \"tsc --noEmit\",\n    lint: \"eslint ./src\",\n    \"lint:ci\": \"eslint --max-warnings 0 ./src\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    test: \"bun test\"\n  },\n  dependencies: {\n    \"@metamask/rpc-errors\": \"7.0.2\",\n    eventemitter3: \"5.0.1\"\n  },\n  devDependencies: {\n    \"@eslint/eslintrc\": \"3.3.1\",\n    \"@eslint/js\": \"9.38.0\",\n    \"@types/node\": \"22.13.0\",\n    \"dotenv-cli\": \"10.0.0\",\n    \"esbuild-plugin-replace\": \"1.4.0\",\n    eslint: \"9.38.0\",\n    \"eslint-config-prettier\": \"10.1.8\",\n    \"eslint-config-turbo\": \"2.5.6\",\n    \"eslint-plugin-import\": \"2.32.0\",\n    \"eslint-plugin-only-warn\": \"1.1.0\",\n    \"eslint-plugin-prettier\": \"5.5.4\",\n    \"eslint-plugin-simple-import-sort\": \"12.1.1\",\n    \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n    globals: \"16.4.0\",\n    prettier: \"3.6.2\",\n    tsup: \"8.5.0\",\n    typescript: \"5.5.3\",\n    \"typescript-eslint\": \"8.40.0\",\n    vitest: \"3.2.4\"\n  },\n  peerDependencies: {\n    viem: \">=2.0.0\"\n  },\n  keywords: [\n    \"gemini\",\n    \"wallet\",\n    \"sdk\",\n    \"ethereum\",\n    \"web3\",\n    \"crypto\"\n  ],\n  module: \"./dist/index.js\"\n};\n\n// src/constants.ts\nvar DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\nvar SDK_BACKEND_URL = DEFAULT_BACKEND_URL;\nvar ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nvar SDK_VERSION = package_default.version;\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111\n};\nvar SUPPORTED_CHAIN_IDS = [...Object.values(MAINNET_CHAIN_IDS), ...Object.values(TESTNET_CHAIN_IDS)];\nfunction getDefaultRpcUrl(chainId) {\n  const chainMap = {\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_1__.arbitrum.id]: viem_chains__WEBPACK_IMPORTED_MODULE_1__.arbitrum.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimism.id]: viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimism.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_3__.base.id]: viem_chains__WEBPACK_IMPORTED_MODULE_3__.base.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_4__.polygon.id]: viem_chains__WEBPACK_IMPORTED_MODULE_4__.polygon.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_5__.sepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_5__.sepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_6__.arbitrumSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_6__.arbitrumSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_7__.optimismSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_7__.optimismSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_8__.baseSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_8__.baseSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_9__.polygonAmoy.id]: viem_chains__WEBPACK_IMPORTED_MODULE_9__.polygonAmoy.rpcUrls.default.http[0]\n  };\n  return chainMap[chainId];\n}\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/types.ts\n\nvar GeminiSdkEvent = /* @__PURE__ */ ((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n  GeminiSdkEvent2[\"SDK_CURRENT_ACCOUNT\"] = \"SDK_CURRENT_ACCOUNT\";\n  GeminiSdkEvent2[\"SDK_SEND_BATCH_CALLS\"] = \"SDK_SEND_BATCH_CALLS\";\n  GeminiSdkEvent2[\"SDK_GET_CAPABILITIES\"] = \"SDK_GET_CAPABILITIES\";\n  GeminiSdkEvent2[\"SDK_GET_CALLS_STATUS\"] = \"SDK_GET_CALLS_STATUS\";\n  GeminiSdkEvent2[\"SDK_SHOW_CALLS_STATUS\"] = \"SDK_SHOW_CALLS_STATUS\";\n  return GeminiSdkEvent2;\n})(GeminiSdkEvent || {});\nvar PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\"\n};\nvar ProviderEventEmitter = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_10__.EventEmitter {\n};\n\n// src/utils/base64.ts\nfunction encodeBase64(array) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    base64 = btoa(\n      Array.from(array).map((b) => String.fromCharCode(b)).join(\"\")\n    );\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n// src/utils/calculateWalletAddress.ts\n\nvar SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\",\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\",\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\"\n};\nvar V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\",\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\",\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\"\n};\nvar V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\",\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\",\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\"\n};\nfunction processWalletAddressParams(params, contractAddresses) {\n  const { publicKey, credentialId, index = 0n } = params;\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\"Invalid public key: must be 64-byte hex string (0x + 128 chars)\");\n  }\n  const pubKeyX = `0x${publicKey.slice(2, 66)}`;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}`;\n  const webAuthnData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY)\n  };\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\"Invalid WebAuthn key: coordinates are not on secp256r1 curve\");\n  }\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData\n  });\n}\nfunction calculateWalletAddress(params) {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\nfunction calculateV1Address(params) {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\nfunction generateAuthenticatorIdHash(credentialId) {\n  const padding = \"=\".repeat((4 - credentialId.length % 4) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)(bytes);\n}\nfunction validateWebAuthnKey(webAuthnData) {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n  const { pubKeyX, pubKeyY } = webAuthnData;\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n  const ySquared = pubKeyY * pubKeyY % SECP256R1_P;\n  const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;\n  const threeX = 3n * pubKeyX % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n  return ySquared === rightSide;\n}\nfunction calculateAddressInternal(params) {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n  const salt = (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)(\n    (0,viem__WEBPACK_IMPORTED_MODULE_12__.encodePacked)(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index]\n    )\n  );\n  const validatorInitData = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" }\n        ],\n        type: \"tuple\"\n      },\n      { type: \"bytes32\" }\n    ],\n    [webAuthnData, authenticatorIdHash]\n  );\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n\n  };\n  const bootstrapCall = (0,viem__WEBPACK_IMPORTED_MODULE_14__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" }\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\"\n          }\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\"\n      }\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\"\n  });\n  const initData = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)([{ type: \"address\" }, { type: \"bytes\" }], [bootstrapper, bootstrapCall]);\n  return predictProxyAddress(accountImplementation, salt, initData, factoryAddress);\n}\nfunction predictProxyAddress(implementation, salt, initData, deployer) {\n  const initializeCall = (0,viem__WEBPACK_IMPORTED_MODULE_14__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\"\n      }\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\"\n  });\n  const constructorArgs = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall]\n  );\n  const nexusProxyCreationCode = \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\";\n  const initCodeHash = (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_12__.encodePacked)([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs]));\n  return (0,viem__WEBPACK_IMPORTED_MODULE_15__.getCreate2Address)({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt\n  });\n}\n\n// src/utils/ens.ts\nasync function reverseResolveEns(address) {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n    if (!response.ok) {\n      throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    return {\n      address: data.address,\n      name: data.name || null\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null\n    };\n  }\n}\n\n// src/utils/popup.ts\n\nvar POPUP_WIDTH2 = 420;\nvar POPUP_HEIGHT2 = 650;\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(url, popupId, `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left}, top=${top}`);\n  popup?.focus();\n  if (!popup) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => {\n  return `0x${BigInt(num).toString(16)}`;\n};\nvar safeJsonStringify = (obj) => JSON.stringify(obj, (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value, 2);\n\n// src/communicator.ts\nvar Communicator = class {\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.popup = null;\n    this.listeners = /* @__PURE__ */ new Map();\n    // posts a message to the popup window\n    this.postMessage = async (message) => {\n      const popup = await this.waitForPopupLoaded();\n      popup.postMessage(message, this.url.origin);\n    };\n    // posts a request to the popup window and waits for a response\n    this.postRequestAndWaitForResponse = async (request) => {\n      const responsePromise = this.onMessage(({ requestId }) => requestId === request.requestId);\n      this.postMessage(request);\n      return await responsePromise;\n    };\n    // listens for messages from the popup window that match a given predicate\n    this.onMessage = (predicate) => {\n      return new Promise((resolve, reject) => {\n        const listener = (event) => {\n          if (event.origin !== this.url.origin) return;\n          const message = event.data;\n          if (predicate(message)) {\n            resolve(message);\n            window.removeEventListener(\"message\", listener);\n            this.listeners.delete(listener);\n          }\n        };\n        window.addEventListener(\"message\", listener);\n        this.listeners.set(listener, { reject });\n      });\n    };\n    // closes the popup, rejects all requests and clears event listeners\n    this.onRequestCancelled = () => {\n      closePopup(this.popup);\n      this.popup = null;\n      this.listeners.forEach(({ reject }, listener) => {\n        reject(_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.userRejectedRequest());\n        window.removeEventListener(\"message\", listener);\n      });\n      this.listeners.clear();\n    };\n    // waits for the popup window to fully load and then sends a version message\n    this.waitForPopupLoaded = () => {\n      if (this.popup && !this.popup.closed) {\n        this.popup.focus();\n        return Promise.resolve(this.popup);\n      }\n      this.popup = openPopup(this.url);\n      this.onMessage(({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */).then(this.onRequestCancelled).catch(() => {\n      });\n      this.onMessage(({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */).then(() => {\n        this.onDisconnectCallback?.();\n        this.onRequestCancelled();\n      }).catch(() => {\n      });\n      return this.onMessage(\n        ({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */\n      ).then((message) => {\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION\n          },\n          event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n          origin: window.location.origin,\n          requestId: message.requestId\n        });\n      }).then(() => {\n        if (!this.popup) throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal();\n        return this.popup;\n      });\n    };\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n};\n\n// src/provider/provider.ts\n\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nvar GeminiStorage = class {\n  constructor({ scope = \"@gemini\", module = \"wallet\" } = {}) {\n    this.scope = scope;\n    this.module = module;\n  }\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      memoryStorage[scoped] = value;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return localStorage.getItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      return memoryStorage[scoped] || null;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      delete memoryStorage[scoped];\n    }\n  }\n  async removeItems(keys) {\n    await Promise.all(keys.map((key) => this.removeItem(key)));\n  }\n};\n\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = \"preserved-passkey-credentials\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\nvar STORAGE_WC_REQUESTS_KEY = \"wc-requests\";\nvar STORAGE_CALL_BATCHES_KEY = \"call-batches\";\n\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(chainId);\n}\nvar GeminiWallet = class {\n  constructor({ appMetadata, chain, onDisconnectCallback, storage }) {\n    this.accounts = [];\n    this.chain = { id: DEFAULT_CHAIN_ID };\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage();\n    const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;\n    const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);\n    const defaultChain = {\n      id: fallbackChainId,\n      rpcUrl: fallbackRpcUrl\n    };\n    this.initPromise = this.initializeFromStorage(defaultChain);\n  }\n  async initializeFromStorage(defaultChain) {\n    const fallbackChain = {\n      ...defaultChain,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),\n      this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)\n    ]);\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)\n    };\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = response.data.address ? [response.data.address] : [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async disconnect() {\n    await this.ensureInitialized();\n    this.accounts = [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n  }\n  async switchChain({ id }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id)\n      };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      return null;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error ?? \"Unsupported chain.\";\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({ message }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  // EIP-5792 Wallet Call API Methods\n  getCapabilities(requestedChainIds) {\n    const capabilities = {};\n    const chainIds = requestedChainIds?.map((id) => parseInt(id, 16)) || [this.chain.id];\n    for (const chainId of chainIds) {\n      const chainIdHex = hexStringFromNumber(chainId);\n      capabilities[chainIdHex] = {\n        atomic: {\n          status: \"supported\"\n          // Smart accounts support atomic batch execution\n        },\n        paymasterService: {\n          supported: true\n        }\n      };\n    }\n    return capabilities;\n  }\n  async sendCalls(params) {\n    await this.ensureInitialized();\n    const batchId = window?.crypto?.randomUUID() || `batch-${Date.now()}-${Math.random()}`;\n    const requestedChainId = parseInt(params.chainId, 16);\n    if (requestedChainId !== this.chain.id) {\n      throw new Error(`Chain mismatch. Expected ${this.chain.id}, got ${requestedChainId}`);\n    }\n    if (!params.calls || params.calls.length === 0) {\n      throw new Error(\"No calls provided\");\n    }\n    const batchMetadata = {\n      calls: params.calls,\n      capabilities: params.capabilities,\n      chainId: params.chainId,\n      from: params.from,\n      id: batchId,\n      status: \"pending\",\n      timestamp: Date.now()\n    };\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    batches[batchId] = batchMetadata;\n    await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n    try {\n      const response = await this.sendMessageToPopup({\n        chainId: this.chain.id,\n        data: {\n          calls: params.calls\n        },\n        event: \"SDK_SEND_BATCH_CALLS\" /* SDK_SEND_BATCH_CALLS */,\n        origin: window.location.origin\n      });\n      if (response.data.error) {\n        throw new Error(response.data.error);\n      }\n      batchMetadata.transactionHash = response.data.hash;\n      batchMetadata.status = \"pending\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n      return {\n        capabilities: {\n          caip345: {\n            caip2: `eip155:${requestedChainId}`,\n            transactionHashes: [response.data.hash]\n          }\n        },\n        id: batchId\n      };\n    } catch (error) {\n      batchMetadata.status = \"failed\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n      throw error;\n    }\n  }\n  async getCallsStatus(batchId) {\n    await this.ensureInitialized();\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n    if (batch.transactionHash && this.chain.rpcUrl) {\n      try {\n        const response = await fetch(this.chain.rpcUrl, {\n          body: JSON.stringify({\n            id: 1,\n            jsonrpc: \"2.0\",\n            method: \"eth_getTransactionReceipt\",\n            params: [batch.transactionHash]\n          }),\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\"\n        });\n        const json = await response.json();\n        const receipt = json.result;\n        if (receipt) {\n          const receiptStatus = receipt.status === \"0x1\" ? \"confirmed\" : \"reverted\";\n          batch.status = receiptStatus;\n          batches[batchId] = batch;\n          await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n          return {\n            atomic: true,\n            chainId: batch.chainId,\n            id: batchId,\n            receipts: [\n              {\n                blockHash: receipt.blockHash,\n                blockNumber: receipt.blockNumber,\n                gasUsed: receipt.gasUsed,\n                logs: receipt.logs.map((log) => ({\n                  address: log.address,\n                  data: log.data,\n                  topics: log.topics\n                })),\n                status: receiptStatus === \"confirmed\" ? \"success\" : \"reverted\",\n                transactionHash: receipt.transactionHash\n              }\n            ],\n            status: receiptStatus === \"confirmed\" ? 200 : 500,\n            version: \"2.0.0\"\n          };\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch transaction receipt:\", error);\n      }\n    }\n    let statusCode;\n    switch (batch.status) {\n      case \"pending\":\n        statusCode = 100;\n        break;\n      case \"confirmed\":\n        statusCode = 200;\n        break;\n      case \"failed\":\n        statusCode = 400;\n        break;\n      case \"reverted\":\n        statusCode = 500;\n        break;\n      default:\n        statusCode = 100;\n    }\n    return {\n      atomic: true,\n      chainId: batch.chainId,\n      id: batchId,\n      status: statusCode,\n      version: \"2.0.0\"\n    };\n  }\n  async showCallsStatus(batchId) {\n    await this.ensureInitialized();\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n};\n\n// src/provider/provider.utils.ts\n\n\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) throw error;\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== void 0 && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) continue;\n    const value = tx[field];\n    if (typeof value === \"bigint\") continue;\n    if ((0,viem__WEBPACK_IMPORTED_MODULE_17__.isHex)(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nvar GeminiWalletProvider = class extends ProviderEventEmitter {\n  constructor(providerConfig) {\n    super();\n    this.wallet = null;\n    this.config = providerConfig;\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        userDisconnectCallback?.();\n        this.disconnect();\n      }\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            if (!this.wallet) {\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  userDisconnectCallback?.();\n                  this.disconnect();\n                }\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(\n              \"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\"\n            );\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(requestParams[1]);\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        // EIP-5792 Wallet Call API\n        case \"wallet_getCapabilities\": {\n          const capabilityParams = Array.isArray(args.params) ? args.params : void 0;\n          response = this.getCapabilities(capabilityParams);\n          break;\n        }\n        case \"wallet_sendCalls\": {\n          requestParams = args.params;\n          response = await this.sendCalls(requestParams[0]);\n          break;\n        }\n        case \"wallet_getCallsStatus\": {\n          requestParams = args.params;\n          response = await this.getCallsStatus(requestParams[0]);\n          break;\n        }\n        case \"wallet_showCallsStatus\": {\n          requestParams = args.params;\n          await this.showCallsStatus(requestParams[0]);\n          response = null;\n          break;\n        }\n        // TODO: not yet implemented or unclear if we support\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_grantPermissions\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.methodNotSupported(\"Not yet implemented.\");\n        // not supported\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.methodNotSupported();\n        // call rpc directly for everything else\n        default:\n          if (!this.wallet.chain.rpcUrl)\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_18__.errorCodes.provider.unauthorized) this.disconnect();\n      return Promise.reject((0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_19__.serializeError)(error));\n    }\n  }\n  // custom wallet function to open settings page\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  // EIP-5792 Implementation Methods - delegating to wallet\n  getCapabilities(params) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    const requestedChainIds = params?.[0];\n    return this.wallet.getCapabilities(requestedChainIds);\n  }\n  async sendCalls(params) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.sendCalls(params);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async getCallsStatus(batchId) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.getCallsStatus(batchId);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async showCallsStatus(batchId) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      await this.wallet.showCallsStatus(batchId);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async disconnect() {\n    if (this.wallet) {\n      const storage = this.config.storage || new GeminiStorage();\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = null;\n    this.config.onDisconnectCallback?.();\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n    await this.emit(\"accountsChanged\", []);\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMrRTs7QUFFL0U7QUFZcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnREFBTyxNQUFNLGdEQUFPO0FBQ3pCLEtBQUssaURBQVEsTUFBTSxpREFBUTtBQUMzQixLQUFLLGlEQUFRLE1BQU0saURBQVE7QUFDM0IsS0FBSyw2Q0FBSSxNQUFNLDZDQUFJO0FBQ25CLEtBQUssZ0RBQU8sTUFBTSxnREFBTztBQUN6QixLQUFLLGdEQUFPLE1BQU0sZ0RBQU87QUFDekIsS0FBSyx3REFBZSxNQUFNLHdEQUFlO0FBQ3pDLEtBQUssd0RBQWUsTUFBTSx3REFBZTtBQUN6QyxLQUFLLG9EQUFXLE1BQU0sb0RBQVc7QUFDakMsS0FBSyxvREFBVyxNQUFNLG9EQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHdEQUFZO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsMEJBQTBCLE1BQU07QUFDaEMsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLE1BQU07QUFDMUIsMEJBQTBCLE1BQU07QUFDaEMsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFPYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUMsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTLGdEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFTO0FBQ3hCLElBQUksbURBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRCxZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRCxnQkFBZ0Isc0NBQXNDO0FBQ3RELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQiwwREFBbUIsSUFBSSxpQkFBaUIsSUFBSSxlQUFlO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBa0I7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQiwwREFBbUI7QUFDN0MsT0FBTyxpQkFBaUIsSUFBSSxlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBUyxDQUFDLG1EQUFZO0FBQzdDLFNBQVMsd0RBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxXQUFXLFFBQVE7QUFDbkU7QUFDQSxpREFBaUQsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RCxtREFBbUQsYUFBYSxXQUFXLGNBQWMsU0FBUyxLQUFLLFFBQVEsSUFBSTtBQUNuSDtBQUNBO0FBQ0EsVUFBVSw0REFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLGVBQWUsaUVBQWM7QUFDN0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsT0FBTztBQUNQLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsK0JBQStCLDREQUFVO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4SDs7QUFFOUg7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsWUFBWSxHQUFHLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQW1EO0FBQ25FO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXLEdBQUcsY0FBYztBQUN6RjtBQUNBO0FBQ0Esa0RBQWtELGNBQWMsUUFBUSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQytEO0FBQ2xDO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQVU7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLFVBQVUsNERBQVU7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsNERBQVU7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0IsNERBQVU7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBVTtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWixrQkFBa0IsNERBQVU7QUFDNUIsc0RBQXNELHFCQUFxQixPQUFPLFlBQVk7QUFDOUY7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0Esa0JBQWtCLGlFQUFlLFVBQVUsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0IsNERBQVU7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBVSxnREFBZ0QscUJBQXFCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLE9BQU87QUFDckIsbUJBQW1CLDZEQUFVO0FBQzdCLDRCQUE0QixxRUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVksNERBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLDREQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSw0REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BnZW1pbmktd2FsbGV0L2NvcmUvZGlzdC9pbmRleC5qcz8yMGU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21tdW5pY2F0b3IudHNcbmltcG9ydCB7IHByb3ZpZGVyRXJyb3JzLCBycGNFcnJvcnMgYXMgcnBjRXJyb3JzMiB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG5pbXBvcnQge1xuICBhcmJpdHJ1bSxcbiAgYXJiaXRydW1TZXBvbGlhLFxuICBiYXNlLFxuICBiYXNlU2Vwb2xpYSxcbiAgbWFpbm5ldCxcbiAgb3B0aW1pc20sXG4gIG9wdGltaXNtU2Vwb2xpYSxcbiAgcG9seWdvbixcbiAgcG9seWdvbkFtb3ksXG4gIHNlcG9saWFcbn0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHBhY2thZ2VfZGVmYXVsdCA9IHtcbiAgbmFtZTogXCJAZ2VtaW5pLXdhbGxldC9jb3JlXCIsXG4gIHZlcnNpb246IFwiMC4zLjJcIixcbiAgZGVzY3JpcHRpb246IFwiQ29yZSBTREsgZm9yIEdlbWluaSBXYWxsZXQgaW50ZWdyYXRpb24gd2l0aCBwb3B1cCBjb21tdW5pY2F0aW9uXCIsXG4gIG1haW46IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICB0eXBlczogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICB0eXBlOiBcIm1vZHVsZVwiLFxuICByZXBvc2l0b3J5OiB7XG4gICAgdHlwZTogXCJnaXRcIixcbiAgICB1cmw6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9nZW1pbmkvZ2VtaW5pLXdhbGxldC1jb3JlLmdpdFwiXG4gIH0sXG4gIGhvbWVwYWdlOiBcImh0dHBzOi8va2V5cy5nZW1pbmkuY29tXCIsXG4gIGJ1Z3M6IHtcbiAgICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2dlbWluaS9nZW1pbmktd2FsbGV0LWNvcmUvaXNzdWVzXCJcbiAgfSxcbiAgbGljZW5zZTogXCJNSVRcIixcbiAgYXV0aG9yOiBcIkdlbWluaVwiLFxuICBmaWxlczogW1xuICAgIFwiZGlzdFwiLFxuICAgIFwic3JjXCIsXG4gICAgXCJSRUFETUUubWRcIixcbiAgICBcIkxJQ0VOU0VcIlxuICBdLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICBpbXBvcnQ6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gICAgICByZXF1aXJlOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCJcbiAgfSxcbiAgc2NyaXB0czoge1xuICAgIGJ1aWxkOiBcImRvdGVudiAtZSAuZW52LnByb2R1Y3Rpb24gLS0gdHN1cFwiLFxuICAgIGRldjogXCJkb3RlbnYgLWUgLmVudi5sb2NhbCAtLSB0c3VwIC0td2F0Y2hcIixcbiAgICB0eXBlY2hlY2s6IFwidHNjIC0tbm9FbWl0XCIsXG4gICAgbGludDogXCJlc2xpbnQgLi9zcmNcIixcbiAgICBcImxpbnQ6Y2lcIjogXCJlc2xpbnQgLS1tYXgtd2FybmluZ3MgMCAuL3NyY1wiLFxuICAgIFwibGludDpmaXhcIjogXCJlc2xpbnQgLi9zcmMgLS1maXhcIixcbiAgICB0ZXN0OiBcImJ1biB0ZXN0XCJcbiAgfSxcbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiOiBcIjcuMC4yXCIsXG4gICAgZXZlbnRlbWl0dGVyMzogXCI1LjAuMVwiXG4gIH0sXG4gIGRldkRlcGVuZGVuY2llczoge1xuICAgIFwiQGVzbGludC9lc2xpbnRyY1wiOiBcIjMuMy4xXCIsXG4gICAgXCJAZXNsaW50L2pzXCI6IFwiOS4zOC4wXCIsXG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIjIyLjEzLjBcIixcbiAgICBcImRvdGVudi1jbGlcIjogXCIxMC4wLjBcIixcbiAgICBcImVzYnVpbGQtcGx1Z2luLXJlcGxhY2VcIjogXCIxLjQuMFwiLFxuICAgIGVzbGludDogXCI5LjM4LjBcIixcbiAgICBcImVzbGludC1jb25maWctcHJldHRpZXJcIjogXCIxMC4xLjhcIixcbiAgICBcImVzbGludC1jb25maWctdHVyYm9cIjogXCIyLjUuNlwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1pbXBvcnRcIjogXCIyLjMyLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tb25seS13YXJuXCI6IFwiMS4xLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tcHJldHRpZXJcIjogXCI1LjUuNFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zaW1wbGUtaW1wb3J0LXNvcnRcIjogXCIxMi4xLjFcIixcbiAgICBcImVzbGludC1wbHVnaW4tc29ydC1rZXlzLWZpeFwiOiBcIjEuMS4yXCIsXG4gICAgZ2xvYmFsczogXCIxNi40LjBcIixcbiAgICBwcmV0dGllcjogXCIzLjYuMlwiLFxuICAgIHRzdXA6IFwiOC41LjBcIixcbiAgICB0eXBlc2NyaXB0OiBcIjUuNS4zXCIsXG4gICAgXCJ0eXBlc2NyaXB0LWVzbGludFwiOiBcIjguNDAuMFwiLFxuICAgIHZpdGVzdDogXCIzLjIuNFwiXG4gIH0sXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHtcbiAgICB2aWVtOiBcIj49Mi4wLjBcIlxuICB9LFxuICBrZXl3b3JkczogW1xuICAgIFwiZ2VtaW5pXCIsXG4gICAgXCJ3YWxsZXRcIixcbiAgICBcInNka1wiLFxuICAgIFwiZXRoZXJldW1cIixcbiAgICBcIndlYjNcIixcbiAgICBcImNyeXB0b1wiXG4gIF0sXG4gIG1vZHVsZTogXCIuL2Rpc3QvaW5kZXguanNcIlxufTtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIERFRkFVTFRfQkFDS0VORF9VUkwgPSBcImh0dHBzOi8va2V5cy5nZW1pbmkuY29tXCI7XG52YXIgU0RLX0JBQ0tFTkRfVVJMID0gREVGQVVMVF9CQUNLRU5EX1VSTDtcbnZhciBFTlNfQVBJX1VSTCA9IFwiaHR0cHM6Ly9ob3Jpem9uLWFwaS5nZW1pbmkuY29tL2FwaS9lbnNcIjtcbnZhciBTREtfVkVSU0lPTiA9IHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uO1xudmFyIERFRkFVTFRfQ0hBSU5fSUQgPSA0MjE2MTtcbnZhciBNQUlOTkVUX0NIQUlOX0lEUyA9IHtcbiAgQVJCSVRSVU1fT05FOiA0MjE2MSxcbiAgQkFTRTogODQ1MyxcbiAgRVRIRVJFVU06IDEsXG4gIE9QX01BSU5ORVQ6IDEwLFxuICBQT0xZR09OOiAxMzdcbn07XG52YXIgVEVTVE5FVF9DSEFJTl9JRFMgPSB7XG4gIEFSQklUUlVNX1NFUE9MSUE6IDQyMTYxNCxcbiAgQkFTRV9TRVBPTElBOiA4NDUzMixcbiAgT1BfU0VQT0xJQTogMTExNTU0MjAsXG4gIFBPTFlHT05fQU1PWTogODAwMDIsXG4gIFNFUE9MSUE6IDExMTU1MTExXG59O1xudmFyIFNVUFBPUlRFRF9DSEFJTl9JRFMgPSBbLi4uT2JqZWN0LnZhbHVlcyhNQUlOTkVUX0NIQUlOX0lEUyksIC4uLk9iamVjdC52YWx1ZXMoVEVTVE5FVF9DSEFJTl9JRFMpXTtcbmZ1bmN0aW9uIGdldERlZmF1bHRScGNVcmwoY2hhaW5JZCkge1xuICBjb25zdCBjaGFpbk1hcCA9IHtcbiAgICBbbWFpbm5ldC5pZF06IG1haW5uZXQucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2FyYml0cnVtLmlkXTogYXJiaXRydW0ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW29wdGltaXNtLmlkXTogb3B0aW1pc20ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2Jhc2UuaWRdOiBiYXNlLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtwb2x5Z29uLmlkXTogcG9seWdvbi5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbc2Vwb2xpYS5pZF06IHNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2FyYml0cnVtU2Vwb2xpYS5pZF06IGFyYml0cnVtU2Vwb2xpYS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbb3B0aW1pc21TZXBvbGlhLmlkXTogb3B0aW1pc21TZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtiYXNlU2Vwb2xpYS5pZF06IGJhc2VTZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtwb2x5Z29uQW1veS5pZF06IHBvbHlnb25BbW95LnJwY1VybHMuZGVmYXVsdC5odHRwWzBdXG4gIH07XG4gIHJldHVybiBjaGFpbk1hcFtjaGFpbklkXTtcbn1cbnZhciBQT1BVUF9XSURUSCA9IDQyMDtcbnZhciBQT1BVUF9IRUlHSFQgPSA2NTA7XG5cbi8vIHNyYy90eXBlcy50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbnZhciBHZW1pbmlTZGtFdmVudCA9IC8qIEBfX1BVUkVfXyAqLyAoKEdlbWluaVNka0V2ZW50MikgPT4ge1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9MT0FERURcIl0gPSBcIlBPUFVQX0xPQURFRFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9VTkxPQURFRFwiXSA9IFwiUE9QVVBfVU5MT0FERURcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiUE9QVVBfQVBQX0NPTlRFWFRcIl0gPSBcIlBPUFVQX0FQUF9DT05URVhUXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19DT05ORUNUXCJdID0gXCJTREtfQ09OTkVDVFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfRElTQ09OTkVDVFwiXSA9IFwiU0RLX0RJU0NPTk5FQ1RcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NFTkRfVFJBTlNBQ1RJT05cIl0gPSBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TSUdOX0RBVEFcIl0gPSBcIlNES19TSUdOX0RBVEFcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NJR05fVFlQRURfREFUQVwiXSA9IFwiU0RLX1NJR05fVFlQRURfREFUQVwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU1dJVENIX0NIQUlOXCJdID0gXCJTREtfU1dJVENIX0NIQUlOXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19PUEVOX1NFVFRJTkdTXCJdID0gXCJTREtfT1BFTl9TRVRUSU5HU1wiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfQ1VSUkVOVF9BQ0NPVU5UXCJdID0gXCJTREtfQ1VSUkVOVF9BQ0NPVU5UXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TRU5EX0JBVENIX0NBTExTXCJdID0gXCJTREtfU0VORF9CQVRDSF9DQUxMU1wiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfR0VUX0NBUEFCSUxJVElFU1wiXSA9IFwiU0RLX0dFVF9DQVBBQklMSVRJRVNcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX0dFVF9DQUxMU19TVEFUVVNcIl0gPSBcIlNES19HRVRfQ0FMTFNfU1RBVFVTXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TSE9XX0NBTExTX1NUQVRVU1wiXSA9IFwiU0RLX1NIT1dfQ0FMTFNfU1RBVFVTXCI7XG4gIHJldHVybiBHZW1pbmlTZGtFdmVudDI7XG59KShHZW1pbmlTZGtFdmVudCB8fCB7fSk7XG52YXIgUGxhdGZvcm1UeXBlID0ge1xuICBSRUFDVF9OQVRJVkU6IFwiUkVBQ1RfTkFUSVZFXCIsXG4gIFdFQjogXCJXRUJcIlxufTtcbnZhciBQcm92aWRlckV2ZW50RW1pdHRlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbn07XG5cbi8vIHNyYy91dGlscy9iYXNlNjQudHNcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChhcnJheSkge1xuICBsZXQgYmFzZTY0O1xuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGFycmF5KS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlNjQgPSBidG9hKFxuICAgICAgQXJyYXkuZnJvbShhcnJheSkubWFwKChiKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKS5qb2luKFwiXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYmFzZTY0LnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChiYXNlNjR1cmwpIHtcbiAgbGV0IGJhc2U2NCA9IGJhc2U2NHVybC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgYmFzZTY0ICs9IFwiPVwiO1xuICB9XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKGJ1ZmZlcikge1xuICBjb25zdCBieXRlcyA9IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWZmZXIgOiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4gZW5jb2RlQmFzZTY0KGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb0J1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NFRvSGV4KGJhc2U2NCkge1xuICBjb25zdCBieXRlcyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcykubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy91dGlscy9jYWxjdWxhdGVXYWxsZXRBZGRyZXNzLnRzXG5pbXBvcnQge1xuICBlbmNvZGVBYmlQYXJhbWV0ZXJzLFxuICBlbmNvZGVGdW5jdGlvbkRhdGEsXG4gIGVuY29kZVBhY2tlZCxcbiAgZ2V0Q3JlYXRlMkFkZHJlc3MsXG4gIGtlY2NhazI1NlxufSBmcm9tIFwidmllbVwiO1xudmFyIFNIQVJFRF9DT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gIEFUVEVTVEVSOiBcIjB4MDAwNDc0MzkyYTljZDg2YTQ2ODczNTRmMUNlMjk2NEI1MmU5NzQ4NFwiLFxuICBCT09UU1RSQVBQRVI6IFwiMHgwMDAwMDAwMEQzMjU0NDUyYTkwOUU0ZWVENDc0NTVBZjdFMjdDMjg5XCIsXG4gIFJFR0lTVFJZOiBcIjB4MDAwMDAwMDAwMDY5RTJhMTg3QUVGRmI4NTJiRjNjQ2RDOTUxNTFCMlwiXG59O1xudmFyIFYyX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgLi4uU0hBUkVEX0NPTlRSQUNUX0FERFJFU1NFUyxcbiAgQUNDT1VOVF9JTVBMRU1FTlRBVElPTjogXCIweDAwMDAwMDAwMDI5ZDljOGI4NjRERDUxZDZiYjBkOTlGQjcyRDY1MGJcIixcbiAgRkFDVE9SWTogXCIweDAwMDAwMDAwMDQ1MjM3N2UxQmQ5ZTcyRTkzOTg1NUVDYjkzNjNDYWJcIixcbiAgV0VCQVVUSE5fVkFMSURBVE9SOiBcIjB4N2FiMTZGZjM1NEFjQjMyODQ1MkYxRDQ0NWIzRGRlZTlhOTFlOWU2OVwiXG59O1xudmFyIFYxX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgLi4uU0hBUkVEX0NPTlRSQUNUX0FERFJFU1NFUyxcbiAgQUNDT1VOVF9JTVBMRU1FTlRBVElPTjogXCIweDAwMDYwNTAxNjhERTI1NWE4NjcyQUNhRDQ4MjFlNzIxQ0JBNDQzMzdcIixcbiAgRkFDVE9SWTogXCIweDAwRTU4REY3MEZhQjk4M2EzMjRjNEMwNjhjODJkMjA0MDc1NzlGYUNcIixcbiAgV0VCQVVUSE5fVkFMSURBVE9SOiBcIjB4YkE0NWEyQkZiOERlM0QyNGNBOUQ3RjFCNTUxRTE0ZEZGNWQ2OTBGZFwiXG59O1xuZnVuY3Rpb24gcHJvY2Vzc1dhbGxldEFkZHJlc3NQYXJhbXMocGFyYW1zLCBjb250cmFjdEFkZHJlc3Nlcykge1xuICBjb25zdCB7IHB1YmxpY0tleSwgY3JlZGVudGlhbElkLCBpbmRleCA9IDBuIH0gPSBwYXJhbXM7XG4gIGlmICghcHVibGljS2V5LnN0YXJ0c1dpdGgoXCIweFwiKSB8fCBwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXk6IG11c3QgYmUgNjQtYnl0ZSBoZXggc3RyaW5nICgweCArIDEyOCBjaGFycylcIik7XG4gIH1cbiAgY29uc3QgcHViS2V5WCA9IGAweCR7cHVibGljS2V5LnNsaWNlKDIsIDY2KX1gO1xuICBjb25zdCBwdWJLZXlZID0gYDB4JHtwdWJsaWNLZXkuc2xpY2UoNjYsIDEzMCl9YDtcbiAgY29uc3Qgd2ViQXV0aG5EYXRhID0ge1xuICAgIHB1YktleVg6IEJpZ0ludChwdWJLZXlYKSxcbiAgICBwdWJLZXlZOiBCaWdJbnQocHViS2V5WSlcbiAgfTtcbiAgaWYgKCF2YWxpZGF0ZVdlYkF1dGhuS2V5KHdlYkF1dGhuRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFdlYkF1dGhuIGtleTogY29vcmRpbmF0ZXMgYXJlIG5vdCBvbiBzZWNwMjU2cjEgY3VydmVcIik7XG4gIH1cbiAgY29uc3QgYXV0aGVudGljYXRvcklkSGFzaCA9IGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaChjcmVkZW50aWFsSWQpO1xuICByZXR1cm4gY2FsY3VsYXRlQWRkcmVzc0ludGVybmFsKHtcbiAgICBhdXRoZW50aWNhdG9ySWRIYXNoLFxuICAgIGNvbnRyYWN0QWRkcmVzc2VzLFxuICAgIGluZGV4LFxuICAgIHdlYkF1dGhuRGF0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVdhbGxldEFkZHJlc3MocGFyYW1zKSB7XG4gIHJldHVybiBwcm9jZXNzV2FsbGV0QWRkcmVzc1BhcmFtcyhwYXJhbXMsIFYyX0NPTlRSQUNUX0FERFJFU1NFUyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVWMUFkZHJlc3MocGFyYW1zKSB7XG4gIHJldHVybiBwcm9jZXNzV2FsbGV0QWRkcmVzc1BhcmFtcyhwYXJhbXMsIFYxX0NPTlRSQUNUX0FERFJFU1NFUyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUF1dGhlbnRpY2F0b3JJZEhhc2goY3JlZGVudGlhbElkKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBcIj1cIi5yZXBlYXQoKDQgLSBjcmVkZW50aWFsSWQubGVuZ3RoICUgNCkgJSA0KTtcbiAgY29uc3QgYmFzZTY0ID0gY3JlZGVudGlhbElkLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpICsgcGFkZGluZztcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGtlY2NhazI1NihieXRlcyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVdlYkF1dGhuS2V5KHdlYkF1dGhuRGF0YSkge1xuICBjb25zdCBTRUNQMjU2UjFfUCA9IDB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm47XG4gIGNvbnN0IFNFQ1AyNTZSMV9CID0gMHg1YWM2MzVkOGFhM2E5M2U3YjNlYmJkNTU3Njk4ODZiYzY1MWQwNmIwY2M1M2IwZjYzYmNlM2MzZTI3ZDI2MDRibjtcbiAgY29uc3QgeyBwdWJLZXlYLCBwdWJLZXlZIH0gPSB3ZWJBdXRobkRhdGE7XG4gIGlmIChwdWJLZXlYID09PSAwbiB8fCBwdWJLZXlZID09PSAwbiB8fCBwdWJLZXlYID49IFNFQ1AyNTZSMV9QIHx8IHB1YktleVkgPj0gU0VDUDI1NlIxX1ApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeVNxdWFyZWQgPSBwdWJLZXlZICogcHViS2V5WSAlIFNFQ1AyNTZSMV9QO1xuICBjb25zdCB4Q3ViZWQgPSBwdWJLZXlYICogcHViS2V5WCAqIHB1YktleVggJSBTRUNQMjU2UjFfUDtcbiAgY29uc3QgdGhyZWVYID0gM24gKiBwdWJLZXlYICUgU0VDUDI1NlIxX1A7XG4gIGNvbnN0IHJpZ2h0U2lkZSA9ICh4Q3ViZWQgKyBTRUNQMjU2UjFfUCAtIHRocmVlWCArIFNFQ1AyNTZSMV9CKSAlIFNFQ1AyNTZSMV9QO1xuICByZXR1cm4geVNxdWFyZWQgPT09IHJpZ2h0U2lkZTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFkZHJlc3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgY29uc3QgeyB3ZWJBdXRobkRhdGEsIGF1dGhlbnRpY2F0b3JJZEhhc2gsIGluZGV4LCBjb250cmFjdEFkZHJlc3NlcyB9ID0gcGFyYW1zO1xuICBjb25zdCBmYWN0b3J5QWRkcmVzcyA9IGNvbnRyYWN0QWRkcmVzc2VzLkZBQ1RPUlk7XG4gIGNvbnN0IGFjY291bnRJbXBsZW1lbnRhdGlvbiA9IGNvbnRyYWN0QWRkcmVzc2VzLkFDQ09VTlRfSU1QTEVNRU5UQVRJT047XG4gIGNvbnN0IHdlYkF1dGhuVmFsaWRhdG9yID0gY29udHJhY3RBZGRyZXNzZXMuV0VCQVVUSE5fVkFMSURBVE9SO1xuICBjb25zdCBhdHRlc3RlciA9IGNvbnRyYWN0QWRkcmVzc2VzLkFUVEVTVEVSO1xuICBjb25zdCBib290c3RyYXBwZXIgPSBjb250cmFjdEFkZHJlc3Nlcy5CT09UU1RSQVBQRVI7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gY29udHJhY3RBZGRyZXNzZXMuUkVHSVNUUlk7XG4gIGNvbnN0IHNhbHQgPSBrZWNjYWsyNTYoXG4gICAgZW5jb2RlUGFja2VkKFxuICAgICAgW1widWludDI1NlwiLCBcInVpbnQyNTZcIiwgXCJieXRlczMyXCIsIFwidWludDI1NlwiXSxcbiAgICAgIFt3ZWJBdXRobkRhdGEucHViS2V5WCwgd2ViQXV0aG5EYXRhLnB1YktleVksIGF1dGhlbnRpY2F0b3JJZEhhc2gsIGluZGV4XVxuICAgIClcbiAgKTtcbiAgY29uc3QgdmFsaWRhdG9ySW5pdERhdGEgPSBlbmNvZGVBYmlQYXJhbWV0ZXJzKFxuICAgIFtcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgIHsgbmFtZTogXCJwdWJLZXlYXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgeyBuYW1lOiBcInB1YktleVlcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgICAgICBdLFxuICAgICAgICB0eXBlOiBcInR1cGxlXCJcbiAgICAgIH0sXG4gICAgICB7IHR5cGU6IFwiYnl0ZXMzMlwiIH1cbiAgICBdLFxuICAgIFt3ZWJBdXRobkRhdGEsIGF1dGhlbnRpY2F0b3JJZEhhc2hdXG4gICk7XG4gIGNvbnN0IHJlZ2lzdHJ5Q29uZmlnID0ge1xuICAgIGF0dGVzdGVyczogW2F0dGVzdGVyXSxcbiAgICByZWdpc3RyeSxcbiAgICB0aHJlc2hvbGQ6IDFuXG4gIH07XG4gIGNvbnN0IGJvb3RzdHJhcENhbGwgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgIGFiaTogW1xuICAgICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICB7IG5hbWU6IFwidmFsaWRhdG9yXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgeyBuYW1lOiBcInZhbGlkYXRvckluaXREYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInJlZ2lzdHJ5XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJhdHRlc3RlcnNcIiwgdHlwZTogXCJhZGRyZXNzW11cIiB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhyZXNob2xkXCIsIHR5cGU6IFwidWludDhcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbmFtZTogXCJyZWdpc3RyeUNvbmZpZ1wiLFxuICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImluaXROZXh1c1dpdGhTaW5nbGVWYWxpZGF0b3JcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgXSxcbiAgICBhcmdzOiBbd2ViQXV0aG5WYWxpZGF0b3IsIHZhbGlkYXRvckluaXREYXRhLCByZWdpc3RyeUNvbmZpZ10sXG4gICAgZnVuY3Rpb25OYW1lOiBcImluaXROZXh1c1dpdGhTaW5nbGVWYWxpZGF0b3JcIlxuICB9KTtcbiAgY29uc3QgaW5pdERhdGEgPSBlbmNvZGVBYmlQYXJhbWV0ZXJzKFt7IHR5cGU6IFwiYWRkcmVzc1wiIH0sIHsgdHlwZTogXCJieXRlc1wiIH1dLCBbYm9vdHN0cmFwcGVyLCBib290c3RyYXBDYWxsXSk7XG4gIHJldHVybiBwcmVkaWN0UHJveHlBZGRyZXNzKGFjY291bnRJbXBsZW1lbnRhdGlvbiwgc2FsdCwgaW5pdERhdGEsIGZhY3RvcnlBZGRyZXNzKTtcbn1cbmZ1bmN0aW9uIHByZWRpY3RQcm94eUFkZHJlc3MoaW1wbGVtZW50YXRpb24sIHNhbHQsIGluaXREYXRhLCBkZXBsb3llcikge1xuICBjb25zdCBpbml0aWFsaXplQ2FsbCA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgYWJpOiBbXG4gICAgICB7XG4gICAgICAgIGlucHV0czogW3sgbmFtZTogXCJkYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICAgICAgbmFtZTogXCJpbml0aWFsaXplQWNjb3VudFwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGFyZ3M6IFtpbml0RGF0YV0sXG4gICAgZnVuY3Rpb25OYW1lOiBcImluaXRpYWxpemVBY2NvdW50XCJcbiAgfSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQXJncyA9IGVuY29kZUFiaVBhcmFtZXRlcnMoXG4gICAgW3sgdHlwZTogXCJhZGRyZXNzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfV0sXG4gICAgW2ltcGxlbWVudGF0aW9uLCBpbml0aWFsaXplQ2FsbF1cbiAgKTtcbiAgY29uc3QgbmV4dXNQcm94eUNyZWF0aW9uQ29kZSA9IFwiMHg2MDgwNjA0MDUyNjEwMmM4ODAzODAzODA2MTAwMTQ4MTYxMDE4YzU2NWI5MjgzMzk4MTAxNjA0MDgyODIwMzEyNjEwMTg4NTc4MTUxNjAwMTYwMDE2MGEwMWIwMzgxMTY5MjkwOTE5MDgzODMwMzYxMDE4ODU3NjAyMDgxMDE1MTkwNjAwMTYwMDE2MDQwMWIwMzgyMTE2MTAxODg1NzAxOTI4MTYwMWY4NTAxMTIxNTYxMDE4ODU3ODM1MTYxMDA2ZTYxMDA2OTgyNjEwMWM1NTY1YjYxMDE4YzU2NWI5NDgxODY1MjYwMjA4NjAxOTM2MDIwODM4MzAxMDExMTYxMDE4ODU3ODE1ZjkyNjAyMDgwOTMwMTg2NWU4NjAxMDE1MjYwMDE3ZjkwYjc3MmMyY2I4YTUxYWE3YThhNjVmYzIzNTQzYzZkMDIyZDViM2Y4ZTJiOTJlZWQ3OWZiYTdlZWY4MjkzMDA1ZDgyM2IxNTYxMDE3NjU3N2YzNjA4OTRhMTNiYTFhMzIxMDY2N2M4Mjg0OTJkYjk4ZGNhM2UyMDc2Y2MzNzM1YTkyMGEzY2E1MDVkMzgyYmJjODA1NDYwMDE2MDAxNjBhMDFiMDMxOTE2ODIxNzkwNTU3ZmJjN2NkNzVhMjBlZTI3ZmQ5YWRlYmFiMzIwNDFmNzU1MjE0ZGJjNmJmZmE5MGNjMDIyNWIzOWRhMmU1YzJkM2I1ZjgwYTI4MjUxMTU2MTAxNWU1NzVmODA5MTYxMDE0Njk0NTE5MDg0NWFmNDNkMTU2MTAxNTY1NzNkOTE2MTAxMzc2MTAwNjk4NDYxMDFjNTU2NWI5MjgzNTIzZDVmNjAyMDg1MDEzZTYxMDFlMDU2NWI1MDViNjA0MDUxNjA4OTkwODE2MTAyM2Y4MjM5ZjM1YjYwNjA5MTYxMDFlMDU2NWI1MDUwNTAzNDE1NjEwMTQ4NTc2M2IzOTg5NzlmNjBlMDFiNWY1MjYwMDQ1ZmZkNWI2MzRjOWM4Y2UzNjBlMDFiNWY1MjYwMDQ1MjYwMjQ1ZmZkNWI1ZjgwZmQ1YjYwNDA1MTkxOTA2MDFmMDE2MDFmMTkxNjgyMDE2MDAxNjAwMTYwNDAxYjAzODExMTgzODIxMDE3NjEwMWIxNTc2MDQwNTI1NjViNjM0ZTQ4N2I3MTYwZTAxYjVmNTI2MDQxNjAwNDUyNjAyNDVmZmQ1YjYwMDE2MDAxNjA0MDFiMDM4MTExNjEwMWIxNTc2MDFmMDE2MDFmMTkxNjYwMjAwMTkwNTY1YjkwNjEwMjA0NTc1MDgwNTExNTYxMDFmNTU3ODA1MTkwNjAyMDAxZmQ1YjYzZDZiZGEyNzU2MGUwMWI1ZjUyNjAwNDVmZmQ1YjgxNTExNTgwNjEwMjM1NTc1YjYxMDIxNTU3NTA5MDU2NWI2Mzk5OTZiMzE1NjBlMDFiNWY5MDgxNTI2MDAxNjAwMTYwYTAxYjAzOTE5MDkxMTY2MDA0NTI2MDI0OTBmZDViNTA4MDNiMTU2MTAyMGQ1NmZlNjA4MDYwNDA1MjM2MTU2MDUxNTc3ZjM2MDg5NGExM2JhMWEzMjEwNjY3YzgyODQ5MmRiOThkY2EzZTIwNzZjYzM3MzVhOTIwYTNjYTUwNWQzODJiYmM1NDVmOTA4MTkwNjAwMTYwMDE2MGEwMWIwMzE2MzY4MjgwMzc4MTM2OTE1YWY0M2Q1ZjgwM2UxNTYwNGQ1NzNkNWZmMzViM2Q1ZmZkNWIwMGZlYTI2NDY5NzA2NjczNTgyMjEyMjA0MWI1ZjcwYTM1MTk1MjE0MjIyM2YyMjUwNGNhN2I0ZTZkOTc1ZjNhMzAyZDExNGZmODIwNDQyZmNmODE1YWMyNjQ3MzZmNmM2MzQzMDAwODFiMDAzM1wiO1xuICBjb25zdCBpbml0Q29kZUhhc2ggPSBrZWNjYWsyNTYoZW5jb2RlUGFja2VkKFtcImJ5dGVzXCIsIFwiYnl0ZXNcIl0sIFtuZXh1c1Byb3h5Q3JlYXRpb25Db2RlLCBjb25zdHJ1Y3RvckFyZ3NdKSk7XG4gIHJldHVybiBnZXRDcmVhdGUyQWRkcmVzcyh7XG4gICAgYnl0ZWNvZGVIYXNoOiBpbml0Q29kZUhhc2gsXG4gICAgZnJvbTogZGVwbG95ZXIsXG4gICAgc2FsdFxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2Vucy50c1xuYXN5bmMgZnVuY3Rpb24gcmV2ZXJzZVJlc29sdmVFbnMoYWRkcmVzcykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RU5TX0FQSV9VUkx9L3JldmVyc2UvJHthZGRyZXNzfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRU5TIEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLFxuICAgICAgbmFtZTogZGF0YS5uYW1lIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZTpcIiwgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL3BvcHVwLnRzXG5pbXBvcnQgeyBycGNFcnJvcnMgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcbnZhciBQT1BVUF9XSURUSDIgPSA0MjA7XG52YXIgUE9QVVBfSEVJR0hUMiA9IDY1MDtcbnZhciBvcGVuUG9wdXAgPSAodXJsKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSAod2luZG93LmlubmVyV2lkdGggLSBQT1BVUF9XSURUSDIpIC8gMiArIHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCB0b3AgPSAod2luZG93LmlubmVySGVpZ2h0IC0gUE9QVVBfSEVJR0hUMikgLyAyICsgd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHBvcHVwSWQgPSBgd2FsbGV0XyR7d2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKX1gO1xuICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgcG9wdXBJZCwgYHdpZHRoPSR7UE9QVVBfV0lEVEgyfSwgaGVpZ2h0PSR7UE9QVVBfSEVJR0hUMn0sIGxlZnQ9JHtsZWZ0fSwgdG9wPSR7dG9wfWApO1xuICBwb3B1cD8uZm9jdXMoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbChcIlBvcCB1cCB3aW5kb3cgZmFpbGVkIHRvIG9wZW5cIik7XG4gIH1cbiAgcmV0dXJuIHBvcHVwO1xufTtcbnZhciBjbG9zZVBvcHVwID0gKHBvcHVwKSA9PiB7XG4gIGlmIChwb3B1cCAmJiAhcG9wdXAuY2xvc2VkKSB7XG4gICAgcG9wdXAub3BlbmVyPy5mb2N1cygpO1xuICAgIHBvcHVwLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9zdHJpbmdzLnRzXG52YXIgaGV4U3RyaW5nRnJvbU51bWJlciA9IChudW0pID0+IHtcbiAgcmV0dXJuIGAweCR7QmlnSW50KG51bSkudG9TdHJpbmcoMTYpfWA7XG59O1xudmFyIHNhZmVKc29uU3RyaW5naWZ5ID0gKG9iaikgPT4gSlNPTi5zdHJpbmdpZnkob2JqLCAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgKyBcIm5cIiA6IHZhbHVlLCAyKTtcblxuLy8gc3JjL2NvbW11bmljYXRvci50c1xudmFyIENvbW11bmljYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBhcHBNZXRhZGF0YSwgb25EaXNjb25uZWN0Q2FsbGJhY2sgfSkge1xuICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvLyBwb3N0cyBhIG1lc3NhZ2UgdG8gdGhlIHBvcHVwIHdpbmRvd1xuICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgcG9wdXAgPSBhd2FpdCB0aGlzLndhaXRGb3JQb3B1cExvYWRlZCgpO1xuICAgICAgcG9wdXAucG9zdE1lc3NhZ2UobWVzc2FnZSwgdGhpcy51cmwub3JpZ2luKTtcbiAgICB9O1xuICAgIC8vIHBvc3RzIGEgcmVxdWVzdCB0byB0aGUgcG9wdXAgd2luZG93IGFuZCB3YWl0cyBmb3IgYSByZXNwb25zZVxuICAgIHRoaXMucG9zdFJlcXVlc3RBbmRXYWl0Rm9yUmVzcG9uc2UgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5vbk1lc3NhZ2UoKHsgcmVxdWVzdElkIH0pID0+IHJlcXVlc3RJZCA9PT0gcmVxdWVzdC5yZXF1ZXN0SWQpO1xuICAgICAgdGhpcy5wb3N0TWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZVByb21pc2U7XG4gICAgfTtcbiAgICAvLyBsaXN0ZW5zIGZvciBtZXNzYWdlcyBmcm9tIHRoZSBwb3B1cCB3aW5kb3cgdGhhdCBtYXRjaCBhIGdpdmVuIHByZWRpY2F0ZVxuICAgIHRoaXMub25NZXNzYWdlID0gKHByZWRpY2F0ZSkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLnVybC5vcmlnaW4pIHJldHVybjtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5zZXQobGlzdGVuZXIsIHsgcmVqZWN0IH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBjbG9zZXMgdGhlIHBvcHVwLCByZWplY3RzIGFsbCByZXF1ZXN0cyBhbmQgY2xlYXJzIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub25SZXF1ZXN0Q2FuY2VsbGVkID0gKCkgPT4ge1xuICAgICAgY2xvc2VQb3B1cCh0aGlzLnBvcHVwKTtcbiAgICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgoeyByZWplY3QgfSwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgcmVqZWN0KHByb3ZpZGVyRXJyb3JzLnVzZXJSZWplY3RlZFJlcXVlc3QoKSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvLyB3YWl0cyBmb3IgdGhlIHBvcHVwIHdpbmRvdyB0byBmdWxseSBsb2FkIGFuZCB0aGVuIHNlbmRzIGEgdmVyc2lvbiBtZXNzYWdlXG4gICAgdGhpcy53YWl0Rm9yUG9wdXBMb2FkZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wb3B1cCAmJiAhdGhpcy5wb3B1cC5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5wb3B1cC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucG9wdXApO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3B1cCA9IG9wZW5Qb3B1cCh0aGlzLnVybCk7XG4gICAgICB0aGlzLm9uTWVzc2FnZSgoeyBldmVudCB9KSA9PiBldmVudCA9PT0gXCJQT1BVUF9VTkxPQURFRFwiIC8qIFBPUFVQX1VOTE9BREVEICovKS50aGVuKHRoaXMub25SZXF1ZXN0Q2FuY2VsbGVkKS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub25NZXNzYWdlKCh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlNES19ESVNDT05ORUNUXCIgLyogU0RLX0RJU0NPTk5FQ1QgKi8pLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdENhbGxiYWNrPy4oKTtcbiAgICAgICAgdGhpcy5vblJlcXVlc3RDYW5jZWxsZWQoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMub25NZXNzYWdlKFxuICAgICAgICAoeyBldmVudCB9KSA9PiBldmVudCA9PT0gXCJQT1BVUF9MT0FERURcIiAvKiBQT1BVUF9MT0FERUQgKi9cbiAgICAgICkudGhlbigobWVzc2FnZSkgPT4ge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBjaGFpbklkOiBERUZBVUxUX0NIQUlOX0lELFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGFwcE1ldGFkYXRhOiB0aGlzLmFwcE1ldGFkYXRhLFxuICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgICAgc2RrVmVyc2lvbjogU0RLX1ZFUlNJT05cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50OiBcIlBPUFVQX0FQUF9DT05URVhUXCIgLyogUE9QVVBfQVBQX0NPTlRFWFQgKi8sXG4gICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5yZXF1ZXN0SWRcbiAgICAgICAgfSk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcHVwKSB0aHJvdyBycGNFcnJvcnMyLmludGVybmFsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwoU0RLX0JBQ0tFTkRfVVJMKTtcbiAgICB0aGlzLmFwcE1ldGFkYXRhID0gYXBwTWV0YWRhdGE7XG4gICAgdGhpcy5vbkRpc2Nvbm5lY3RDYWxsYmFjayA9IG9uRGlzY29ubmVjdENhbGxiYWNrO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcHJvdmlkZXIudHNcbmltcG9ydCB7IGVycm9yQ29kZXMsIHByb3ZpZGVyRXJyb3JzIGFzIHByb3ZpZGVyRXJyb3JzMiwgcnBjRXJyb3JzIGFzIHJwY0Vycm9yczQsIHNlcmlhbGl6ZUVycm9yIH0gZnJvbSBcIkBtZXRhbWFzay9ycGMtZXJyb3JzXCI7XG5cbi8vIHNyYy9zdG9yYWdlL3N0b3JhZ2UudHNcbnZhciBtZW1vcnlTdG9yYWdlID0ge307XG52YXIgR2VtaW5pU3RvcmFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBzY29wZSA9IFwiQGdlbWluaVwiLCBtb2R1bGUgPSBcIndhbGxldFwiIH0gPSB7fSkge1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgfVxuICBzY29wZWRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGAke3RoaXMuc2NvcGV9LiR7dGhpcy5tb2R1bGV9LiR7a2V5fWA7XG4gIH1cbiAgYXN5bmMgc3RvcmVPYmplY3Qoa2V5LCBpdGVtKSB7XG4gICAgY29uc3QganNvbiA9IHNhZmVKc29uU3RyaW5naWZ5KGl0ZW0pO1xuICAgIGF3YWl0IHRoaXMuc2V0SXRlbShrZXksIGpzb24pO1xuICB9XG4gIGFzeW5jIGxvYWRPYmplY3Qoa2V5LCBmYWxsYmFjaykge1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmVPYmplY3Qoa2V5LCBmYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBKU09OIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc2NvcGVkLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUsIHVzaW5nIG1lbW9yeSBzdG9yYWdlXCIsIGUpO1xuICAgICAgbWVtb3J5U3RvcmFnZVtzY29wZWRdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldEl0ZW0oa2V5KSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHNjb3BlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUsIHVzaW5nIG1lbW9yeSBzdG9yYWdlXCIsIGUpO1xuICAgICAgcmV0dXJuIG1lbW9yeVN0b3JhZ2Vbc2NvcGVkXSB8fCBudWxsO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyByZW1vdmVJdGVtKGtleSkge1xuICAgIGNvbnN0IHNjb3BlZCA9IHRoaXMuc2NvcGVkS2V5KGtleSk7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNjb3BlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUsIHVzaW5nIG1lbW9yeSBzdG9yYWdlXCIsIGUpO1xuICAgICAgZGVsZXRlIG1lbW9yeVN0b3JhZ2Vbc2NvcGVkXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVtb3ZlSXRlbXMoa2V5cykge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrZXkpID0+IHRoaXMucmVtb3ZlSXRlbShrZXkpKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdG9yYWdlL3N0b3JhZ2VJbnRlcmZhY2UudHNcbnZhciBTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVkgPSBcImV0aC1hY2NvdW50c1wiO1xudmFyIFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkgPSBcImV0aC1hY3RpdmUtY2hhaW5cIjtcbnZhciBTVE9SQUdFX1BBU1NLRVlfQ1JFREVOVElBTF9LRVkgPSBcInBhc3NrZXktY3JlZGVudGlhbFwiO1xudmFyIFNUT1JBR0VfUFJFU0VSVkVEX1BBU1NLRVlfQ1JFREVOVElBTFNfS0VZID0gXCJwcmVzZXJ2ZWQtcGFzc2tleS1jcmVkZW50aWFsc1wiO1xudmFyIFNUT1JBR0VfU01BUlRfQUNDT1VOVF9LRVkgPSBcInNtYXJ0LWFjY291bnRcIjtcbnZhciBTVE9SQUdFX1NFVFRJTkdTX0tFWSA9IFwic2V0dGluZ3NcIjtcbnZhciBTVE9SQUdFX1dDX1JFUVVFU1RTX0tFWSA9IFwid2MtcmVxdWVzdHNcIjtcbnZhciBTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVkgPSBcImNhbGwtYmF0Y2hlc1wiO1xuXG4vLyBzcmMvd2FsbGV0cy93YWxsZXQudHNcbmZ1bmN0aW9uIGlzQ2hhaW5TdXBwb3J0ZWRCeUdlbWluaVN3KGNoYWluSWQpIHtcbiAgcmV0dXJuIFNVUFBPUlRFRF9DSEFJTl9JRFMuaW5jbHVkZXMoY2hhaW5JZCk7XG59XG52YXIgR2VtaW5pV2FsbGV0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGFwcE1ldGFkYXRhLCBjaGFpbiwgb25EaXNjb25uZWN0Q2FsbGJhY2ssIHN0b3JhZ2UgfSkge1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLmNoYWluID0geyBpZDogREVGQVVMVF9DSEFJTl9JRCB9O1xuICAgIHRoaXMuY29tbXVuaWNhdG9yID0gbmV3IENvbW11bmljYXRvcih7XG4gICAgICBhcHBNZXRhZGF0YSxcbiAgICAgIG9uRGlzY29ubmVjdENhbGxiYWNrXG4gICAgfSk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZSB8fCBuZXcgR2VtaW5pU3RvcmFnZSgpO1xuICAgIGNvbnN0IGZhbGxiYWNrQ2hhaW5JZCA9IGNoYWluPy5pZCA/PyBERUZBVUxUX0NIQUlOX0lEO1xuICAgIGNvbnN0IGZhbGxiYWNrUnBjVXJsID0gY2hhaW4/LnJwY1VybCA/PyBnZXREZWZhdWx0UnBjVXJsKGZhbGxiYWNrQ2hhaW5JZCk7XG4gICAgY29uc3QgZGVmYXVsdENoYWluID0ge1xuICAgICAgaWQ6IGZhbGxiYWNrQ2hhaW5JZCxcbiAgICAgIHJwY1VybDogZmFsbGJhY2tScGNVcmxcbiAgICB9O1xuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLmluaXRpYWxpemVGcm9tU3RvcmFnZShkZWZhdWx0Q2hhaW4pO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemVGcm9tU3RvcmFnZShkZWZhdWx0Q2hhaW4pIHtcbiAgICBjb25zdCBmYWxsYmFja0NoYWluID0ge1xuICAgICAgLi4uZGVmYXVsdENoYWluLFxuICAgICAgcnBjVXJsOiBkZWZhdWx0Q2hhaW4ucnBjVXJsIHx8IGdldERlZmF1bHRScGNVcmwoZGVmYXVsdENoYWluLmlkKVxuICAgIH07XG4gICAgY29uc3QgW3N0b3JlZENoYWluLCBzdG9yZWRBY2NvdW50c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnN0b3JhZ2UubG9hZE9iamVjdChTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLCBmYWxsYmFja0NoYWluKSxcbiAgICAgIHRoaXMuc3RvcmFnZS5sb2FkT2JqZWN0KFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSwgdGhpcy5hY2NvdW50cylcbiAgICBdKTtcbiAgICB0aGlzLmNoYWluID0ge1xuICAgICAgLi4uc3RvcmVkQ2hhaW4sXG4gICAgICBycGNVcmw6IHN0b3JlZENoYWluLnJwY1VybCB8fCBnZXREZWZhdWx0UnBjVXJsKHN0b3JlZENoYWluLmlkKVxuICAgIH07XG4gICAgdGhpcy5hY2NvdW50cyA9IHN0b3JlZEFjY291bnRzO1xuICB9XG4gIGFzeW5jIGVuc3VyZUluaXRpYWxpemVkKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdFByb21pc2U7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZXZlbnQ6IFwiU0RLX0NPTk5FQ1RcIiAvKiBTREtfQ09OTkVDVCAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHRoaXMuYWNjb3VudHMgPSByZXNwb25zZS5kYXRhLmFkZHJlc3MgPyBbcmVzcG9uc2UuZGF0YS5hZGRyZXNzXSA6IFtdO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksIHRoaXMuYWNjb3VudHMpO1xuICAgIHJldHVybiB0aGlzLmFjY291bnRzO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9FVEhfQUNDT1VOVFNfS0VZLCB0aGlzLmFjY291bnRzKTtcbiAgfVxuICBhc3luYyBzd2l0Y2hDaGFpbih7IGlkIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgaWYgKGlzQ2hhaW5TdXBwb3J0ZWRCeUdlbWluaVN3KGlkKSkge1xuICAgICAgdGhpcy5jaGFpbiA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJwY1VybDogZ2V0RGVmYXVsdFJwY1VybChpZClcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSwgdGhpcy5jaGFpbik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YTogaWQsXG4gICAgICBldmVudDogXCJTREtfU1dJVENIX0NIQUlOXCIgLyogU0RLX1NXSVRDSF9DSEFJTiAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmVycm9yID8/IFwiVW5zdXBwb3J0ZWQgY2hhaW4uXCI7XG4gIH1cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4RGF0YSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiB0eERhdGEsXG4gICAgICBldmVudDogXCJTREtfU0VORF9UUkFOU0FDVElPTlwiIC8qIFNES19TRU5EX1RSQU5TQUNUSU9OICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgYXN5bmMgc2lnbkRhdGEoeyBtZXNzYWdlIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YTogeyBtZXNzYWdlIH0sXG4gICAgICBldmVudDogXCJTREtfU0lHTl9EQVRBXCIgLyogU0RLX1NJR05fREFUQSAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoe1xuICAgIG1lc3NhZ2UsXG4gICAgdHlwZXMsXG4gICAgcHJpbWFyeVR5cGUsXG4gICAgZG9tYWluXG4gIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YToge1xuICAgICAgICBkb21haW4sXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICB0eXBlc1xuICAgICAgfSxcbiAgICAgIGV2ZW50OiBcIlNES19TSUdOX1RZUEVEX0RBVEFcIiAvKiBTREtfU0lHTl9UWVBFRF9EQVRBICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgYXN5bmMgb3BlblNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YToge30sXG4gICAgICBldmVudDogXCJTREtfT1BFTl9TRVRUSU5HU1wiIC8qIFNES19PUEVOX1NFVFRJTkdTICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gIH1cbiAgLy8gRUlQLTU3OTIgV2FsbGV0IENhbGwgQVBJIE1ldGhvZHNcbiAgZ2V0Q2FwYWJpbGl0aWVzKHJlcXVlc3RlZENoYWluSWRzKSB7XG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0ge307XG4gICAgY29uc3QgY2hhaW5JZHMgPSByZXF1ZXN0ZWRDaGFpbklkcz8ubWFwKChpZCkgPT4gcGFyc2VJbnQoaWQsIDE2KSkgfHwgW3RoaXMuY2hhaW4uaWRdO1xuICAgIGZvciAoY29uc3QgY2hhaW5JZCBvZiBjaGFpbklkcykge1xuICAgICAgY29uc3QgY2hhaW5JZEhleCA9IGhleFN0cmluZ0Zyb21OdW1iZXIoY2hhaW5JZCk7XG4gICAgICBjYXBhYmlsaXRpZXNbY2hhaW5JZEhleF0gPSB7XG4gICAgICAgIGF0b21pYzoge1xuICAgICAgICAgIHN0YXR1czogXCJzdXBwb3J0ZWRcIlxuICAgICAgICAgIC8vIFNtYXJ0IGFjY291bnRzIHN1cHBvcnQgYXRvbWljIGJhdGNoIGV4ZWN1dGlvblxuICAgICAgICB9LFxuICAgICAgICBwYXltYXN0ZXJTZXJ2aWNlOiB7XG4gICAgICAgICAgc3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXRpZXM7XG4gIH1cbiAgYXN5bmMgc2VuZENhbGxzKHBhcmFtcykge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBiYXRjaElkID0gd2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKSB8fCBgYmF0Y2gtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YDtcbiAgICBjb25zdCByZXF1ZXN0ZWRDaGFpbklkID0gcGFyc2VJbnQocGFyYW1zLmNoYWluSWQsIDE2KTtcbiAgICBpZiAocmVxdWVzdGVkQ2hhaW5JZCAhPT0gdGhpcy5jaGFpbi5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiBtaXNtYXRjaC4gRXhwZWN0ZWQgJHt0aGlzLmNoYWluLmlkfSwgZ290ICR7cmVxdWVzdGVkQ2hhaW5JZH1gKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuY2FsbHMgfHwgcGFyYW1zLmNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FsbHMgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoTWV0YWRhdGEgPSB7XG4gICAgICBjYWxsczogcGFyYW1zLmNhbGxzLFxuICAgICAgY2FwYWJpbGl0aWVzOiBwYXJhbXMuY2FwYWJpbGl0aWVzLFxuICAgICAgY2hhaW5JZDogcGFyYW1zLmNoYWluSWQsXG4gICAgICBmcm9tOiBwYXJhbXMuZnJvbSxcbiAgICAgIGlkOiBiYXRjaElkLFxuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgY29uc3QgYmF0Y2hlcyA9IGF3YWl0IHRoaXMuc3RvcmFnZS5sb2FkT2JqZWN0KFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSwge30pO1xuICAgIGJhdGNoZXNbYmF0Y2hJZF0gPSBiYXRjaE1ldGFkYXRhO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVksIGJhdGNoZXMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNhbGxzOiBwYXJhbXMuY2FsbHNcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnQ6IFwiU0RLX1NFTkRfQkFUQ0hfQ0FMTFNcIiAvKiBTREtfU0VORF9CQVRDSF9DQUxMUyAqLyxcbiAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGJhdGNoTWV0YWRhdGEudHJhbnNhY3Rpb25IYXNoID0gcmVzcG9uc2UuZGF0YS5oYXNoO1xuICAgICAgYmF0Y2hNZXRhZGF0YS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgIGJhdGNoZXNbYmF0Y2hJZF0gPSBiYXRjaE1ldGFkYXRhO1xuICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSwgYmF0Y2hlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICBjYWlwMzQ1OiB7XG4gICAgICAgICAgICBjYWlwMjogYGVpcDE1NToke3JlcXVlc3RlZENoYWluSWR9YCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaGVzOiBbcmVzcG9uc2UuZGF0YS5oYXNoXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IGJhdGNoSWRcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGJhdGNoTWV0YWRhdGEuc3RhdHVzID0gXCJmYWlsZWRcIjtcbiAgICAgIGJhdGNoZXNbYmF0Y2hJZF0gPSBiYXRjaE1ldGFkYXRhO1xuICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSwgYmF0Y2hlcyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2FsbHNTdGF0dXMoYmF0Y2hJZCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBiYXRjaGVzID0gYXdhaXQgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9DQUxMX0JBVENIRVNfS0VZLCB7fSk7XG4gICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2JhdGNoSWRdO1xuICAgIGlmICghYmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBidW5kbGUgSUQ6ICR7YmF0Y2hJZH1gKTtcbiAgICB9XG4gICAgaWYgKGJhdGNoLnRyYW5zYWN0aW9uSGFzaCAmJiB0aGlzLmNoYWluLnJwY1VybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmNoYWluLnJwY1VybCwge1xuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBwYXJhbXM6IFtiYXRjaC50cmFuc2FjdGlvbkhhc2hdXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBqc29uLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICBjb25zdCByZWNlaXB0U3RhdHVzID0gcmVjZWlwdC5zdGF0dXMgPT09IFwiMHgxXCIgPyBcImNvbmZpcm1lZFwiIDogXCJyZXZlcnRlZFwiO1xuICAgICAgICAgIGJhdGNoLnN0YXR1cyA9IHJlY2VpcHRTdGF0dXM7XG4gICAgICAgICAgYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoO1xuICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVksIGJhdGNoZXMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdG9taWM6IHRydWUsXG4gICAgICAgICAgICBjaGFpbklkOiBiYXRjaC5jaGFpbklkLFxuICAgICAgICAgICAgaWQ6IGJhdGNoSWQsXG4gICAgICAgICAgICByZWNlaXB0czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmxvY2tIYXNoOiByZWNlaXB0LmJsb2NrSGFzaCxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogcmVjZWlwdC5ibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiByZWNlaXB0Lmdhc1VzZWQsXG4gICAgICAgICAgICAgICAgbG9nczogcmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICAgIHRvcGljczogbG9nLnRvcGljc1xuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlY2VpcHRTdGF0dXMgPT09IFwiY29uZmlybWVkXCIgPyBcInN1Y2Nlc3NcIiA6IFwicmV2ZXJ0ZWRcIixcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdGF0dXM6IHJlY2VpcHRTdGF0dXMgPT09IFwiY29uZmlybWVkXCIgPyAyMDAgOiA1MDAsXG4gICAgICAgICAgICB2ZXJzaW9uOiBcIjIuMC4wXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHRyYW5zYWN0aW9uIHJlY2VpcHQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgc3dpdGNoIChiYXRjaC5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIHN0YXR1c0NvZGUgPSAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbmZpcm1lZFwiOlxuICAgICAgICBzdGF0dXNDb2RlID0gMjAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmV2ZXJ0ZWRcIjpcbiAgICAgICAgc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGF0dXNDb2RlID0gMTAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXRvbWljOiB0cnVlLFxuICAgICAgY2hhaW5JZDogYmF0Y2guY2hhaW5JZCxcbiAgICAgIGlkOiBiYXRjaElkLFxuICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlLFxuICAgICAgdmVyc2lvbjogXCIyLjAuMFwiXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaG93Q2FsbHNTdGF0dXMoYmF0Y2hJZCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBiYXRjaGVzID0gYXdhaXQgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9DQUxMX0JBVENIRVNfS0VZLCB7fSk7XG4gICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2JhdGNoSWRdO1xuICAgIGlmICghYmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBidW5kbGUgSUQ6ICR7YmF0Y2hJZH1gKTtcbiAgICB9XG4gIH1cbiAgc2VuZE1lc3NhZ2VUb1BvcHVwKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tdW5pY2F0b3IucG9zdFJlcXVlc3RBbmRXYWl0Rm9yUmVzcG9uc2Uoe1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIHJlcXVlc3RJZDogd2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcHJvdmlkZXIudXRpbHMudHNcbmltcG9ydCB7IHJwY0Vycm9ycyBhcyBycGNFcnJvcnMzIH0gZnJvbSBcIkBtZXRhbWFzay9ycGMtZXJyb3JzXCI7XG5pbXBvcnQgeyBpc0hleCB9IGZyb20gXCJ2aWVtXCI7XG52YXIgZmV0Y2hScGNSZXF1ZXN0ID0gYXN5bmMgKHJlcXVlc3QsIHJwY1VybCkgPT4ge1xuICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAuLi5yZXF1ZXN0LFxuICAgIGlkOiB3aW5kb3c/LmNyeXB0bz8ucmFuZG9tVVVJRCgpLFxuICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgfTtcbiAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93LmZldGNoKHJwY1VybCwge1xuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBtb2RlOiBcImNvcnNcIlxuICB9KTtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MoYXJncykge1xuICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgIHRocm93IHJwY0Vycm9yczMuaW52YWxpZFBhcmFtcyh7XG4gICAgICBtZXNzYWdlOiBcIkV4cGVjdGVkIGEgc2luZ2xlLCBub24tYXJyYXksIG9iamVjdCBhcmd1bWVudC5cIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInN0cmluZ1wiIHx8IG1ldGhvZC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBycGNFcnJvcnMzLmludmFsaWRQYXJhbXMoe1xuICAgICAgbWVzc2FnZTogXCInYXJncy5tZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwICYmICFBcnJheS5pc0FycmF5KHBhcmFtcykgJiYgKHR5cGVvZiBwYXJhbXMgIT09IFwib2JqZWN0XCIgfHwgcGFyYW1zID09PSBudWxsKSkge1xuICAgIHRocm93IHJwY0Vycm9yczMuaW52YWxpZFBhcmFtcyh7XG4gICAgICBtZXNzYWdlOiBcIidhcmdzLnBhcmFtcycgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYXJyYXkgaWYgcHJvdmlkZWQuXCJcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludCh0eCkge1xuICBjb25zdCBGSUVMRFNfVE9fTk9STUFMSVpFID0gW1widmFsdWVcIiwgXCJnYXNcIiwgXCJnYXNQcmljZVwiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibWF4RmVlUGVyR2FzXCJdO1xuICBjb25zdCBub3JtYWxpemVkID0geyAuLi50eCB9O1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIEZJRUxEU19UT19OT1JNQUxJWkUpIHtcbiAgICBpZiAoIShmaWVsZCBpbiB0eCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHZhbHVlID0gdHhbZmllbGRdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIGNvbnRpbnVlO1xuICAgIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICAgIG5vcm1hbGl6ZWRbZmllbGRdID0gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHNyYy9wcm92aWRlci9wcm92aWRlci50c1xudmFyIEdlbWluaVdhbGxldFByb3ZpZGVyID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlckV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyQ29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndhbGxldCA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBwcm92aWRlckNvbmZpZztcbiAgICBjb25zdCB1c2VyRGlzY29ubmVjdENhbGxiYWNrID0gcHJvdmlkZXJDb25maWcub25EaXNjb25uZWN0Q2FsbGJhY2s7XG4gICAgdGhpcy53YWxsZXQgPSBuZXcgR2VtaW5pV2FsbGV0KHtcbiAgICAgIC4uLnByb3ZpZGVyQ29uZmlnLFxuICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdXNlckRpc2Nvbm5lY3RDYWxsYmFjaz8uKCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZVJwY1JlcXVlc3RBcmdzKGFyZ3MpO1xuICAgICAgaWYgKCF0aGlzLndhbGxldD8uYWNjb3VudHM/Lmxlbmd0aCkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubWV0aG9kKSB7XG4gICAgICAgICAgY2FzZSBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIjoge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbGxldCkge1xuICAgICAgICAgICAgICBjb25zdCB1c2VyRGlzY29ubmVjdENhbGxiYWNrID0gdGhpcy5jb25maWcub25EaXNjb25uZWN0Q2FsbGJhY2s7XG4gICAgICAgICAgICAgIHRoaXMud2FsbGV0ID0gbmV3IEdlbWluaVdhbGxldCh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHVzZXJEaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2FsbGV0LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCB0aGlzLndhbGxldC5hY2NvdW50cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5ldF92ZXJzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgICBjYXNlIFwiZXRoX2NoYWluSWRcIjpcbiAgICAgICAgICAgIHJldHVybiBoZXhTdHJpbmdGcm9tTnVtYmVyKERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyRXJyb3JzMi51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCByZXNwb25zZTtcbiAgICAgIGxldCByZXF1ZXN0UGFyYW1zO1xuICAgICAgc3dpdGNoIChhcmdzLm1ldGhvZCkge1xuICAgICAgICBjYXNlIFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiOlxuICAgICAgICBjYXNlIFwiZXRoX2FjY291bnRzXCI6XG4gICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLndhbGxldC5hY2NvdW50cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldF92ZXJzaW9uXCI6XG4gICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLndhbGxldC5jaGFpbi5pZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV0aF9jaGFpbklkXCI6XG4gICAgICAgICAgcmVzcG9uc2UgPSBoZXhTdHJpbmdGcm9tTnVtYmVyKHRoaXMud2FsbGV0LmNoYWluLmlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBlcnNvbmFsX3NpZ25cIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9zaWduXCI6XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2lnbkRhdGEoe1xuICAgICAgICAgICAgYWNjb3VudDogcmVxdWVzdFBhcmFtc1sxXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHJlcXVlc3RQYXJhbXNbMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9yczQudHJhbnNhY3Rpb25SZWplY3RlZChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuaGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJldGhfc2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50KHJlcXVlc3RQYXJhbXNbMF0pO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHJlcXVlc3RQYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCI6IHtcbiAgICAgICAgICBjb25zdCByYXdQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICBsZXQgY2hhaW5JZDtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdQYXJhbXMpICYmIHJhd1BhcmFtc1swXT8uY2hhaW5JZCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KHJhd1BhcmFtc1swXS5jaGFpbklkLCAxNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYXdQYXJhbXMgJiYgdHlwZW9mIHJhd1BhcmFtcyA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcmF3UGFyYW1zICYmIE51bWJlci5pc0ludGVnZXIocmF3UGFyYW1zLmlkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHJhd1BhcmFtcy5pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAgICAgICBcIkludmFsaWQgY2hhaW4gaWQgYXJndW1lbnQuIEV4cGVjdGVkIFt7IGNoYWluSWQ6IGhleF9zdHJpbmcgfV0gb3IgeyBpZDogbnVtYmVyIH0uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc3dpdGNoQ2hhaW4oeyBpZDogY2hhaW5JZCB9KTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyRXJyb3JzMi5jdXN0b20oeyBjb2RlOiA0OTAyLCBtZXNzYWdlOiByZXNwb25zZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdGhpcy5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIGhleFN0cmluZ0Zyb21OdW1iZXIoY2hhaW5JZCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92MVwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3YzXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92NFwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFcIjoge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICBjb25zdCBzaWduZWRUeXBlZERhdGFQYXJhbXMgPSBKU09OLnBhcnNlKHJlcXVlc3RQYXJhbXNbMV0pO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICBhY2NvdW50OiByZXF1ZXN0UGFyYW1zWzBdLFxuICAgICAgICAgICAgZG9tYWluOiBzaWduZWRUeXBlZERhdGFQYXJhbXMuZG9tYWluLFxuICAgICAgICAgICAgbWVzc2FnZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgdHlwZXM6IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy50eXBlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBFSVAtNTc5MiBXYWxsZXQgQ2FsbCBBUElcbiAgICAgICAgY2FzZSBcIndhbGxldF9nZXRDYXBhYmlsaXRpZXNcIjoge1xuICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdHlQYXJhbXMgPSBBcnJheS5pc0FycmF5KGFyZ3MucGFyYW1zKSA/IGFyZ3MucGFyYW1zIDogdm9pZCAwO1xuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5nZXRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0eVBhcmFtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndhbGxldF9zZW5kQ2FsbHNcIjoge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZENhbGxzKHJlcXVlc3RQYXJhbXNbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfZ2V0Q2FsbHNTdGF0dXNcIjoge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0Q2FsbHNTdGF0dXMocmVxdWVzdFBhcmFtc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndhbGxldF9zaG93Q2FsbHNTdGF0dXNcIjoge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICBhd2FpdCB0aGlzLnNob3dDYWxsc1N0YXR1cyhyZXF1ZXN0UGFyYW1zWzBdKTtcbiAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogbm90IHlldCBpbXBsZW1lbnRlZCBvciB1bmNsZWFyIGlmIHdlIHN1cHBvcnRcbiAgICAgICAgY2FzZSBcImV0aF9lY1JlY292ZXJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zdWJzY3JpYmVcIjpcbiAgICAgICAgY2FzZSBcImV0aF91bnN1YnNjcmliZVwiOlxuICAgICAgICBjYXNlIFwicGVyc29uYWxfZWNSZWNvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblRyYW5zYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfd2F0Y2hBc3NldFwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X2dyYW50UGVybWlzc2lvbnNcIjpcbiAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0Lm1ldGhvZE5vdFN1cHBvcnRlZChcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGNhc2UgXCJldGhfc2lnblwiOlxuICAgICAgICBjYXNlIFwiZXRoX2NvaW5iYXNlXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiOlxuICAgICAgICAgIHRocm93IHJwY0Vycm9yczQubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIC8vIGNhbGwgcnBjIGRpcmVjdGx5IGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0LmNoYWluLnJwY1VybClcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9yczQuaW50ZXJuYWwoYFJQQyBVUkwgbWlzc2luZyBmb3IgY3VycmVudCBjaGFpbiAoJHt0aGlzLndhbGxldC5jaGFpbi5pZH0pYCk7XG4gICAgICAgICAgcmV0dXJuIGZldGNoUnBjUmVxdWVzdChhcmdzLCB0aGlzLndhbGxldC5jaGFpbi5ycGNVcmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgaWYgKGNvZGUgPT09IGVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkKSB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgfVxuICAvLyBjdXN0b20gd2FsbGV0IGZ1bmN0aW9uIHRvIG9wZW4gc2V0dGluZ3MgcGFnZVxuICBhc3luYyBvcGVuU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy53YWxsZXQ/Lm9wZW5TZXR0aW5ncygpO1xuICB9XG4gIC8vIEVJUC01NzkyIEltcGxlbWVudGF0aW9uIE1ldGhvZHMgLSBkZWxlZ2F0aW5nIHRvIHdhbGxldFxuICBnZXRDYXBhYmlsaXRpZXMocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLndhbGxldCkge1xuICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMyLnVuYXV0aG9yaXplZCgpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ZWRDaGFpbklkcyA9IHBhcmFtcz8uWzBdO1xuICAgIHJldHVybiB0aGlzLndhbGxldC5nZXRDYXBhYmlsaXRpZXMocmVxdWVzdGVkQ2hhaW5JZHMpO1xuICB9XG4gIGFzeW5jIHNlbmRDYWxscyhwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBwcm92aWRlckVycm9yczIudW5hdXRob3JpemVkKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy53YWxsZXQuc2VuZENhbGxzKHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHJwY0Vycm9yczQudHJhbnNhY3Rpb25SZWplY3RlZChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDYWxsc1N0YXR1cyhiYXRjaElkKSB7XG4gICAgaWYgKCF0aGlzLndhbGxldCkge1xuICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMyLnVuYXV0aG9yaXplZCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2FsbGV0LmdldENhbGxzU3RhdHVzKGJhdGNoSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBycGNFcnJvcnM0LmludmFsaWRQYXJhbXMoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2hvd0NhbGxzU3RhdHVzKGJhdGNoSWQpIHtcbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBwcm92aWRlckVycm9yczIudW5hdXRob3JpemVkKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndhbGxldC5zaG93Q2FsbHNTdGF0dXMoYmF0Y2hJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHJwY0Vycm9yczQuaW52YWxpZFBhcmFtcyhlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLndhbGxldCkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuY29uZmlnLnN0b3JhZ2UgfHwgbmV3IEdlbWluaVN0b3JhZ2UoKTtcbiAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVkpO1xuICAgICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkpO1xuICAgIH1cbiAgICB0aGlzLndhbGxldCA9IG51bGw7XG4gICAgdGhpcy5jb25maWcub25EaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgIGF3YWl0IHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgXCJVc2VyIGluaXRpYXRlZCBkaXNjb25uZWN0aW9uXCIpO1xuICAgIGF3YWl0IHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBbXSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb21tdW5pY2F0b3IsXG4gIERFRkFVTFRfQ0hBSU5fSUQsXG4gIEdlbWluaVNka0V2ZW50LFxuICBHZW1pbmlTdG9yYWdlLFxuICBHZW1pbmlXYWxsZXQsXG4gIEdlbWluaVdhbGxldFByb3ZpZGVyLFxuICBQT1BVUF9IRUlHSFQsXG4gIFBPUFVQX1dJRFRILFxuICBQbGF0Zm9ybVR5cGUsXG4gIFByb3ZpZGVyRXZlbnRFbWl0dGVyLFxuICBTREtfQkFDS0VORF9VUkwsXG4gIFNES19WRVJTSU9OLFxuICBTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVksXG4gIFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSxcbiAgU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSxcbiAgU1RPUkFHRV9QQVNTS0VZX0NSRURFTlRJQUxfS0VZLFxuICBTVE9SQUdFX1BSRVNFUlZFRF9QQVNTS0VZX0NSRURFTlRJQUxTX0tFWSxcbiAgU1RPUkFHRV9TRVRUSU5HU19LRVksXG4gIFNUT1JBR0VfU01BUlRfQUNDT1VOVF9LRVksXG4gIFNUT1JBR0VfV0NfUkVRVUVTVFNfS0VZLFxuICBiYXNlNjRUb0hleCxcbiAgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcsXG4gIGNhbGN1bGF0ZVYxQWRkcmVzcyxcbiAgY2FsY3VsYXRlV2FsbGV0QWRkcmVzcyxcbiAgY2xvc2VQb3B1cCxcbiAgY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludCxcbiAgZGVjb2RlQmFzZTY0LFxuICBlbmNvZGVCYXNlNjQsXG4gIGZldGNoUnBjUmVxdWVzdCxcbiAgZ2VuZXJhdGVBdXRoZW50aWNhdG9ySWRIYXNoLFxuICBoZXhTdHJpbmdGcm9tTnVtYmVyLFxuICBpc0NoYWluU3VwcG9ydGVkQnlHZW1pbmlTdyxcbiAgb3BlblBvcHVwLFxuICByZXZlcnNlUmVzb2x2ZUVucyxcbiAgc2FmZUpzb25TdHJpbmdpZnksXG4gIHV0ZjhTdHJpbmdUb0J1ZmZlcixcbiAgdmFsaWRhdGVScGNSZXF1ZXN0QXJncyxcbiAgdmFsaWRhdGVXZWJBdXRobktleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@gemini-wallet/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: function() { return /* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFZDtBQUN2QiwrREFBZSxzQ0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/OGRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/classes.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/classes.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EthereumProviderError: function() { return /* binding */ EthereumProviderError; },\n/* harmony export */   JsonRpcError: function() { return /* binding */ JsonRpcError; }\n/* harmony export */ });\n/* harmony import */ var _metamask_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/utils */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-safe-stringify */ \"(app-pages-browser)/./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/utils.mjs\");\nfunction $importDefault(module) {\n    if (module?.__esModule) {\n        return module.default;\n    }\n    return module;\n}\n\n\nconst safeStringify = $importDefault(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */\nclass JsonRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a non-empty string.');\n        }\n        if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.dataHasCause)(data)) {\n            // @ts-expect-error - Error class does accept options argument depending on runtime, but types are mapping to oldest supported\n            super(message, { cause: data.cause });\n            // Browser backwards-compatibility fallback\n            if (!(0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(this, 'cause')) {\n                Object.assign(this, { cause: data.cause });\n            }\n        }\n        else {\n            super(message);\n        }\n        if (data !== undefined) {\n            this.data = data;\n        }\n        this.code = code;\n    }\n    /**\n     * Get the error as JSON-serializable object.\n     *\n     * @returns A plain object with all public class properties.\n     */\n    serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message,\n        };\n        if (this.data !== undefined) {\n            // `this.data` is not guaranteed to be a plain object, but this simplifies\n            // the type guard below. We can safely cast it because we know it's a\n            // JSON-serializable value.\n            serialized.data = this.data;\n            if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(this.data)) {\n                serialized.data.cause = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.serializeCause)(this.data.cause);\n            }\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    /**\n     * Get a string representation of the serialized error, omitting any circular\n     * references.\n     *\n     * @returns A string representation of the serialized error.\n     */\n    toString() {\n        return safeStringify(this.serialize(), stringifyReplacer, 2);\n    }\n}\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nclass EthereumProviderError extends JsonRpcError {\n    /**\n     * Create an Ethereum Provider JSON-RPC error.\n     *\n     * @param code - The JSON-RPC error code. Must be an integer in the\n     * `1000 <= n <= 4999` range.\n     * @param message - The JSON-RPC error message.\n     * @param data - Optional data to include in the error.\n     */\n    constructor(code, message, data) {\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */\nfunction stringifyReplacer(_, value) {\n    if (value === '[Circular]') {\n        return undefined;\n    }\n    return value;\n}\n//# sourceMappingURL=classes.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2NsYXNzZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1o7QUFDakQscUNBQXFDLGdEQUFjO0FBQ1E7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQVk7QUFDeEI7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0EsaUJBQWlCLDREQUFXO0FBQzVCLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQWE7QUFDN0Isd0NBQXdDLDBEQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9jbGFzc2VzLm1qcz81NWQxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uICRpbXBvcnREZWZhdWx0KG1vZHVsZSkge1xuICAgIGlmIChtb2R1bGU/Ll9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlO1xufVxuaW1wb3J0IHsgaGFzUHJvcGVydHksIGlzUGxhaW5PYmplY3QgfSBmcm9tIFwiQG1ldGFtYXNrL3V0aWxzXCI7XG5pbXBvcnQgJHNhZmVTdHJpbmdpZnkgZnJvbSBcImZhc3Qtc2FmZS1zdHJpbmdpZnlcIjtcbmNvbnN0IHNhZmVTdHJpbmdpZnkgPSAkaW1wb3J0RGVmYXVsdCgkc2FmZVN0cmluZ2lmeSk7XG5pbXBvcnQgeyBkYXRhSGFzQ2F1c2UsIHNlcmlhbGl6ZUNhdXNlIH0gZnJvbSBcIi4vdXRpbHMubWpzXCI7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKlxuICogUGVybWl0cyBhbnkgaW50ZWdlciBlcnJvciBjb2RlLlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhSGFzQ2F1c2UoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBFcnJvciBjbGFzcyBkb2VzIGFjY2VwdCBvcHRpb25zIGFyZ3VtZW50IGRlcGVuZGluZyBvbiBydW50aW1lLCBidXQgdHlwZXMgYXJlIG1hcHBpbmcgdG8gb2xkZXN0IHN1cHBvcnRlZFxuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZTogZGF0YS5jYXVzZSB9KTtcbiAgICAgICAgICAgIC8vIEJyb3dzZXIgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZmFsbGJhY2tcbiAgICAgICAgICAgIGlmICghaGFzUHJvcGVydHkodGhpcywgJ2NhdXNlJykpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgY2F1c2U6IGRhdGEuY2F1c2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXJyb3IgYXMgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGB0aGlzLmRhdGFgIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0LCBidXQgdGhpcyBzaW1wbGlmaWVzXG4gICAgICAgICAgICAvLyB0aGUgdHlwZSBndWFyZCBiZWxvdy4gV2UgY2FuIHNhZmVseSBjYXN0IGl0IGJlY2F1c2Ugd2Uga25vdyBpdCdzIGFcbiAgICAgICAgICAgIC8vIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICAgICAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YS5jYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKHRoaXMuZGF0YS5jYXVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nIGFueSBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQLTExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBKc29uUnBjRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFdGhlcmV1bSBQcm92aWRlciBKU09OLVJQQyBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIC0gVGhlIEpTT04tUlBDIGVycm9yIGNvZGUuIE11c3QgYmUgYW4gaW50ZWdlciBpbiB0aGVcbiAgICAgKiBgMTAwMCA8PSBuIDw9IDQ5OTlgIHJhbmdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIEpTT04tUlBDIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIGRhdGEgLSBPcHRpb25hbCBkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29kZSBpcyBhIHZhbGlkIEpTT04tUlBDIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGNvZGUgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTk7XG59XG4vKipcbiAqIEEgSlNPTiByZXBsYWNlciBmdW5jdGlvbiB0aGF0IG9taXRzIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIF8gLSBUaGUga2V5IGJlaW5nIHJlcGxhY2VkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHJlcGxhY2VkLlxuICogQHJldHVybnMgVGhlIHZhbHVlIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3Nlcy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/classes.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/error-constants.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   errorCodes: function() { return /* binding */ errorCodes; },\n/* harmony export */   errorValues: function() { return /* binding */ errorValues; }\n/* harmony export */ });\nconst errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603,\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901,\n    },\n};\n/* eslint-disable @typescript-eslint/naming-convention */\nconst errorValues = {\n    '-32700': {\n        standard: 'JSON RPC 2.0',\n        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    },\n    '-32600': {\n        standard: 'JSON RPC 2.0',\n        message: 'The JSON sent is not a valid Request object.',\n    },\n    '-32601': {\n        standard: 'JSON RPC 2.0',\n        message: 'The method does not exist / is not available.',\n    },\n    '-32602': {\n        standard: 'JSON RPC 2.0',\n        message: 'Invalid method parameter(s).',\n    },\n    '-32603': {\n        standard: 'JSON RPC 2.0',\n        message: 'Internal JSON-RPC error.',\n    },\n    '-32000': {\n        standard: 'EIP-1474',\n        message: 'Invalid input.',\n    },\n    '-32001': {\n        standard: 'EIP-1474',\n        message: 'Resource not found.',\n    },\n    '-32002': {\n        standard: 'EIP-1474',\n        message: 'Resource unavailable.',\n    },\n    '-32003': {\n        standard: 'EIP-1474',\n        message: 'Transaction rejected.',\n    },\n    '-32004': {\n        standard: 'EIP-1474',\n        message: 'Method not supported.',\n    },\n    '-32005': {\n        standard: 'EIP-1474',\n        message: 'Request limit exceeded.',\n    },\n    '4001': {\n        standard: 'EIP-1193',\n        message: 'User rejected the request.',\n    },\n    '4100': {\n        standard: 'EIP-1193',\n        message: 'The requested account and/or method has not been authorized by the user.',\n    },\n    '4200': {\n        standard: 'EIP-1193',\n        message: 'The requested method is not supported by this Ethereum provider.',\n    },\n    '4900': {\n        standard: 'EIP-1193',\n        message: 'The provider is disconnected from all chains.',\n    },\n    '4901': {\n        standard: 'EIP-1193',\n        message: 'The provider is disconnected from the specified chain.',\n    },\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n//# sourceMappingURL=error-constants.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2Vycm9yLWNvbnN0YW50cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMubWpzP2YwNTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGVycm9yQ29kZXMgPSB7XG4gICAgcnBjOiB7XG4gICAgICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgICAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICAgICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgICAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICAgICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgICAgICBwYXJzZTogLTMyNzAwLFxuICAgICAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgICAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgICAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgICAgIGludGVybmFsOiAtMzI2MDMsXG4gICAgfSxcbiAgICBwcm92aWRlcjoge1xuICAgICAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgICAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxLFxuICAgIH0sXG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5leHBvcnQgY29uc3QgZXJyb3JWYWx1ZXMgPSB7XG4gICAgJy0zMjcwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC4nLFxuICAgIH0sXG4gICAgJy0zMjYwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC4nLFxuICAgIH0sXG4gICAgJy0zMjYwMSc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJyxcbiAgICB9LFxuICAgICctMzI2MDInOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS4nLFxuICAgIH0sXG4gICAgJy0zMjYwMyc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuJyxcbiAgICB9LFxuICAgICctMzIwMDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dC4nLFxuICAgIH0sXG4gICAgJy0zMjAwMSc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSBub3QgZm91bmQuJyxcbiAgICB9LFxuICAgICctMzIwMDInOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnUmVzb3VyY2UgdW5hdmFpbGFibGUuJyxcbiAgICB9LFxuICAgICctMzIwMDMnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQuJyxcbiAgICB9LFxuICAgICctMzIwMDQnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnTWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICB9LFxuICAgICctMzIwMDUnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBsaW1pdCBleGNlZWRlZC4nLFxuICAgIH0sXG4gICAgJzQwMDEnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgICAgICBtZXNzYWdlOiAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nLFxuICAgIH0sXG4gICAgJzQxMDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuJyxcbiAgICB9LFxuICAgICc0MjAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBFdGhlcmV1bSBwcm92aWRlci4nLFxuICAgIH0sXG4gICAgJzQ5MDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuJyxcbiAgICB9LFxuICAgICc0OTAxJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLicsXG4gICAgfSxcbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3ItY29uc3RhbnRzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/errors.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/errors.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   providerErrors: function() { return /* binding */ providerErrors; },\n/* harmony export */   rpcErrors: function() { return /* binding */ rpcErrors; }\n/* harmony export */ });\n/* harmony import */ var _classes_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes.mjs */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/classes.mjs\");\n/* harmony import */ var _error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error-constants.mjs */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/utils.mjs\");\n\n\n\nconst rpcErrors = {\n    /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    parse: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.parse, arg),\n    /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    invalidRequest: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.invalidRequest, arg),\n    /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    invalidParams: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.invalidParams, arg),\n    /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    methodNotFound: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.methodNotFound, arg),\n    /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    internal: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.internal, arg),\n    /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     *\n     * @param opts - The error options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    server: (opts) => {\n        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n            throw new Error('Ethereum RPC Server errors must provide single object argument.');\n        }\n        const { code } = opts;\n        if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n            throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n        }\n        return getJsonRpcError(code, opts);\n    },\n    /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    invalidInput: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.invalidInput, arg),\n    /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    resourceNotFound: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.resourceNotFound, arg),\n    /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    resourceUnavailable: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.resourceUnavailable, arg),\n    /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    transactionRejected: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.transactionRejected, arg),\n    /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    methodNotSupported: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.methodNotSupported, arg),\n    /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */\n    limitExceeded: (arg) => getJsonRpcError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.limitExceeded, arg),\n};\nconst providerErrors = {\n    /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    userRejectedRequest: (arg) => {\n        return getEthProviderError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    unauthorized: (arg) => {\n        return getEthProviderError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.provider.unauthorized, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    unsupportedMethod: (arg) => {\n        return getEthProviderError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    disconnected: (arg) => {\n        return getEthProviderError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.provider.disconnected, arg);\n    },\n    /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    chainDisconnected: (arg) => {\n        return getEthProviderError(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n     * Get a custom Ethereum Provider error.\n     *\n     * @param opts - The error options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */\n    custom: (opts) => {\n        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n            throw new Error('Ethereum Provider custom errors must provide single object argument.');\n        }\n        const { code, message, data } = opts;\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        return new _classes_mjs__WEBPACK_IMPORTED_MODULE_1__.EthereumProviderError(code, message, data);\n    },\n};\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */\nfunction getJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new _classes_mjs__WEBPACK_IMPORTED_MODULE_1__.JsonRpcError(code, message ?? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.getMessageFromCode)(code), data);\n}\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */\nfunction getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new _classes_mjs__WEBPACK_IMPORTED_MODULE_1__.EthereumProviderError(code, message ?? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.getMessageFromCode)(code), data);\n}\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === 'string') {\n            return [arg];\n        }\n        else if (typeof arg === 'object' && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== 'string') {\n                throw new Error('Must specify string message.');\n            }\n            return [message ?? undefined, data];\n        }\n    }\n    return [];\n}\n//# sourceMappingURL=errors.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2Vycm9ycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0U7QUFDakI7QUFDRjtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLG9DQUFvQyw0REFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQSw2Q0FBNkMsNERBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsNENBQTRDLDREQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLDZDQUE2Qyw0REFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQSx1Q0FBdUMsNERBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsMkNBQTJDLDREQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLCtDQUErQyw0REFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQSxrREFBa0QsNERBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0Esa0RBQWtELDREQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLGlEQUFpRCw0REFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQSw0Q0FBNEMsNERBQVU7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2QjtBQUNqRTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFVO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBLG1DQUFtQyw0REFBVTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQSxtQ0FBbUMsNERBQVU7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2QjtBQUNqRTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFVO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBLG1DQUFtQyw0REFBVTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBcUI7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBWSxrQkFBa0IsOERBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBcUIsa0JBQWtCLDhEQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2Vycm9ycy5tanM/MWU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBKc29uUnBjRXJyb3IsIEV0aGVyZXVtUHJvdmlkZXJFcnJvciB9IGZyb20gXCIuL2NsYXNzZXMubWpzXCI7XG5pbXBvcnQgeyBlcnJvckNvZGVzIH0gZnJvbSBcIi4vZXJyb3ItY29uc3RhbnRzLm1qc1wiO1xuaW1wb3J0IHsgZ2V0TWVzc2FnZUZyb21Db2RlIH0gZnJvbSBcIi4vdXRpbHMubWpzXCI7XG5leHBvcnQgY29uc3QgcnBjRXJyb3JzID0ge1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgcGFyc2U6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5wYXJzZSwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBSZXF1ZXN0ICgtMzI2MDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBpbnZhbGlkUmVxdWVzdDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgaW52YWxpZFBhcmFtczogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIE1ldGhvZCBOb3QgRm91bmQgKC0zMjYwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIG1ldGhvZE5vdEZvdW5kOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90Rm91bmQsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBpbnRlcm5hbDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBTZXJ2ZXIgZXJyb3IuXG4gICAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cbiAgICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUC0xNDc0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgZXJyb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHNlcnZlcjogKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAtMzIwOTkgPD0gY29kZSA8PSAtMzIwMDUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIGludmFsaWRJbnB1dDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgTm90IEZvdW5kICgtMzIwMDEpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICByZXNvdXJjZU5vdEZvdW5kOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgVW5hdmFpbGFibGUgKC0zMjAwMikgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHJlc291cmNlVW5hdmFpbGFibGU6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIE1ldGhvZCBOb3QgU3VwcG9ydGVkICgtMzIwMDQpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIExpbWl0IEV4Y2VlZGVkICgtMzIwMDUpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBsaW1pdEV4Y2VlZGVkOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKSxcbn07XG5leHBvcnQgY29uc3QgcHJvdmlkZXJFcnJvcnMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVzZXIgUmVqZWN0ZWQgUmVxdWVzdCAoNDAwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IChhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHVuYXV0aG9yaXplZDogKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIE5vdCBDb25uZWN0ZWQgKDQ5MDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIGNoYWluRGlzY29ubmVjdGVkOiAoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBjdXN0b20gRXRoZXJldW0gUHJvdmlkZXIgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgY3VzdG9tOiAob3B0cykgPT4ge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IG9wdHM7XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBHZXQgYSBnZW5lcmljIEpTT04tUlBDIGVycm9yIGNsYXNzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgICByZXR1cm4gbmV3IEpzb25ScGNFcnJvcihjb2RlLCBtZXNzYWdlID8/IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG4vKipcbiAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBlcnJvciBjbGFzcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICovXG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yKGNvZGUsIGFyZykge1xuICAgIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xuICAgIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgPz8gZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbi8qKlxuICogR2V0IGFuIGVycm9yIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIGRhdGEgZnJvbSBhbiBvcHRpb25zIGJhZy5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZGF0YSB9ID0gYXJnO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW21lc3NhZ2UgPz8gdW5kZWZpbmVkLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/errors.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/utils.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/utils.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSON_RPC_SERVER_ERROR_MESSAGE: function() { return /* binding */ JSON_RPC_SERVER_ERROR_MESSAGE; },\n/* harmony export */   dataHasCause: function() { return /* binding */ dataHasCause; },\n/* harmony export */   getMessageFromCode: function() { return /* binding */ getMessageFromCode; },\n/* harmony export */   isValidCode: function() { return /* binding */ isValidCode; },\n/* harmony export */   serializeCause: function() { return /* binding */ serializeCause; },\n/* harmony export */   serializeError: function() { return /* binding */ serializeError; }\n/* harmony export */ });\n/* harmony import */ var _metamask_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/utils */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs\");\n/* harmony import */ var _metamask_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/utils */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/json.mjs\");\n/* harmony import */ var _error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error-constants.mjs */ \"(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs\");\n\n\nconst FALLBACK_ERROR_CODE = _error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';\nconst FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE),\n};\nconst JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n    if (isValidCode(code)) {\n        const codeString = code.toString();\n        if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(_error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorValues, codeString)) {\n            return _error_constants_mjs__WEBPACK_IMPORTED_MODULE_0__.errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */\nfunction isValidCode(code) {\n    return Number.isInteger(code);\n}\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON-serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @param options.shouldPreserveMessage - Whether to preserve the error's\n * message if the fallback error is used.\n * @returns The serialized error.\n */\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true, shouldPreserveMessage = true, } = {}) {\n    if (!(0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcError)(fallbackError)) {\n        throw new Error('Must provide fallback error with integer number code and string message.');\n    }\n    const serialized = buildError(error, fallbackError, shouldPreserveMessage);\n    if (!shouldIncludeStack) {\n        delete serialized.stack;\n    }\n    return serialized;\n}\n/**\n * Construct a JSON-serializable object given an error and a JSON-serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON-serializable fallback error.\n * @param shouldPreserveMessage - Whether to preserve the error's message if the fallback\n * error is used.\n * @returns A JSON-serializable error object.\n */\nfunction buildError(error, fallbackError, shouldPreserveMessage) {\n    // If an error specifies a `serialize` function, we call it and return the result.\n    if (error &&\n        typeof error === 'object' &&\n        'serialize' in error &&\n        typeof error.serialize === 'function') {\n        return error.serialize();\n    }\n    if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcError)(error)) {\n        return error;\n    }\n    const originalMessage = getOriginalMessage(error);\n    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n    const cause = serializeCause(error);\n    const fallbackWithCause = {\n        ...fallbackError,\n        ...(shouldPreserveMessage &&\n            originalMessage && { message: originalMessage }),\n        data: { cause },\n    };\n    return fallbackWithCause;\n}\n/**\n * Attempts to extract the original `message` property from an error value of uncertain shape.\n *\n * @param error - The error in question.\n * @returns The original message, if it exists and is a non-empty string.\n */\nfunction getOriginalMessage(error) {\n    if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(error) &&\n        (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(error, 'message') &&\n        typeof error.message === 'string' &&\n        error.message.length > 0) {\n        return error.message;\n    }\n    return undefined;\n}\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */\nfunction isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */\nfunction serializeCause(error) {\n    if (Array.isArray(error)) {\n        return error.map((entry) => {\n            if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isValidJson)(entry)) {\n                return entry;\n            }\n            else if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(entry)) {\n                return serializeObject(entry);\n            }\n            return null;\n        });\n    }\n    else if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(error)) {\n        return serializeObject(error);\n    }\n    if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isValidJson)(error)) {\n        return error;\n    }\n    return null;\n}\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */\nfunction serializeObject(object) {\n    return Object.getOwnPropertyNames(object).reduce((acc, key) => {\n        const value = object[key];\n        if ((0,_metamask_utils__WEBPACK_IMPORTED_MODULE_2__.isValidJson)(value)) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {});\n}\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */\nfunction dataHasCause(data) {\n    return (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(data) && (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(data, 'cause') && (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(data.cause);\n}\n//# sourceMappingURL=utils.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUY7QUFDckI7QUFDaEUsNEJBQTRCLDREQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSw0REFBVyxDQUFDLDZEQUFXO0FBQ25DLG1CQUFtQiw2REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDLDJGQUEyRixJQUFJO0FBQ3ZJLFNBQVMsK0RBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQixRQUFRLDREQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQiw0REFBVztBQUMzQjtBQUNBO0FBQ0EscUJBQXFCLHlEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWEseURBQVE7QUFDckI7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcseURBQVEsVUFBVSw0REFBVyxtQkFBbUIseURBQVE7QUFDbkU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC91dGlscy5tanM/OGRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNWYWxpZEpzb24sIGlzT2JqZWN0LCBpc0pzb25ScGNFcnJvciB9IGZyb20gXCJAbWV0YW1hc2svdXRpbHNcIjtcbmltcG9ydCB7IGVycm9yQ29kZXMsIGVycm9yVmFsdWVzIH0gZnJvbSBcIi4vZXJyb3ItY29uc3RhbnRzLm1qc1wiO1xuY29uc3QgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yQ29kZXMucnBjLmludGVybmFsO1xuY29uc3QgRkFMTEJBQ0tfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0Lic7XG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgICBjb2RlOiBGQUxMQkFDS19FUlJPUl9DT0RFLFxuICAgIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKSxcbn07XG5leHBvcnQgY29uc3QgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgc2VydmVyIGVycm9yLic7XG4vKipcbiAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICogbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gZmFsbGJhY2tNZXNzYWdlIC0gVGhlIGZhbGxiYWNrIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSBjb2RlIGhhcyBub1xuICogY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2UgZm9yIHRoZSBnaXZlbiBjb2RlLCBvciB0aGUgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZVxuICogaGFzIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG4gICAgaWYgKGlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChoYXNQcm9wZXJ0eShlcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqIEEgY29kZSBpcyB2YWxpZCBpZiBpdCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZENvZGUoY29kZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXG4gKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLmNhdXNlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMuZmFsbGJhY2tFcnJvciAtIFRoZSBlcnJvciB0byByZXR1cm4gaWYgdGhlIGdpdmVuIGVycm9yIGlzXG4gKiBub3QgY29tcGF0aWJsZS4gU2hvdWxkIGJlIGEgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRJbmNsdWRlU3RhY2sgLSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGVycm9yJ3Mgc3RhY2tcbiAqIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRQcmVzZXJ2ZU1lc3NhZ2UgLSBXaGV0aGVyIHRvIHByZXNlcnZlIHRoZSBlcnJvcidzXG4gKiBtZXNzYWdlIGlmIHRoZSBmYWxsYmFjayBlcnJvciBpcyB1c2VkLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvciwgeyBmYWxsYmFja0Vycm9yID0gRkFMTEJBQ0tfRVJST1IsIHNob3VsZEluY2x1ZGVTdGFjayA9IHRydWUsIHNob3VsZFByZXNlcnZlTWVzc2FnZSA9IHRydWUsIH0gPSB7fSkge1xuICAgIGlmICghaXNKc29uUnBjRXJyb3IoZmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IsIHNob3VsZFByZXNlcnZlTWVzc2FnZSk7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlU3RhY2spIHtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufVxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgZ2l2ZW4gYW4gZXJyb3IgYW5kIGEgSlNPTi1zZXJpYWxpemFibGUgYGZhbGxiYWNrRXJyb3JgXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGluIHF1ZXN0aW9uLlxuICogQHBhcmFtIGZhbGxiYWNrRXJyb3IgLSBBIEpTT04tc2VyaWFsaXphYmxlIGZhbGxiYWNrIGVycm9yLlxuICogQHBhcmFtIHNob3VsZFByZXNlcnZlTWVzc2FnZSAtIFdoZXRoZXIgdG8gcHJlc2VydmUgdGhlIGVycm9yJ3MgbWVzc2FnZSBpZiB0aGUgZmFsbGJhY2tcbiAqIGVycm9yIGlzIHVzZWQuXG4gKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvciwgc2hvdWxkUHJlc2VydmVNZXNzYWdlKSB7XG4gICAgLy8gSWYgYW4gZXJyb3Igc3BlY2lmaWVzIGEgYHNlcmlhbGl6ZWAgZnVuY3Rpb24sIHdlIGNhbGwgaXQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIGlmIChlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdzZXJpYWxpemUnIGluIGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5zZXJpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNKc29uUnBjRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxNZXNzYWdlID0gZ2V0T3JpZ2luYWxNZXNzYWdlKGVycm9yKTtcbiAgICAvLyBJZiB0aGUgZXJyb3IgZG9lcyBub3QgbWF0Y2ggdGhlIEpzb25ScGNFcnJvciB0eXBlLCB1c2UgdGhlIGZhbGxiYWNrIGVycm9yLCBidXQgdHJ5IHRvIGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIGFzIGBjYXVzZWAuXG4gICAgY29uc3QgY2F1c2UgPSBzZXJpYWxpemVDYXVzZShlcnJvcik7XG4gICAgY29uc3QgZmFsbGJhY2tXaXRoQ2F1c2UgPSB7XG4gICAgICAgIC4uLmZhbGxiYWNrRXJyb3IsXG4gICAgICAgIC4uLihzaG91bGRQcmVzZXJ2ZU1lc3NhZ2UgJiZcbiAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZSAmJiB7IG1lc3NhZ2U6IG9yaWdpbmFsTWVzc2FnZSB9KSxcbiAgICAgICAgZGF0YTogeyBjYXVzZSB9LFxuICAgIH07XG4gICAgcmV0dXJuIGZhbGxiYWNrV2l0aENhdXNlO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRyYWN0IHRoZSBvcmlnaW5hbCBgbWVzc2FnZWAgcHJvcGVydHkgZnJvbSBhbiBlcnJvciB2YWx1ZSBvZiB1bmNlcnRhaW4gc2hhcGUuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGluIHF1ZXN0aW9uLlxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIG1lc3NhZ2UsIGlmIGl0IGV4aXN0cyBhbmQgaXMgYSBub24tZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRPcmlnaW5hbE1lc3NhZ2UoZXJyb3IpIHtcbiAgICBpZiAoaXNPYmplY3QoZXJyb3IpICYmXG4gICAgICAgIGhhc1Byb3BlcnR5KGVycm9yLCAnbWVzc2FnZScpICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBlcnJvci5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgc2VydmVyIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBzZXJ2ZXIgZXJyb3IgY29kZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IC0zMjA5OSAmJiBjb2RlIDw9IC0zMjAwMDtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhbiB1bmtub3duIGVycm9yIHRvIGJlIHVzZWQgYXMgdGhlIGBjYXVzZWAgaW4gYSBmYWxsYmFjayBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgdW5rbm93biBlcnJvci5cbiAqIEByZXR1cm5zIEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGNvbnRhaW5pbmcgYXMgbXVjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXJyb3IgYXMgcG9zc2libGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDYXVzZShlcnJvcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRKc29uKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlcnJvcik7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkSnNvbihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRXh0cmFjdHMgYWxsIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgaW4gcXVlc3Rpb24uXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGlmIChpc1ZhbGlkSnNvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdXBwbGllZCBlcnJvciBkYXRhIGhhcyBhIHVzYWJsZSBgY2F1c2VgIHByb3BlcnR5OyBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBPcHRpb25hbCBkYXRhIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgV2hldGhlciBjYXVzZSBwcm9wZXJ0eSBpcyBwcmVzZW50IGFuZCBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhSGFzQ2F1c2UoZGF0YSkge1xuICAgIHJldHVybiBpc09iamVjdChkYXRhKSAmJiBoYXNQcm9wZXJ0eShkYXRhLCAnY2F1c2UnKSAmJiBpc09iamVjdChkYXRhLmNhdXNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/rpc-errors/dist/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/error.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/error.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StructError: function() { return /* binding */ StructError; }\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n//# sourceMappingURL=error.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9lcnJvci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdCQUFnQixPQUFPO0FBQ3ZCLGdFQUFnRSxnQkFBZ0IsS0FBSyxRQUFRO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvZXJyb3IubWpzPzMzMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCAuLi5yZXN0IH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBjYXVzZSk7XG4gICAgICAgIGlmIChleHBsYW5hdGlvbiAhPT0gbnVsbCAmJiBleHBsYW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/error.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/struct.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExactOptionalStruct: function() { return /* binding */ ExactOptionalStruct; },\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   is: function() { return /* binding */ is; },\n/* harmony export */   mask: function() { return /* binding */ mask; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/error.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs\");\n\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n// String instead of a Symbol in case of multiple different versions of this library.\nconst ExactOptionalBrand = 'EXACT_OPTIONAL';\n/**\n * An `ExactOptionalStruct` is a `Struct` that is used to create exactly optional\n * properties of `object()` structs.\n */\nclass ExactOptionalStruct extends Struct {\n    constructor(props) {\n        super({\n            ...props,\n            type: `exact optional ${props.type}`,\n        });\n        this.brand = ExactOptionalBrand;\n    }\n    static isExactOptional(value) {\n        return ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && 'brand' in value && value.brand === ExactOptionalBrand);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(value, struct, options);\n    const tuple = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.shiftIterator)(tuples);\n    if (tuple[0]) {\n        const error = new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\n//# sourceMappingURL=struct.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwQztBQUM2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDO0FBQ3BELG1CQUFtQiwrQ0FBRztBQUN0QixrQkFBa0IseURBQWE7QUFDL0I7QUFDQSwwQkFBMEIsbURBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdC5tanM/NGI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdHJ1Y3RFcnJvciB9IGZyb20gXCIuL2Vycm9yLm1qc1wiO1xuaW1wb3J0IHsgaXNPYmplY3QsIHRvRmFpbHVyZXMsIHNoaWZ0SXRlcmF0b3IsIHJ1biB9IGZyb20gXCIuL3V0aWxzLm1qc1wiO1xuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5leHBvcnQgY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBub29wICovXG4gICAgICAgIH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLy8gU3RyaW5nIGluc3RlYWQgb2YgYSBTeW1ib2wgaW4gY2FzZSBvZiBtdWx0aXBsZSBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgdGhpcyBsaWJyYXJ5LlxuY29uc3QgRXhhY3RPcHRpb25hbEJyYW5kID0gJ0VYQUNUX09QVElPTkFMJztcbi8qKlxuICogQW4gYEV4YWN0T3B0aW9uYWxTdHJ1Y3RgIGlzIGEgYFN0cnVjdGAgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSBleGFjdGx5IG9wdGlvbmFsXG4gKiBwcm9wZXJ0aWVzIG9mIGBvYmplY3QoKWAgc3RydWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEV4YWN0T3B0aW9uYWxTdHJ1Y3QgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgdHlwZTogYGV4YWN0IG9wdGlvbmFsICR7cHJvcHMudHlwZX1gLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5icmFuZCA9IEV4YWN0T3B0aW9uYWxCcmFuZDtcbiAgICB9XG4gICAgc3RhdGljIGlzRXhhY3RPcHRpb25hbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSAmJiAnYnJhbmQnIGluIHZhbHVlICYmIHZhbHVlLmJyYW5kID09PSBFeGFjdE9wdGlvbmFsQnJhbmQpO1xuICAgIH1cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29lcmNlIGFuZCB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAcmV0dXJucyBUaGUgY29lcmNlZCBhbmQgdmFsaWRhdGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBtYXNrLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gbWFzayBhZ2FpbnN0LlxuICogQHBhcmFtIG1lc3NhZ2UgLSBBbiBvcHRpb25hbCBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICogQHJldHVybnMgVGhlIG1hc2tlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICogQHBhcmFtIG9wdGlvbnMuY29lcmNlIC0gV2hldGhlciB0byBjb2VyY2UgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWFzayAtIFdoZXRoZXIgdG8gbWFzayB0aGUgdmFsdWUgYmVmb3JlIHZhbGlkYXRpbmcgaXQuXG4gKiBAcGFyYW0gb3B0aW9ucy5tZXNzYWdlIC0gQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgZXJyb3IgKGlmIGludmFsaWQpIGFuZCB0aGUgdmFsaWRhdGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5uZXJUdXBsZSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUdXBsZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpbm5lclR1cGxlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlZFZhbHVlID0gdHVwbGVbMV07XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZhbGlkYXRlZFZhbHVlXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cnVjdC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/coercions.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/coercions.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerce: function() { return /* binding */ coerce; },\n/* harmony export */   defaulted: function() { return /* binding */ defaulted; },\n/* harmony export */   trimmed: function() { return /* binding */ trimmed; }\n/* harmony export */ });\n/* harmony import */ var _struct_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../struct.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/types.mjs\");\n\n\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nfunction coerce(struct, condition, coercer) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_0__.Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return (0,_struct_mjs__WEBPACK_IMPORTED_MODULE_0__.is)(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, (0,_types_mjs__WEBPACK_IMPORTED_MODULE_1__.unknown)(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(value) && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nfunction trimmed(struct) {\n    return coerce(struct, (0,_types_mjs__WEBPACK_IMPORTED_MODULE_1__.string)(), (value) => value.trim());\n}\n//# sourceMappingURL=coercions.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL2NvZXJjaW9ucy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJDO0FBQ0U7QUFDQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFFO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saURBQWlEO0FBQ3hELDBCQUEwQixtREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBYSxXQUFXLHlEQUFhO0FBQ3BFLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDBCQUEwQixrREFBTTtBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL2NvZXJjaW9ucy5tanM/NzA3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdHJ1Y3QsIGlzIH0gZnJvbSBcIi4uL3N0cnVjdC5tanNcIjtcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tIFwiLi4vdXRpbHMubWpzXCI7XG5pbXBvcnQgeyBzdHJpbmcsIHVua25vd24gfSBmcm9tIFwiLi90eXBlcy5tanNcIjtcbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBjb25kaXRpb24gLSBBIHN0cnVjdCB0aGF0IHRoZSBpbnB1dCBtdXN0IHBhc3MgdG8gYmUgY29lcmNlZC5cbiAqIEBwYXJhbSBjb2VyY2VyIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBpbnB1dCBhbmQgcmV0dXJucyB0aGUgY29lcmNlZFxuICogdmFsdWUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIGNvZXJjZSBpdHMgaW5wdXQgYmVmb3JlIHZhbGlkYXRpbmcgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KVxuICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIFRoZSB2YWx1ZSB0byB1c2Ugd2hlbiB0aGUgaW5wdXQgaXMgYHVuZGVmaW5lZGAuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMuc3RyaWN0IC0gV2hlbiBgdHJ1ZWAsIHRoZSBmYWxsYmFjayB3aWxsIG9ubHkgYmUgdXNlZCB3aGVuIHRoZVxuICogaW5wdXQgaXMgYHVuZGVmaW5lZGAuIFdoZW4gYGZhbHNlYCwgdGhlIGZhbGxiYWNrIHdpbGwgYmUgdXNlZCB3aGVuIHRoZSBpbnB1dFxuICogaXMgYHVuZGVmaW5lZGAgb3Igd2hlbiB0aGUgaW5wdXQgaXMgYSBwbGFpbiBvYmplY3QgYW5kIHRoZSBmYWxsYmFjayBpcyBhXG4gKiBwbGFpbiBvYmplY3QsIGFuZCBhbnkga2V5cyBpbiB0aGUgZmFsbGJhY2sgYXJlIG1pc3NpbmcgZnJvbSB0aGUgaW5wdXQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIHJlcGxhY2UgYHVuZGVmaW5lZGAgaW5wdXRzIHdpdGggYSBkZWZhdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7IC4uLnZhbHVlIH07XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgdHJpbSBzdHJpbmcgaW5wdXRzIGJlZm9yZSB2YWxpZGF0aW5nIHRoZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltbWVkKHN0cnVjdCkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgKHZhbHVlKSA9PiB2YWx1ZS50cmltKCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29lcmNpb25zLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/coercions.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/refinements.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/refinements.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   empty: function() { return /* binding */ empty; },\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   nonempty: function() { return /* binding */ nonempty; },\n/* harmony export */   pattern: function() { return /* binding */ pattern; },\n/* harmony export */   refine: function() { return /* binding */ refine; },\n/* harmony export */   size: function() { return /* binding */ size; }\n/* harmony export */ });\n/* harmony import */ var _struct_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../struct.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs\");\n\n\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nfunction size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nfunction refine(struct, name, refiner) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_0__.Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.toFailures)(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n//# sourceMappingURL=refinements.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3JlZmluZW1lbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBdUM7QUFDRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsb0NBQW9DLEtBQUs7QUFDdkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRDQUE0QztBQUNuRCxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxZQUFZO0FBQ3ZEO0FBQ0EsaUJBQWlCLEVBQUUsV0FBVyxpQkFBaUIsTUFBTTtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNENBQTRDO0FBQ25ELFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhLGVBQWU7QUFDMUQ7QUFDQSxpQkFBaUIsRUFBRSxXQUFXLGlCQUFpQixNQUFNO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixhQUFhLGNBQWMsY0FBYyxvQkFBb0IsTUFBTTtBQUM3RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQix1QkFBdUIsUUFBUSxXQUFXLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxFQUFFLElBQUksaUJBQWlCLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxtQkFBbUIsVUFBVSxjQUFjLElBQUksb0NBQW9DLEtBQUs7QUFDeEY7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGVBQWUsVUFBVSxnQkFBZ0IsSUFBSSxzQ0FBc0MsT0FBTztBQUMxRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBVTtBQUN2QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy9yZWZpbmVtZW50cy5tanM/Yjk5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdHJ1Y3QgfSBmcm9tIFwiLi4vc3RydWN0Lm1qc1wiO1xuaW1wb3J0IHsgdG9GYWlsdXJlcyB9IGZyb20gXCIuLi91dGlscy5tanNcIjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBlbXB0eSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID09PSAwIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBtZWFzdXJlLlxuICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gdGhyZXNob2xkIC0gVGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLmV4Y2x1c2l2ZSAtIFdoZW4gYHRydWVgLCB0aGUgaW5wdXQgbXVzdCBiZSBzdHJpY3RseSBsZXNzIHRoYW5cbiAqIHRoZSB0aHJlc2hvbGQuIFdoZW4gYGZhbHNlYCwgdGhlIGlucHV0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZVxuICogdGhyZXNob2xkLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWx1ZXMgYmVsb3cgdGhlIHRocmVzaG9sZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBsZXNzIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIH0ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIHRocmVzaG9sZCAtIFRoZSBtaW5pbXVtIHZhbHVlIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5leGNsdXNpdmUgLSBXaGVuIGB0cnVlYCwgdGhlIGlucHV0IG11c3QgYmUgc3RyaWN0bHkgZ3JlYXRlclxuICogdGhhbiB0aGUgdGhyZXNob2xkLiBXaGVuIGBmYWxzZWAsIHRoZSBpbnB1dCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICogdGhlIHRocmVzaG9sZC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIGFib3ZlIHRoZSB0aHJlc2hvbGQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4oc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgID8gdmFsdWUgPiB0aHJlc2hvbGRcbiAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gZ3JlYXRlciB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICB9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgbm9uLWVtcHR5IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbm9uZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIHJlZ2V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgc3RyaW5ncyBtYXRjaGluZyB0aGUgcmVndWxhclxuICogZXhwcmVzc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIChyZWdleHAudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IG1hdGNoaW5nIFxcYC8ke3JlZ2V4cC5zb3VyY2V9L1xcYCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsXG4gKiBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIG1pbmltdW0gLSBUaGUgbWluaW11bSBzaXplIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEBwYXJhbSBtYXhpbXVtIC0gVGhlIG1heGltdW0gc2l6ZSB0aGF0IHRoZSBpbnB1dCBjYW4gYmUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHZhbHVlcyB3aXRoaW4gdGhlIGdpdmVuIHNpemVcbiAqIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZShzdHJ1Y3QsIG1pbmltdW0sIG1heGltdW0gPSBtaW5pbXVtKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfWA7XG4gICAgY29uc3Qgb2YgPSBtaW5pbXVtID09PSBtYXhpbXVtXG4gICAgICAgID8gYG9mIFxcYCR7bWluaW11bX1cXGBgXG4gICAgICAgIDogYGJldHdlZW4gXFxgJHttaW5pbXVtfVxcYCBhbmQgXFxgJHttYXhpbXVtfVxcYGA7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgobWluaW11bSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXhpbXVtKSB8fFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgobWluaW11bSA8PSBzaXplICYmIHNpemUgPD0gbWF4aW11bSkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIHNpemUgJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gKChtaW5pbXVtIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4aW11bSkgfHxcbiAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgbGVuZ3RoICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBcXGAke2xlbmd0aH1cXGBgKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJlZmluZW1lbnQuXG4gKiBAcGFyYW0gcmVmaW5lciAtIFRoZSByZWZpbmVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBydW4gdGhlIHJlZmluZXIgZnVuY3Rpb24gYWZ0ZXIgdGhlIGV4aXN0aW5nXG4gKiB2YWxpZGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmaW5lbWVudHMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/refinements.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/types.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/types.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   any: function() { return /* binding */ any; },\n/* harmony export */   array: function() { return /* binding */ array; },\n/* harmony export */   bigint: function() { return /* binding */ bigint; },\n/* harmony export */   boolean: function() { return /* binding */ boolean; },\n/* harmony export */   date: function() { return /* binding */ date; },\n/* harmony export */   enums: function() { return /* binding */ enums; },\n/* harmony export */   exactOptional: function() { return /* binding */ exactOptional; },\n/* harmony export */   func: function() { return /* binding */ func; },\n/* harmony export */   instance: function() { return /* binding */ instance; },\n/* harmony export */   integer: function() { return /* binding */ integer; },\n/* harmony export */   intersection: function() { return /* binding */ intersection; },\n/* harmony export */   literal: function() { return /* binding */ literal; },\n/* harmony export */   map: function() { return /* binding */ map; },\n/* harmony export */   never: function() { return /* binding */ never; },\n/* harmony export */   nullable: function() { return /* binding */ nullable; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   object: function() { return /* binding */ object; },\n/* harmony export */   optional: function() { return /* binding */ optional; },\n/* harmony export */   record: function() { return /* binding */ record; },\n/* harmony export */   regexp: function() { return /* binding */ regexp; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   string: function() { return /* binding */ string; },\n/* harmony export */   tuple: function() { return /* binding */ tuple; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   union: function() { return /* binding */ union; },\n/* harmony export */   unknown: function() { return /* binding */ unknown; }\n/* harmony export */ });\n/* harmony import */ var _struct_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../struct.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs\");\n/* harmony import */ var _utilities_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/utilities.mjs\");\n\n\n\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nfunction any() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('any', () => true);\n}\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nfunction array(Element) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nfunction bigint() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nfunction boolean() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nfunction date() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((value) => (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction func() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nfunction instance(Class) {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nfunction integer() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nfunction intersection(Structs) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nfunction literal(constant) {\n    const description = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(constant);\n    const valueType = typeof constant;\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nfunction map(Key, Value) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nfunction never() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nfunction nullable(struct) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nfunction number() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    const propertySchema = schema[key];\n                    if (_struct_mjs__WEBPACK_IMPORTED_MODULE_1__.ExactOptionalStruct.isExactOptional(propertySchema) &&\n                        !Object.prototype.hasOwnProperty.call(value, key)) {\n                        continue;\n                    }\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) || `Expected an object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n        coercer(value) {\n            return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nfunction optional(struct) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Augment a struct such that, if it is the property of an object, it is exactly optional.\n * In other words, it is either present with the correct type, or not present at all.\n *\n * NOTE: Only intended for use with `object()` structs.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that can be used to create exactly optional properties of `object()`\n * structs.\n */\nfunction exactOptional(struct) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.ExactOptionalStruct(struct);\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nfunction record(Key, Value) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) || `Expected an object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nfunction regexp() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nfunction set(Element) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nfunction string() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) || `Expected an object, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`);\n        },\n        coercer(value) {\n            return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nfunction union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.run)(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.print)(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nfunction unknown() {\n    return (0,_utilities_mjs__WEBPACK_IMPORTED_MODULE_0__.define)('unknown', () => true);\n}\n//# sourceMappingURL=types.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3R5cGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RDtBQUNSO0FBQ1g7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBELGlEQUFLLFFBQVE7QUFDdkUsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHNEQUFNO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBTTtBQUNqQjtBQUNBLCtEQUErRCxpREFBSyxRQUFRO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4Q0FBOEMsaURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLG9CQUFvQixpREFBSyxRQUFRO0FBQ2xGLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSxrREFBa0QsaURBQUssUUFBUTtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSw0QkFBNEIsV0FBVyw2QkFBNkIsaURBQUssUUFBUTtBQUNqRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHNEQUFNO0FBQ2pCO0FBQ0Esa0RBQWtELGlEQUFLLFFBQVE7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsK0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLGlEQUFLO0FBQzdCO0FBQ0EsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVksb0JBQW9CLGlEQUFLLFFBQVE7QUFDdkYsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsK0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDREQUE0RCxpREFBSyxRQUFRO0FBQ3pFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHNEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSxnREFBZ0QsaURBQUssUUFBUTtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLG9EQUFRLGdEQUFnRCxpREFBSyxRQUFRO0FBQ3pGLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixvREFBUSxZQUFZLFdBQVc7QUFDbEQsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSw0REFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixvREFBUSxnREFBZ0QsaURBQUssUUFBUTtBQUN6RixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBTTtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTRELGlEQUFLLFFBQVE7QUFDekUsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSxnREFBZ0QsaURBQUssUUFBUTtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCxpREFBSyxRQUFRO0FBQ2pFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isb0RBQVEsZ0RBQWdELGlEQUFLLFFBQVE7QUFDekYsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLG9EQUFRLFlBQVksV0FBVztBQUNsRCxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSwrQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsWUFBWSxvQkFBb0IsaURBQUssUUFBUTtBQUMzRztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQU07QUFDakI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy90eXBlcy5tanM/NjVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeGFjdE9wdGlvbmFsU3RydWN0LCBTdHJ1Y3QgfSBmcm9tIFwiLi4vc3RydWN0Lm1qc1wiO1xuaW1wb3J0IHsgcHJpbnQsIHJ1biwgaXNPYmplY3QgfSBmcm9tIFwiLi4vdXRpbHMubWpzXCI7XG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi91dGlsaXRpZXMubWpzXCI7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0aGF0IHdpbGwgYWx3YXlzIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBhcnJheSBhbmQgdGhhdCBpdHMgZWxlbWVudHMgYXJlIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBOb3RlOiBJZiB5b3Ugb21pdCB0aGUgZWxlbWVudCBzdHJ1Y3QsIHRoZSBhcnJheXMgZWxlbWVudHMgd2lsbCBub3QgYmVcbiAqIGl0ZXJhdGVkIGF0IGFsbC4gVGhpcyBjYW4gYmUgaGVscGZ1bCBmb3IgY2FzZXMgd2hlcmUgcGVyZm9ybWFuY2UgaXMgY3JpdGljYWwsXG4gKiBhbmQgaXQgaXMgcHJlZmVycmVkIHRvIHVzaW5nIGBhcnJheShhbnkoKSlgLlxuICpcbiAqIEBwYXJhbSBFbGVtZW50IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGFycmF5cyBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGFycmF5VmFsdWVdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaW5kZXgsIGFycmF5VmFsdWUsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBiaWdpbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlnaW50KCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2JpZ2ludCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBib29sZWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gKlxuICogTm90ZTogdGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgKm5vdCogYW4gaW52YWxpZCBgRGF0ZWAgb2JqZWN0LFxuICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWxpZCBgRGF0ZWAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGUoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSB2YWxpZCBcXGBEYXRlXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBvbmUgb2YgYSBzZXQgb2YgcG90ZW50aWFsIHZhbHVlcy5cbiAqXG4gKiBOb3RlOiBhZnRlciBjcmVhdGluZyB0aGUgc3RydWN0LCB5b3UgY2FuIGFjY2VzcyB0aGUgZGVmaW5pdGlvbiBvZiB0aGVcbiAqIHBvdGVudGlhbCB2YWx1ZXMgYXMgYHN0cnVjdC5zY2hlbWFgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgcG90ZW50aWFsIHZhbHVlcyB0aGF0IHRoZSBpbnB1dCBjYW4gYmUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBwcmludCh2YWx1ZSkpLmpvaW4oKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2VudW1zJyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmluY2x1ZGVzKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBvbmUgb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGZ1bmN0aW9ucy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKlxuICogQHBhcmFtIENsYXNzIC0gVGhlIGNsYXNzIHRoYXQgdGhlIHZhbHVlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGluc3RhbmNlcyBvZiB0aGUgZ2l2ZW4gY2xhc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW5jZShDbGFzcykge1xuICAgIHJldHVybiBkZWZpbmUoJ2luc3RhbmNlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgJHtDbGFzcy5uYW1lfVxcYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgaW50ZWdlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKlxuICogQHBhcmFtIFN0cnVjdHMgLSBUaGUgc2V0IG9mIHN0cnVjdHMgdGhhdCB0aGUgdmFsdWUgbXVzdCBtYXRjaC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIHRoYXQgbWF0Y2ggYWxsIG9mIHRoZVxuICogZ2l2ZW4gc3RydWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVudHJpZXMgfSBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIGVudHJpZXModmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdmFsaWRhdG9yIH0gb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZmluZXIgfSBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGV4YWN0IHZhbHVlLCB1c2luZyBgPT09YCBmb3IgY29tcGFyaXNvbi5cbiAqXG4gKiBAcGFyYW0gY29uc3RhbnQgLSBUaGUgZXhhY3QgdmFsdWUgdGhhdCB0aGUgaW5wdXQgbXVzdCBiZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGV4YWN0IGdpdmVuIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB2YWx1ZVR5cGUgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBjb25zdGFudFxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYE1hcGAgb2JqZWN0LCBhbmQgdGhhdCBpdHMga2V5cyBhbmQgdmFsdWVzIGFyZSBvZlxuICogc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogQHBhcmFtIEtleSAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgZWFjaCBrZXkgaW4gdGhlIG1hcCBhZ2FpbnN0LlxuICogQHBhcmFtIFZhbHVlIC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIHZhbHVlIGluIHRoZSBtYXAgYWdhaW5zdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYE1hcGAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbWFwJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21hcEtleSwgbWFwVmFsdWVdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbWFwS2V5LCBtYXBLZXksIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFttYXBLZXksIG1hcFZhbHVlLCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgbmV2ZXIgcGFzcyB2YWxpZGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgYWNjZXB0IGBudWxsYCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgbnVtYmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhhdCBpdCBoYXMgYSBrbm93biBzZXQgb2YgcHJvcGVydGllcyxcbiAqIGFuZCB0aGF0IGl0cyBwcm9wZXJ0aWVzIGFyZSBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyB3aWxsIGZhaWwgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBvYmplY3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gc2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChFeGFjdE9wdGlvbmFsU3RydWN0LmlzRXhhY3RPcHRpb25hbChwcm9wZXJ0eVNjaGVtYSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCBzdWNoIHRoYXQsIGlmIGl0IGlzIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIGl0IGlzIGV4YWN0bHkgb3B0aW9uYWwuXG4gKiBJbiBvdGhlciB3b3JkcywgaXQgaXMgZWl0aGVyIHByZXNlbnQgd2l0aCB0aGUgY29ycmVjdCB0eXBlLCBvciBub3QgcHJlc2VudCBhdCBhbGwuXG4gKlxuICogTk9URTogT25seSBpbnRlbmRlZCBmb3IgdXNlIHdpdGggYG9iamVjdCgpYCBzdHJ1Y3RzLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgZXhhY3RseSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3QoKWBcbiAqIHN0cnVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdE9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgRXhhY3RPcHRpb25hbFN0cnVjdChzdHJ1Y3QpO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gS2V5IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGtleSBpbiB0aGUgcmVjb3JkIGFnYWluc3QuXG4gKiBAcGFyYW0gVmFsdWUgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggdmFsdWUgaW4gdGhlIHJlY29yZCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdyZWNvcmQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqZWN0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFZhbHVlID0gdmFsdWVbb2JqZWN0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW29iamVjdEtleSwgb2JqZWN0S2V5LCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBgUmVnRXhwYCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ3JlZ2V4cCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgU2V0YCBvYmplY3QsIGFuZCB0aGF0IGl0cyBlbGVtZW50cyBhcmUgb2YgYVxuICogc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBAcGFyYW0gRWxlbWVudCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYFNldGAgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNldFZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtzZXRWYWx1ZSwgc2V0VmFsdWUsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgU2V0XFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKlxuICogQHBhcmFtIFN0cnVjdHMgLSBUaGUgc2V0IG9mIHN0cnVjdHMgdGhhdCB0aGUgdmFsdWUgbXVzdCBtYXRjaC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdHVwbGVzIG9mIHRoZSBnaXZlbiB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gU3RydWN0cyAtIFRoZSBzZXQgb2Ygc3RydWN0cyB0aGF0IHRoZSB2YWx1ZSBtdXN0IG1hdGNoLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWx1ZXMgdGhhdCBtYXRjaCBvbmUgb2YgdGhlXG4gKiBnaXZlbiBzdHJ1Y3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oU3RydWN0cykge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHN0cnVjdCkgPT4gc3RydWN0LnR5cGUpLmpvaW4oJyB8ICcpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3VuaW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IElubmVyU3RydWN0IG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXJyb3IsIGNvZXJjZWRdID0gSW5uZXJTdHJ1Y3QudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgSW5uZXJTdHJ1Y3Qgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBJbm5lclN0cnVjdCwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3Q/LlswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0aGF0IHdpbGwgYWx3YXlzIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/types.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/utilities.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/utilities.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   define: function() { return /* binding */ define; },\n/* harmony export */   deprecated: function() { return /* binding */ deprecated; },\n/* harmony export */   dynamic: function() { return /* binding */ dynamic; },\n/* harmony export */   lazy: function() { return /* binding */ lazy; },\n/* harmony export */   omit: function() { return /* binding */ omit; },\n/* harmony export */   partial: function() { return /* binding */ partial; },\n/* harmony export */   pick: function() { return /* binding */ pick; }\n/* harmony export */ });\n/* harmony import */ var _struct_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../struct.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/types.mjs\");\n\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nfunction assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(schema) : (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.object)(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nfunction define(name, validator) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nfunction deprecated(struct, log) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nfunction dynamic(fn) {\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nfunction lazy(fn) {\n    let struct;\n    return new _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(subschema);\n        default:\n            return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.object)(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof _struct_mjs__WEBPACK_IMPORTED_MODULE_1__.Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.optional)(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(schema);\n    }\n    return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.object)(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(subschema);\n        default:\n            return (0,_types_mjs__WEBPACK_IMPORTED_MODULE_0__.object)(subschema);\n    }\n}\n//# sourceMappingURL=utilities.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3V0aWxpdGllcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDLG1DQUFtQztBQUNuQyxvQkFBb0IsZ0RBQUksV0FBVyxrREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNLEdBQUcscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLCtDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsK0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsK0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLGtEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVDQUF1QywrQ0FBTTtBQUM3QyxnQ0FBZ0MsbUJBQW1CLElBQUk7QUFDdkQ7QUFDQTtBQUNBLHNCQUFzQixvREFBUTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxnREFBSTtBQUNuQjtBQUNBLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBSTtBQUN2QjtBQUNBLG1CQUFtQixrREFBTTtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvdXRpbGl0aWVzLm1qcz8xYjBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0cnVjdCB9IGZyb20gXCIuLi9zdHJ1Y3QubWpzXCI7XG5pbXBvcnQgeyBvYmplY3QsIG9wdGlvbmFsLCB0eXBlIH0gZnJvbSBcIi4vdHlwZXMubWpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBmcm9tIG11bHRpcGxlIG9iamVjdCBvciB0eXBlXG4gKiBzdHJ1Y3RzLiBJdHMgcmV0dXJuIHR5cGUgd2lsbCBtYXRjaCB0aGUgZmlyc3QgcGFyYW1ldGVyJ3MgdHlwZS5cbiAqXG4gKiBAcGFyYW0gU3RydWN0cyAtIFRoZSBzdHJ1Y3RzIHRvIGNvbWJpbmUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgc3RydWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXT8udHlwZSA9PT0gJ3R5cGUnO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcCgoeyBzY2hlbWEgfSkgPT4gc2NoZW1hKTtcbiAgICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKTtcbiAgICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc3RydWN0IHR5cGUuXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gVGhlIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7IHR5cGU6IG5hbWUsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGxvZyAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYHVuZGVmaW5lZGAgb3IgdmFsdWVzIHRoYXQgcGFzc1xuICogdGhlIGlucHV0IHN0cnVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAqIHZhbGlkYXRpb24gbG9naWMgdGhhdCBjaGFuZ2VzIGJhc2VkIG9uIGl0cyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgY2FsbGJhY2sgdG8gY3JlYXRlIHRoZSBzdHJ1Y3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgY2FsbGJhY2sgdG8gY3JlYXRlIHRoZSBzdHJ1Y3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIHRvIG9taXQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG5vdCBhY2NlcHQgdGhlIGlucHV0IGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBhY2NlcHQgdGhlIGlucHV0IGtleXMgYXMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICAgIGNvbnN0IGlzU3RydWN0ID0gc3RydWN0IGluc3RhbmNlb2YgU3RydWN0O1xuICAgIGNvbnN0IHNjaGVtYSA9IGlzU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hIH0gOiB7IC4uLnN0cnVjdCB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiB0eXBlKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBrZXlzIC0gVGhlIGtleXMgdG8gcGljay5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGlucHV0IGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsaXRpZXMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/utilities.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/utils.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   print: function() { return /* binding */ print; },\n/* harmony export */   run: function() { return /* binding */ run; },\n/* harmony export */   shiftIterator: function() { return /* binding */ shiftIterator; },\n/* harmony export */   toFailure: function() { return /* binding */ toFailure; },\n/* harmony export */   toFailures: function() { return /* binding */ toFailures; }\n/* harmony export */ });\n/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n//# sourceMappingURL=utils.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC91dGlscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksT0FBTztBQUNuQixZQUFZLG9EQUFvRCxLQUFLLElBQUksbUNBQW1DLFdBQVcsU0FBUyxvQkFBb0IsYUFBYSxPQUFPO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLDREQUE0RDtBQUN4RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvdXRpbHMubWpzP2RlOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwcmludC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG59XG4vKipcbiAqIFNoaWZ0IChyZW1vdmUgYW5kIHJldHVybikgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpdGVyYXRvciB0byBzaGlmdC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVyYXRvciBpc1xuICogZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaW5wdXQubmV4dCgpO1xuICAgIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICpcbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgcmVzdWx0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgYmVpbmcgdmFsaWRhdGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHZhbGlkYXRlZC5cbiAqIEByZXR1cm5zIEEgZmFpbHVyZSBpZiB0aGUgcmVzdWx0IGlzIGEgZmFpbHVyZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlc3VsdFxuICogaXMgYSBzdWNjZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZWZpbmVtZW50LFxuICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICpcbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgcmVzdWx0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgYmVpbmcgdmFsaWRhdGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHZhbGlkYXRlZC5cbiAqIEB5aWVsZHMgVGhlIGZhaWx1cmVzLlxuICogQHJldHVybnMgQW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdGlvblJlc3VsdCBvZiByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZSh2YWxpZGF0aW9uUmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICogQHBhcmFtIG9wdGlvbnMucGF0aCAtIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZSBpbiB0aGUgaW5wdXQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLmJyYW5jaCAtIFRoZSBicmFuY2ggb2YgdGhlIHZhbHVlIGluIHRoZSBpbnB1dCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMuY29lcmNlIC0gV2hldGhlciB0byBjb2VyY2UgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWFzayAtIFdoZXRoZXIgdG8gbWFzayB0aGUgdmFsdWUgYmVmb3JlIHZhbGlkYXRpbmcgaXQuXG4gKiBAcGFyYW0gb3B0aW9ucy5tZXNzYWdlIC0gQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAqIEB5aWVsZHMgQW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHBhdGgsIGJyYW5jaCB9O1xuICAgIGlmIChjb2VyY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWFzayAmJlxuICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXR1cyA9ICd2YWxpZCc7XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGZvciAobGV0IFtpbm5lcktleSwgaW5uZXJWYWx1ZSwgaW5uZXJTdHJ1Y3RdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjb250ZXh0KSkge1xuICAgICAgICBjb25zdCBpdGVyYWJsZSA9IHJ1bihpbm5lclZhbHVlLCBpbm5lclN0cnVjdCwge1xuICAgICAgICAgICAgcGF0aDogaW5uZXJLZXkgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwgaW5uZXJLZXldLFxuICAgICAgICAgICAgYnJhbmNoOiBpbm5lcktleSA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgaW5uZXJWYWx1ZV0sXG4gICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICBtYXNrLFxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gbnVsbCB8fCByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdub3RfdmFsaWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3Jlc3VsdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWUgPSByZXN1bHRbMV07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGlubmVyS2V5LCBpbm5lclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKGlubmVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBpbm5lcktleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaW5uZXJLZXldID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgc3RhdHVzID0gJ25vdF9yZWZpbmVkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/superstruct/dist/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/utils/dist/assert.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/assert.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssertionError: function() { return /* binding */ AssertionError; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assertExhaustive: function() { return /* binding */ assertExhaustive; },\n/* harmony export */   assertStruct: function() { return /* binding */ assertStruct; }\n/* harmony export */ });\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.mjs */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/errors.mjs\");\n\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0,_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\n//# sourceMappingURL=assert.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9hc3NlcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRTtBQUNyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWU7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkUsSUFBSSxhQUFhO0FBQ2pCO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFpQjtBQUN6QjtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksSUFBSSw0Q0FBNEM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5tanM/ZWY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQgYXMgYXNzZXJ0U3VwZXJzdHJ1Y3QgfSBmcm9tIFwiQG1ldGFtYXNrL3N1cGVyc3RydWN0XCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9lcnJvcnMubWpzXCI7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgZm4/LnByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gb2J0YWluIHRoZSBtZXNzYWdlIGZyb20gYSBwb3NzaWJsZSBlcnJvciBvYmplY3QuIElmIGl0IGlzXG4gKiBwb3NzaWJsZSB0byBkbyBzbywgYW55IHRyYWlsaW5nIHBlcmlvZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbWVzc2FnZTtcbiAqIG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIHdpdGhvdXQgYW55IHRyYWlsaW5nIHBlcmlvZCBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdFxuICogd2l0aCBhIGBtZXNzYWdlYCBwcm9wZXJ0eTsgdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgd2l0aG91dCBhbnkgdHJhaWxpbmdcbiAqIHBlcmlvZCBpZiBpdCBpcyBub3QgYHVuZGVmaW5lZGAgb3IgYG51bGxgOyBvdGhlcndpc2UgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2VXaXRob3V0VHJhaWxpbmdQZXJpb2QoZXJyb3IpIHtcbiAgICAvLyBXZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgcmV0dXJuIGdldEVycm9yTWVzc2FnZShlcnJvcikucmVwbGFjZSgvXFwuJC91LCAnJyk7XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYW4ge0BsaW5rIEFzc2VydGlvbkVycm9yQ29uc3RydWN0b3J9IGVycm9yLlxuICpcbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0NvbnN0cnVjdGFibGUoRXJyb3JXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yV3JhcHBlcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yV3JhcHBlcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVycm9yIGNsYXNzIHRoYXQgaXMgdGhyb3duIGlmIGFuIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWx1ZSBhZ2FpbnN0IGEgU3VwZXJzdHJ1Y3Qgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBBIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gKiBcIkFzc2VydGlvbiBmYWlsZWRcIi5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRTdXBlcnN0cnVjdCh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcil9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVXNlIGluIHRoZSBkZWZhdWx0IGNhc2Ugb2YgYSBzd2l0Y2ggdGhhdCB5b3Ugd2FudCB0byBiZSBmdWxseSBleGhhdXN0aXZlLlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiBmb3JjZXMgdGhlIGNvbXBpbGVyIHRvIGVuZm9yY2UgZXhoYXVzdGl2aXR5IGR1cmluZ1xuICogY29tcGlsZS10aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG51bWJlciA9IDE7XG4gKiBzd2l0Y2ggKG51bWJlcikge1xuICogICBjYXNlIDA6XG4gKiAgICAgLi4uXG4gKiAgIGNhc2UgMTpcbiAqICAgICAuLi5cbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3NlcnRFeGhhdXN0aXZlKHNuYXBQcmVmaXgpO1xuICogfVxuICogYGBgXG4gKiBAcGFyYW0gX29iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHN3aXRjaCBpcyBiZWluZyBvcGVyYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/utils/dist/assert.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/utils/dist/errors.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/errors.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getErrorMessage: function() { return /* binding */ getErrorMessage; },\n/* harmony export */   isErrorWithCode: function() { return /* binding */ isErrorWithCode; },\n/* harmony export */   isErrorWithMessage: function() { return /* binding */ isErrorWithMessage; },\n/* harmony export */   isErrorWithStack: function() { return /* binding */ isErrorWithStack; },\n/* harmony export */   wrapError: function() { return /* binding */ wrapError; }\n/* harmony export */ });\n/* harmony import */ var pony_cause__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pony-cause */ \"(app-pages-browser)/./node_modules/pony-cause/index.mjs\");\n/* harmony import */ var _misc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.mjs */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs\");\n\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause__WEBPACK_IMPORTED_MODULE_0__.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\n//# sourceMappingURL=errors.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbURBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBYyxZQUFZLHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0IsSUFBSSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMubWpzPzZjZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JXaXRoQ2F1c2UgfSBmcm9tIFwicG9ueS1jYXVzZVwiO1xuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQsIGlzT2JqZWN0IH0gZnJvbSBcIi4vbWlzYy5tanNcIjtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKiBGb3IgZXJyb3JzIGdlbmVyYXRlZCB2aWEgYGZzLnByb21pc2VzYCwgYGVycm9yIGluc3RhbmNlb2YgRXJyb3JgIHdvbid0IHdvcmssXG4gKiBzbyB3ZSBoYXZlIHRvIGNvbWUgdXAgd2l0aCBhbm90aGVyIHdheSBvZiB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRXJyb3InKSk7XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBjb2RlYCBwcm9wZXJ0eSBzdWNoIGFzIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgTm9kZSB0aHJvd3MgZm9yIGZpbGVzeXN0ZW1cbiAqIG9wZXJhdGlvbnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhTdGFjayhlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdzdGFjaycgaW4gZXJyb3I7XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBpZiAoaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgbmV3IGVycm9yIG9iamVjdCwgbGlua2luZyBpdCB0byB0aGUgb3JpZ2luYWwgZXJyb3IgdmlhIHRoZSBgY2F1c2VgXG4gKiBwcm9wZXJ0eSBpZiBpdCBpcyBhbiBFcnJvci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB0byByZWZyYW1lIGVycm9yIG1lc3NhZ2VzIGluIGdlbmVyYWwsIGJ1dCBpc1xuICogX2NyaXRpY2FsXyB3aGVuIGludGVyYWN0aW5nIHdpdGggYW55IG9mIE5vZGUncyBmaWxlc3lzdGVtIGZ1bmN0aW9ucyBhc1xuICogcHJvdmlkZWQgdmlhIGBmcy5wcm9taXNlc2AsIGJlY2F1c2UgdGhlc2UgZG8gbm90IHByb2R1Y2Ugc3RhY2sgdHJhY2VzIGluIHRoZVxuICogY2FzZSBvZiBhbiBJL08gZXJyb3IgKHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMDk0ND4pLlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbEVycm9yIC0gVGhlIGVycm9yIHRvIGJlIHdyYXBwZWQgKHNvbWV0aGluZyB0aHJvd2FibGUpLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZGVzaXJlZCBtZXNzYWdlIG9mIHRoZSBuZXcgZXJyb3IuXG4gKiBAcmV0dXJucyBBIG5ldyBlcnJvciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcldpdGhDYXVzZShtZXNzYWdlLCB7IGNhdXNlOiBvcmlnaW5hbEVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Vycm9yV2l0aENvZGUob3JpZ2luYWxFcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBvcmlnaW5hbEVycm9yLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYCR7U3RyaW5nKG9yaWdpbmFsRXJyb3IpfTogJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhvcmlnaW5hbEVycm9yKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/utils/dist/errors.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/utils/dist/json.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/json.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcErrorStruct: function() { return /* binding */ JsonRpcErrorStruct; },\n/* harmony export */   JsonRpcFailureStruct: function() { return /* binding */ JsonRpcFailureStruct; },\n/* harmony export */   JsonRpcIdStruct: function() { return /* binding */ JsonRpcIdStruct; },\n/* harmony export */   JsonRpcNotificationStruct: function() { return /* binding */ JsonRpcNotificationStruct; },\n/* harmony export */   JsonRpcParamsStruct: function() { return /* binding */ JsonRpcParamsStruct; },\n/* harmony export */   JsonRpcRequestStruct: function() { return /* binding */ JsonRpcRequestStruct; },\n/* harmony export */   JsonRpcResponseStruct: function() { return /* binding */ JsonRpcResponseStruct; },\n/* harmony export */   JsonRpcSuccessStruct: function() { return /* binding */ JsonRpcSuccessStruct; },\n/* harmony export */   JsonRpcVersionStruct: function() { return /* binding */ JsonRpcVersionStruct; },\n/* harmony export */   JsonStruct: function() { return /* binding */ JsonStruct; },\n/* harmony export */   PendingJsonRpcResponseStruct: function() { return /* binding */ PendingJsonRpcResponseStruct; },\n/* harmony export */   UnsafeJsonStruct: function() { return /* binding */ UnsafeJsonStruct; },\n/* harmony export */   assertIsJsonRpcError: function() { return /* binding */ assertIsJsonRpcError; },\n/* harmony export */   assertIsJsonRpcFailure: function() { return /* binding */ assertIsJsonRpcFailure; },\n/* harmony export */   assertIsJsonRpcNotification: function() { return /* binding */ assertIsJsonRpcNotification; },\n/* harmony export */   assertIsJsonRpcRequest: function() { return /* binding */ assertIsJsonRpcRequest; },\n/* harmony export */   assertIsJsonRpcResponse: function() { return /* binding */ assertIsJsonRpcResponse; },\n/* harmony export */   assertIsJsonRpcSuccess: function() { return /* binding */ assertIsJsonRpcSuccess; },\n/* harmony export */   assertIsPendingJsonRpcResponse: function() { return /* binding */ assertIsPendingJsonRpcResponse; },\n/* harmony export */   exactOptional: function() { return /* binding */ exactOptional; },\n/* harmony export */   getJsonRpcIdValidator: function() { return /* binding */ getJsonRpcIdValidator; },\n/* harmony export */   getJsonSize: function() { return /* binding */ getJsonSize; },\n/* harmony export */   getSafeJson: function() { return /* binding */ getSafeJson; },\n/* harmony export */   isJsonRpcError: function() { return /* binding */ isJsonRpcError; },\n/* harmony export */   isJsonRpcFailure: function() { return /* binding */ isJsonRpcFailure; },\n/* harmony export */   isJsonRpcNotification: function() { return /* binding */ isJsonRpcNotification; },\n/* harmony export */   isJsonRpcRequest: function() { return /* binding */ isJsonRpcRequest; },\n/* harmony export */   isJsonRpcResponse: function() { return /* binding */ isJsonRpcResponse; },\n/* harmony export */   isJsonRpcSuccess: function() { return /* binding */ isJsonRpcSuccess; },\n/* harmony export */   isPendingJsonRpcResponse: function() { return /* binding */ isPendingJsonRpcResponse; },\n/* harmony export */   isValidJson: function() { return /* binding */ isValidJson; },\n/* harmony export */   jsonrpc2: function() { return /* binding */ jsonrpc2; },\n/* harmony export */   object: function() { return /* binding */ object; }\n/* harmony export */ });\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/types.mjs\");\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/utilities.mjs\");\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/coercions.mjs\");\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @metamask/superstruct */ \"(app-pages-browser)/./node_modules/@metamask/superstruct/dist/structs/refinements.mjs\");\n/* harmony import */ var _assert_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assert.mjs */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/assert.mjs\");\n/* harmony import */ var _misc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.mjs */ \"(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs\");\n\n\n\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nconst object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\n(0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.object)(schema);\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return (0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nfunction exactOptional(struct) {\n    return new _metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json) {\n    if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n        return true;\n    }\n    if (typeof json === 'number' && Number.isFinite(json)) {\n        return true;\n    }\n    if (typeof json === 'object') {\n        let every = true;\n        if (Array.isArray(json)) {\n            // Ignoring linting error since for-of is significantly slower than a normal for-loop\n            // and performance is important in this specific function.\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < json.length; i++) {\n                if (!validateJson(json[i])) {\n                    every = false;\n                    break;\n                }\n            }\n            return every;\n        }\n        const entries = Object.entries(json);\n        // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n        // and performance is important in this specific function.\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < entries.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {\n                every = false;\n                break;\n            }\n        }\n        return every;\n    }\n    return false;\n}\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nconst UnsafeJsonStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_3__.define)('JSON', (json) => validateJson(json));\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nconst JsonStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_4__.coerce)(UnsafeJsonStruct, (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_5__.refine)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.any)(), 'JSON', (value) => (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n    // Strip __proto__ and constructor properties to prevent prototype pollution.\n    if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n    }\n    return propValue;\n})));\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nfunction getSafeJson(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.create)(value, JsonStruct);\n}\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\n/**\n * The string '2.0'.\n */\nconst jsonrpc2 = '2.0';\nconst JsonRpcVersionStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.literal)(jsonrpc2);\nconst JsonRpcIdStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.nullable)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.union)([(0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.number)(), (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)()]));\nconst JsonRpcErrorStruct = object({\n    code: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.integer)(),\n    message: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)(),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)()),\n});\nconst JsonRpcParamsStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.union)([(0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.record)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)(), JsonStruct), (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.array)(JsonStruct)]);\nconst JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\nconst JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.string)(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, JsonRpcNotificationStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, JsonRpcRequestStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nconst PendingJsonRpcResponseStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.object)({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.optional)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.unknown)()),\n    error: (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.optional)(JsonRpcErrorStruct),\n});\nconst JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct,\n});\nconst JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct,\n});\nconst JsonRpcResponseStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_0__.union)([\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(response, PendingJsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(response, JsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, JsonRpcSuccessStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, JsonRpcFailureStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n    return (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.is)(value, JsonRpcErrorStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_6__.assertStruct)(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\n//# sourceMappingURL=json.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBNO0FBQzlKO0FBQ0g7QUFDekM7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZEQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQSxXQUFXLHNEQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSx5REFBTTtBQUNyQjtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNPLHlCQUF5Qiw2REFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsNkRBQU0sbUJBQW1CLDZEQUFNLENBQUMsMERBQUcsdUJBQXVCLHlEQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2REFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBLDZCQUE2Qiw4REFBTztBQUNwQyx3QkFBd0IsK0RBQVEsQ0FBQyw0REFBSyxFQUFFLDZEQUFNLElBQUksNkRBQU07QUFDeEQ7QUFDUCxVQUFVLDhEQUFPO0FBQ2pCLGFBQWEsNkRBQU07QUFDbkI7QUFDQSx5QkFBeUIsNkRBQU07QUFDL0IsQ0FBQztBQUNNLDRCQUE0Qiw0REFBSyxFQUFFLDZEQUFNLENBQUMsNkRBQU0saUJBQWlCLDREQUFLO0FBQ3RFO0FBQ1A7QUFDQTtBQUNBLFlBQVksNkRBQU07QUFDbEI7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBLFlBQVksNkRBQU07QUFDbEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBRTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUkseURBQVk7QUFDaEI7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDTztBQUNQLFdBQVcseURBQUU7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHlEQUFZO0FBQ2hCO0FBQ08scUNBQXFDLDZEQUFpQjtBQUM3RDtBQUNBO0FBQ0EsWUFBWSwrREFBUSxDQUFDLDhEQUFPO0FBQzVCLFdBQVcsK0RBQVE7QUFDbkIsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLDhCQUE4Qiw0REFBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcseURBQUU7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QztBQUM5QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSx5REFBWTtBQUNoQjtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBRTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUkseURBQVk7QUFDaEI7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDTztBQUNQLFdBQVcseURBQUU7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHlEQUFZO0FBQ2hCO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ087QUFDUCxXQUFXLHlEQUFFO0FBQ2I7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSx5REFBWTtBQUNoQjtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNPO0FBQ1AsV0FBVyx5REFBRTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUkseURBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLm1qcz8xZDMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFueSwgYXJyYXksIGNvZXJjZSwgY3JlYXRlLCBkZWZpbmUsIGludGVnZXIsIGlzLCBsaXRlcmFsLCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QgYXMgc3VwZXJzdHJ1Y3RPYmplY3QsIG9wdGlvbmFsLCByZWNvcmQsIHN0cmluZywgdW5pb24sIHVua25vd24sIFN0cnVjdCwgcmVmaW5lIH0gZnJvbSBcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiO1xuaW1wb3J0IHsgYXNzZXJ0U3RydWN0IH0gZnJvbSBcIi4vYXNzZXJ0Lm1qc1wiO1xuaW1wb3J0IHsgaGFzUHJvcGVydHkgfSBmcm9tIFwiLi9taXNjLm1qc1wiO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBvYmplY3QsIHdpdGggc3VwcG9ydCBmb3JcbiAqIHtAbGluayBleGFjdE9wdGlvbmFsfSB0eXBlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGV4YWN0T3B0aW9uYWxgIGFuZCBgb2JqZWN0YCBmcm9tIGBAbWV0YW1hc2svc3VwZXJzdHJ1Y3RAPj0zLjIuMGAgaW5zdGVhZC5cbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIG9mIHRoZSBvYmplY3QuXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3Qgb2JqZWN0ID0gKHNjaGVtYSkgPT4gXG4vLyBUaGUgdHlwZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBhIHJlZ3VsYXIgb2JqZWN0IHN0cnVjdCwgYmVjYXVzZSB3ZVxuLy8gd2FudCB0byBtYWtlIHByb3BlcnRpZXMgd2l0aCBgdW5kZWZpbmVkYCBpbiB0aGVpciB0eXBlIG9wdGlvbmFsLCBidXQgbm90XG4vLyBgdW5kZWZpbmVkYCBpdHNlbGYuIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIGEgdHlwZSBjYXN0Llxuc3VwZXJzdHJ1Y3RPYmplY3Qoc2NoZW1hKTtcbi8qKlxuICogQ2hlY2sgdGhlIGxhc3QgZmllbGQgb2YgYSBwYXRoIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB0byBjaGVjay5cbiAqIEBwYXJhbSBjb250ZXh0LnBhdGggLSBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSBjb250ZXh0LmJyYW5jaCAtIFRoZSBicmFuY2ggdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBsYXN0IGZpZWxkIG9mIGEgcGF0aCBpcyBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBoYXNPcHRpb25hbCh7IHBhdGgsIGJyYW5jaCB9KSB7XG4gICAgY29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGhhc1Byb3BlcnR5KGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMl0sIGZpZWxkKTtcbn1cbi8qKlxuICogQSBzdHJ1Y3Qgd2hpY2ggYWxsb3dzIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdG8gYmUgYWJzZW50LCBvciB0byBiZSBwcmVzZW50XG4gKiBhcyBsb25nIGFzIGl0J3MgdmFsaWQgYW5kIG5vdCBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2hvdWxkIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUge0BsaW5rIG9iamVjdH0gZnJvbSB0aGlzXG4gKiBsaWJyYXJ5LCB0byBnZXQgcHJvcGVyIHR5cGUgaW5mZXJlbmNlLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgZXhhY3RPcHRpb25hbGAgYW5kIGBvYmplY3RgIGZyb20gYEBtZXRhbWFzay9zdXBlcnN0cnVjdEA+PTMuMi4wYCBpbnN0ZWFkLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gY2hlY2sgdGhlIHZhbHVlIGFnYWluc3QsIGlmIHByZXNlbnQuXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQsIG9yIG5vdCBwcmVzZW50LlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBzdHJ1Y3QgPSBvYmplY3Qoe1xuICogICBmb286IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpLFxuICogICBiYXI6IGV4YWN0T3B0aW9uYWwobnVtYmVyKCkpLFxuICogICBiYXo6IG9wdGlvbmFsKGJvb2xlYW4oKSksXG4gKiAgIHF1eDogdW5rbm93bigpLFxuICogfSk7XG4gKlxuICogdHlwZSBUeXBlID0gSW5mZXI8dHlwZW9mIHN0cnVjdD47XG4gKiAvLyBUeXBlIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyB7XG4gKiAvLyAgIGZvbz86IHN0cmluZztcbiAqIC8vICAgYmFyPzogbnVtYmVyO1xuICogLy8gICBiYXo/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICogLy8gICBxdXg6IHVua25vd247XG4gKiAvLyB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHR5cGU6IGBvcHRpb25hbCAke3N0cnVjdC50eXBlfWAsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY29udGV4dCkgPT4gIWhhc09wdGlvbmFsKGNvbnRleHQpIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjb250ZXh0KSxcbiAgICB9KTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYW4gdW5rbm93biBpbnB1dCB0byBiZSB2YWxpZCBKU09OLlxuICpcbiAqIFVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIEpTT04gc3RydWN0cy5cbiAqXG4gKiBAcGFyYW0ganNvbiAtIEFuIHVua25vd24gdmFsdWUuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBKU09OLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbihqc29uKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwgfHwgdHlwZW9mIGpzb24gPT09ICdib29sZWFuJyB8fCB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKGpzb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxldCBldmVyeSA9IHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmluZyBsaW50aW5nIGVycm9yIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgICAgICAvLyBhbmQgcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50IGluIHRoaXMgc3BlY2lmaWMgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVKc29uKGpzb25baV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoanNvbik7XG4gICAgICAgIC8vIElnbm9yaW5nIGxpbnRpbmcgZXJyb3JzIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgIC8vIGFuZCBwZXJmb3JtYW5jZSBpcyBpbXBvcnRhbnQgaW4gdGhpcyBzcGVjaWZpYyBmdW5jdGlvbi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cmllc1tpXVswXSAhPT0gJ3N0cmluZycgfHwgIXZhbGlkYXRlSnNvbihlbnRyaWVzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHN0cnVjdCBpcyB1bnNhZmUuIEZvciBzYWZlIHZhbGlkYXRpb24sIHVzZSB7QGxpbmsgSnNvblN0cnVjdH0uXG4gKi9cbmV4cG9ydCBjb25zdCBVbnNhZmVKc29uU3RydWN0ID0gZGVmaW5lKCdKU09OJywgKGpzb24pID0+IHZhbGlkYXRlSnNvbihqc29uKSk7XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIFRoaXMgc3RydWN0IHNhbml0aXplcyB0aGUgdmFsdWUgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHNvIHRoYXQgaXQgaXMgc2FmZSB0b1xuICogdXNlIHdpdGggdW50cnVzdGVkIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgSnNvblN0cnVjdCA9IGNvZXJjZShVbnNhZmVKc29uU3RydWN0LCByZWZpbmUoYW55KCksICdKU09OJywgKHZhbHVlKSA9PiBpcyh2YWx1ZSwgVW5zYWZlSnNvblN0cnVjdCkpLCAodmFsdWUpID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUsIChwcm9wS2V5LCBwcm9wVmFsdWUpID0+IHtcbiAgICAvLyBTdHJpcCBfX3Byb3RvX18gYW5kIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uLlxuICAgIGlmIChwcm9wS2V5ID09PSAnX19wcm90b19fJyB8fCBwcm9wS2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWU7XG59KSkpO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUsIGkuZS4sIGEgdmFsdWUgdGhhdCBpc1xuICogc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldFNhZmVKc29uKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGUgYW5kIHJldHVybiBzYW5pdGl6ZWQgSlNPTi5cbiAqXG4gKiBOb3RlOlxuICogVGhpcyBmdW5jdGlvbiB1c2VzIHNhbml0aXplZCBKc29uU3RydWN0IGZvciB2YWxpZGF0aW9uXG4gKiB0aGF0IGFwcGxpZXMgc3RyaW5naWZ5IGFuZCB0aGVuIHBhcnNlIG9mIGEgdmFsdWUgcHJvdmlkZWRcbiAqIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBubyBnZXR0ZXJzIHdoaWNoIGNhbiBoYXZlIHNpZGUgZWZmZWN0c1xuICogdGhhdCBjYW4gY2F1c2Ugc2VjdXJpdHkgaXNzdWVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEpTT04gc3RydWN0dXJlIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEByZXR1cm5zIFNhbml0aXplZCBKU09OIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgSnNvblN0cnVjdCk7XG59XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SnNvblNpemUodmFsdWUpIHtcbiAgICBhc3NlcnRTdHJ1Y3QodmFsdWUsIEpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0IGNvbnN0IGpzb25ycGMyID0gJzIuMCc7XG5leHBvcnQgY29uc3QgSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBsaXRlcmFsKGpzb25ycGMyKTtcbmV4cG9ydCBjb25zdCBKc29uUnBjSWRTdHJ1Y3QgPSBudWxsYWJsZSh1bmlvbihbbnVtYmVyKCksIHN0cmluZygpXSkpO1xuZXhwb3J0IGNvbnN0IEpzb25ScGNFcnJvclN0cnVjdCA9IG9iamVjdCh7XG4gICAgY29kZTogaW50ZWdlcigpLFxuICAgIG1lc3NhZ2U6IHN0cmluZygpLFxuICAgIGRhdGE6IGV4YWN0T3B0aW9uYWwoSnNvblN0cnVjdCksXG4gICAgc3RhY2s6IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpLFxufSk7XG5leHBvcnQgY29uc3QgSnNvblJwY1BhcmFtc1N0cnVjdCA9IHVuaW9uKFtyZWNvcmQoc3RyaW5nKCksIEpzb25TdHJ1Y3QpLCBhcnJheShKc29uU3RydWN0KV0pO1xuZXhwb3J0IGNvbnN0IEpzb25ScGNSZXF1ZXN0U3RydWN0ID0gb2JqZWN0KHtcbiAgICBpZDogSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIG1ldGhvZDogc3RyaW5nKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpLFxufSk7XG5leHBvcnQgY29uc3QgSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IG9iamVjdCh7XG4gICAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiBzdHJpbmcoKSxcbiAgICBwYXJhbXM6IGV4YWN0T3B0aW9uYWwoSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0KTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICBhc3NlcnRTdHJ1Y3QodmFsdWUsIEpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIG5vdGlmaWNhdGlvbicsIEVycm9yV3JhcHBlcik7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25ScGNSZXF1ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCBKc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1JlcXVlc3QodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgYXNzZXJ0U3RydWN0KHZhbHVlLCBKc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnQgY29uc3QgUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IHN1cGVyc3RydWN0T2JqZWN0KHtcbiAgICBpZDogSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogb3B0aW9uYWwodW5rbm93bigpKSxcbiAgICBlcnJvcjogb3B0aW9uYWwoSnNvblJwY0Vycm9yU3RydWN0KSxcbn0pO1xuZXhwb3J0IGNvbnN0IEpzb25ScGNTdWNjZXNzU3RydWN0ID0gb2JqZWN0KHtcbiAgICBpZDogSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0IGNvbnN0IEpzb25ScGNGYWlsdXJlU3RydWN0ID0gb2JqZWN0KHtcbiAgICBpZDogSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBKc29uUnBjRXJyb3JTdHJ1Y3QsXG59KTtcbmV4cG9ydCBjb25zdCBKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSB1bmlvbihbXG4gICAgSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsXG5dKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayB3aGV0aGVyIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBhXG4gKiB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIHBlbmRpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gaXMocmVzcG9uc2UsIFBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICBhc3NlcnRTdHJ1Y3QocmVzcG9uc2UsIFBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgSnNvblJwY1Jlc3BvbnNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gaXMocmVzcG9uc2UsIEpzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgYXNzZXJ0U3RydWN0KHZhbHVlLCBKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICBhc3NlcnRTdHJ1Y3QodmFsdWUsIEpzb25ScGNTdWNjZXNzU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBzdWNjZXNzIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNGYWlsdXJlU3RydWN0KTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICBhc3NlcnRTdHJ1Y3QodmFsdWUsIEpzb25ScGNGYWlsdXJlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBmYWlsdXJlIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNFcnJvclN0cnVjdCk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRXJyb3IodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgYXNzZXJ0U3RydWN0KHZhbHVlLCBKc29uUnBjRXJyb3JTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGVycm9yJywgRXJyb3JXcmFwcGVyKTtcbn1cbi8qKlxuICogR2V0cyBhIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW5nIEpTT04tUlBDIHJlcXVlc3QgLyByZXNwb25zZSBgaWRgIHZhbHVlcy5cbiAqXG4gKiBCeSBtYW5pcHVsYXRpbmcgdGhlIG9wdGlvbnMgb2YgdGhpcyBmYWN0b3J5LCB5b3UgY2FuIGNvbnRyb2wgdGhlIGJlaGF2aW9yXG4gKiBvZiB0aGUgcmVzdWx0aW5nIHZhbGlkYXRvciBmb3Igc29tZSBlZGdlIGNhc2VzLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGUuZy5cbiAqIGBudWxsYCBzaG91bGQgc29tZXRpbWVzIGJ1dCBub3QgYWx3YXlzIGJlIHBlcm1pdHRlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGVtcHR5IHN0cmluZyAoYCcnYCkgaXMgYWx3YXlzIHBlcm1pdHRlZCBieSB0aGUgSlNPTi1SUENcbiAqIHNwZWNpZmljYXRpb24sIGJ1dCB0aGF0IGtpbmQgb2Ygc3Vja3MgYW5kIHlvdSBtYXkgd2FudCB0byBmb3JiaWQgaXQgaW4gc29tZVxuICogaW5zdGFuY2VzIGFueXdheS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlXG4gKiBbSlNPTi1SUEMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEVtcHR5U3RyaW5nIC0gV2hldGhlciB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGAnJ2ApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEZyYWN0aW9ucyAtIFdoZXRoZXIgZnJhY3Rpb25hbCBudW1iZXJzIChlLmcuIGAxLjJgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQgSURzLiBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXROdWxsIC0gV2hldGhlciBgbnVsbGAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC5cbiAqIERlZmF1bHQ6IGB0cnVlYFxuICogQHJldHVybnMgVGhlIEpTT04tUlBDIElEIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpzb25ScGNJZFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwZXJtaXRFbXB0eVN0cmluZywgcGVybWl0RnJhY3Rpb25zLCBwZXJtaXROdWxsIH0gPSB7XG4gICAgICAgIHBlcm1pdEVtcHR5U3RyaW5nOiB0cnVlLFxuICAgICAgICBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLFxuICAgICAgICBwZXJtaXROdWxsOiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb25ScGNJZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSlNPTi1SUEMgSUQgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gSUQgaXMgdmFsaWQgcGVyIHRoZSBvcHRpb25zIGdpdmVuIHRvIHRoZVxuICAgICAqIGZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3QgaXNWYWxpZEpzb25ScGNJZCA9IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiAocGVybWl0RnJhY3Rpb25zIHx8IE51bWJlci5pc0ludGVnZXIoaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSkgfHxcbiAgICAgICAgICAgIChwZXJtaXROdWxsICYmIGlkID09PSBudWxsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNWYWxpZEpzb25ScGNJZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/utils/dist/json.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/misc.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESCAPE_CHARACTERS_REGEXP: function() { return /* binding */ ESCAPE_CHARACTERS_REGEXP; },\n/* harmony export */   JsonSize: function() { return /* binding */ JsonSize; },\n/* harmony export */   calculateNumberSize: function() { return /* binding */ calculateNumberSize; },\n/* harmony export */   calculateStringSize: function() { return /* binding */ calculateStringSize; },\n/* harmony export */   getKnownPropertyNames: function() { return /* binding */ getKnownPropertyNames; },\n/* harmony export */   hasProperty: function() { return /* binding */ hasProperty; },\n/* harmony export */   isASCII: function() { return /* binding */ isASCII; },\n/* harmony export */   isNonEmptyArray: function() { return /* binding */ isNonEmptyArray; },\n/* harmony export */   isNullOrUndefined: function() { return /* binding */ isNullOrUndefined; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; }\n/* harmony export */ });\n//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nconst ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9taXNjLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQkFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVDQUF1QztBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9taXNjLm1qcz8zODViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBUeXBlc1xuLy9cbi8vXG4vLyBUeXBlIEd1YXJkc1xuLy9cbi8qKlxuICogQSB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgRWxlbWVudCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtub3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbn1cbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG5leHBvcnQgdmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBKc29uU2l6ZSB8fCAoSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgY29uc3QgRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKHZhbHVlLm1hdGNoKEVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHNpemUgb2YgYSBudW1iZXIgb2Z0ZXIgSlNPTiBzZXJpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIG51bWJlciBpbiBKU09OLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@metamask/utils/dist/misc.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pony-cause/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/pony-cause/index.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorWithCause: function() { return /* reexport safe */ _lib_error_with_cause_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorWithCause; },\n/* harmony export */   findCauseByReference: function() { return /* reexport safe */ _lib_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.findCauseByReference; },\n/* harmony export */   getErrorCause: function() { return /* reexport safe */ _lib_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.getErrorCause; },\n/* harmony export */   messageWithCauses: function() { return /* reexport safe */ _lib_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.messageWithCauses; },\n/* harmony export */   stackWithCauses: function() { return /* reexport safe */ _lib_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.stackWithCauses; }\n/* harmony export */ });\n/* harmony import */ var _lib_error_with_cause_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/error-with-cause.mjs */ \"(app-pages-browser)/./node_modules/pony-cause/lib/error-with-cause.mjs\");\n/* harmony import */ var _lib_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers.mjs */ \"(app-pages-browser)/./node_modules/pony-cause/lib/helpers.mjs\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb255LWNhdXNlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRStDOztBQU9qQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9ueS1jYXVzZS9pbmRleC5tanM/MDBlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCB7IEVycm9yV2l0aENhdXNlIH0gZnJvbSAnLi9saWIvZXJyb3Itd2l0aC1jYXVzZS5tanMnO1xuXG5leHBvcnQge1xuICBmaW5kQ2F1c2VCeVJlZmVyZW5jZSxcbiAgZ2V0RXJyb3JDYXVzZSxcbiAgbWVzc2FnZVdpdGhDYXVzZXMsXG4gIHN0YWNrV2l0aENhdXNlcyxcbn0gZnJvbSAnLi9saWIvaGVscGVycy5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pony-cause/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pony-cause/lib/error-with-cause.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pony-cause/lib/error-with-cause.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorWithCause: function() { return /* binding */ ErrorWithCause; }\n/* harmony export */ });\n\n\n/** @template [T=undefined] */\nclass ErrorWithCause extends Error {\n  /**\n   * @param {string} message\n   * @param {{ cause?: T }} options\n   */\n  constructor (message, { cause } = {}) {\n    super(message);\n\n    /** @type {string} */\n    this.name = ErrorWithCause.name;\n    if (cause) {\n      /** @type {T} */\n      this.cause = cause;\n    }\n    /** @type {string} */\n    this.message = message;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb255LWNhdXNlL2xpYi9lcnJvci13aXRoLWNhdXNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7O0FBRWI7QUFDTztBQUNQO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBLDBCQUEwQixRQUFRLElBQUk7QUFDdEM7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9ueS1jYXVzZS9saWIvZXJyb3Itd2l0aC1jYXVzZS5tanM/YjIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdGVtcGxhdGUgW1Q9dW5kZWZpbmVkXSAqL1xuZXhwb3J0IGNsYXNzIEVycm9yV2l0aENhdXNlIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHt7IGNhdXNlPzogVCB9fSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgeyBjYXVzZSB9ID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMubmFtZSA9IEVycm9yV2l0aENhdXNlLm5hbWU7XG4gICAgaWYgKGNhdXNlKSB7XG4gICAgICAvKiogQHR5cGUge1R9ICovXG4gICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pony-cause/lib/error-with-cause.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pony-cause/lib/helpers.mjs":
/*!*************************************************!*\
  !*** ./node_modules/pony-cause/lib/helpers.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findCauseByReference: function() { return /* binding */ findCauseByReference; },\n/* harmony export */   getErrorCause: function() { return /* binding */ getErrorCause; },\n/* harmony export */   messageWithCauses: function() { return /* binding */ messageWithCauses; },\n/* harmony export */   stackWithCauses: function() { return /* binding */ stackWithCauses; }\n/* harmony export */ });\n\n\n/**\n * @template {Error} T\n * @param {unknown} err\n * @param {new(...args: any[]) => T} reference\n * @returns {T|undefined}\n */\nconst findCauseByReference = (err, reference) => {\n  if (!err || !reference) return;\n  if (!(err instanceof Error)) return;\n  if (\n    !(reference.prototype instanceof Error) &&\n    // @ts-ignore\n    reference !== Error\n  ) return;\n\n  /**\n   * Ensures we don't go circular\n   *\n   * @type {Set<Error>}\n   */\n  const seen = new Set();\n\n  /** @type {Error|undefined} */\n  let currentErr = err;\n\n  while (currentErr && !seen.has(currentErr)) {\n    seen.add(currentErr);\n\n    if (currentErr instanceof reference) {\n      return currentErr;\n    }\n\n    currentErr = getErrorCause(currentErr);\n  }\n};\n\n/**\n * @param {Error|{ cause?: unknown|(()=>err)}} err\n * @returns {Error|undefined}\n */\nconst getErrorCause = (err) => {\n  if (!err || typeof err !== 'object' || !('cause' in err)) {\n    return;\n  }\n\n  // VError / NError style causes\n  if (typeof err.cause === 'function') {\n    const causeResult = err.cause();\n\n    return causeResult instanceof Error\n      ? causeResult\n      : undefined;\n  } else {\n    return err.cause instanceof Error\n      ? err.cause\n      : undefined;\n  }\n};\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @returns {string}\n */\nconst _stackWithCauses = (err, seen) => {\n  if (!(err instanceof Error)) return '';\n\n  const stack = err.stack || '';\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return stack + '\\ncauses have become circular...';\n  }\n\n  const cause = getErrorCause(err);\n\n  // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff\n\n  if (cause) {\n    seen.add(err);\n    return (stack + '\\ncaused by: ' + _stackWithCauses(cause, seen));\n  } else {\n    return stack;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nconst stackWithCauses = (err) => _stackWithCauses(err, new Set());\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @param {boolean} [skip]\n * @returns {string}\n */\nconst _messageWithCauses = (err, seen, skip) => {\n  if (!(err instanceof Error)) return '';\n\n  const message = skip ? '' : (err.message || '');\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return message + ': ...';\n  }\n\n  const cause = getErrorCause(err);\n\n  if (cause) {\n    seen.add(err);\n\n    const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';\n\n    return (message +\n      (skipIfVErrorStyleCause ? '' : ': ') +\n      _messageWithCauses(cause, seen, skipIfVErrorStyleCause));\n  } else {\n    return message;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nconst messageWithCauses = (err) => _messageWithCauses(err, new Set());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb255LWNhdXNlL2xpYi9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7O0FBRWI7QUFDQSxjQUFjLE9BQU87QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsMEJBQTBCO0FBQ3JDLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRLDRCQUE0QjtBQUMvQyxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wb255LWNhdXNlL2xpYi9oZWxwZXJzLm1qcz81MmQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdGVtcGxhdGUge0Vycm9yfSBUXG4gKiBAcGFyYW0ge3Vua25vd259IGVyclxuICogQHBhcmFtIHtuZXcoLi4uYXJnczogYW55W10pID0+IFR9IHJlZmVyZW5jZVxuICogQHJldHVybnMge1R8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgZmluZENhdXNlQnlSZWZlcmVuY2UgPSAoZXJyLCByZWZlcmVuY2UpID0+IHtcbiAgaWYgKCFlcnIgfHwgIXJlZmVyZW5jZSkgcmV0dXJuO1xuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHJldHVybjtcbiAgaWYgKFxuICAgICEocmVmZXJlbmNlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKSAmJlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZWZlcmVuY2UgIT09IEVycm9yXG4gICkgcmV0dXJuO1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHdlIGRvbid0IGdvIGNpcmN1bGFyXG4gICAqXG4gICAqIEB0eXBlIHtTZXQ8RXJyb3I+fVxuICAgKi9cbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcblxuICAvKiogQHR5cGUge0Vycm9yfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnRFcnIgPSBlcnI7XG5cbiAgd2hpbGUgKGN1cnJlbnRFcnIgJiYgIXNlZW4uaGFzKGN1cnJlbnRFcnIpKSB7XG4gICAgc2Vlbi5hZGQoY3VycmVudEVycik7XG5cbiAgICBpZiAoY3VycmVudEVyciBpbnN0YW5jZW9mIHJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRFcnI7XG4gICAgfVxuXG4gICAgY3VycmVudEVyciA9IGdldEVycm9yQ2F1c2UoY3VycmVudEVycik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcnx7IGNhdXNlPzogdW5rbm93bnwoKCk9PmVycil9fSBlcnJcbiAqIEByZXR1cm5zIHtFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFcnJvckNhdXNlID0gKGVycikgPT4ge1xuICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCAhKCdjYXVzZScgaW4gZXJyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFZFcnJvciAvIE5FcnJvciBzdHlsZSBjYXVzZXNcbiAgaWYgKHR5cGVvZiBlcnIuY2F1c2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjYXVzZVJlc3VsdCA9IGVyci5jYXVzZSgpO1xuXG4gICAgcmV0dXJuIGNhdXNlUmVzdWx0IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgID8gY2F1c2VSZXN1bHRcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlcnIuY2F1c2UgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgPyBlcnIuY2F1c2VcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB0aGF0IGtlZXBzIGEgdHJhY2sgb2Ygd2hpY2ggZXJyb3Igd2UgaGF2ZSBhbHJlYWR5IGFkZGVkLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1NldDxFcnJvcj59IHNlZW5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IF9zdGFja1dpdGhDYXVzZXMgPSAoZXJyLCBzZWVuKSA9PiB7XG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkgcmV0dXJuICcnO1xuXG4gIGNvbnN0IHN0YWNrID0gZXJyLnN0YWNrIHx8ICcnO1xuXG4gIC8vIEVuc3VyZSB3ZSBkb24ndCBnbyBjaXJjdWxhciBvciBjcmF6aWx5IGRlZXBcbiAgaWYgKHNlZW4uaGFzKGVycikpIHtcbiAgICByZXR1cm4gc3RhY2sgKyAnXFxuY2F1c2VzIGhhdmUgYmVjb21lIGNpcmN1bGFyLi4uJztcbiAgfVxuXG4gIGNvbnN0IGNhdXNlID0gZ2V0RXJyb3JDYXVzZShlcnIpO1xuXG4gIC8vIFRPRE86IEZvbGxvdyB1cCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM4NzI1I2lzc3VlY29tbWVudC05MjAzMDkwOTIgb24gaG93IHRvIGxvZyBzdHVmZlxuXG4gIGlmIChjYXVzZSkge1xuICAgIHNlZW4uYWRkKGVycik7XG4gICAgcmV0dXJuIChzdGFjayArICdcXG5jYXVzZWQgYnk6ICcgKyBfc3RhY2tXaXRoQ2F1c2VzKGNhdXNlLCBzZWVuKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHN0YWNrV2l0aENhdXNlcyA9IChlcnIpID0+IF9zdGFja1dpdGhDYXVzZXMoZXJyLCBuZXcgU2V0KCkpO1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB0aGF0IGtlZXBzIGEgdHJhY2sgb2Ygd2hpY2ggZXJyb3Igd2UgaGF2ZSBhbHJlYWR5IGFkZGVkLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1NldDxFcnJvcj59IHNlZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBfbWVzc2FnZVdpdGhDYXVzZXMgPSAoZXJyLCBzZWVuLCBza2lwKSA9PiB7XG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkgcmV0dXJuICcnO1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBza2lwID8gJycgOiAoZXJyLm1lc3NhZ2UgfHwgJycpO1xuXG4gIC8vIEVuc3VyZSB3ZSBkb24ndCBnbyBjaXJjdWxhciBvciBjcmF6aWx5IGRlZXBcbiAgaWYgKHNlZW4uaGFzKGVycikpIHtcbiAgICByZXR1cm4gbWVzc2FnZSArICc6IC4uLic7XG4gIH1cblxuICBjb25zdCBjYXVzZSA9IGdldEVycm9yQ2F1c2UoZXJyKTtcblxuICBpZiAoY2F1c2UpIHtcbiAgICBzZWVuLmFkZChlcnIpO1xuXG4gICAgY29uc3Qgc2tpcElmVkVycm9yU3R5bGVDYXVzZSA9ICdjYXVzZScgaW4gZXJyICYmIHR5cGVvZiBlcnIuY2F1c2UgPT09ICdmdW5jdGlvbic7XG5cbiAgICByZXR1cm4gKG1lc3NhZ2UgK1xuICAgICAgKHNraXBJZlZFcnJvclN0eWxlQ2F1c2UgPyAnJyA6ICc6ICcpICtcbiAgICAgIF9tZXNzYWdlV2l0aENhdXNlcyhjYXVzZSwgc2Vlbiwgc2tpcElmVkVycm9yU3R5bGVDYXVzZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VXaXRoQ2F1c2VzID0gKGVycikgPT4gX21lc3NhZ2VXaXRoQ2F1c2VzKGVyciwgbmV3IFNldCgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pony-cause/lib/helpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/viem/_esm/utils/abi/encodePacked.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_esm/utils/abi/encodePacked.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodePacked: function() { return /* binding */ encodePacked; }\n/* harmony export */ });\n/* harmony import */ var _errors_abi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors/abi.js */ \"(app-pages-browser)/./node_modules/viem/_esm/errors/abi.js\");\n/* harmony import */ var _errors_address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/address.js */ \"(app-pages-browser)/./node_modules/viem/_esm/errors/address.js\");\n/* harmony import */ var _address_isAddress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/isAddress.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/address/isAddress.js\");\n/* harmony import */ var _data_concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/concat.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/concat.js\");\n/* harmony import */ var _data_pad_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/pad.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var _encoding_toHex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../encoding/toHex.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../regex.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/regex.js\");\n\n\n\n\n\n\n\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new _errors_abi_js__WEBPACK_IMPORTED_MODULE_0__.AbiEncodingLengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encode(type, value));\n    }\n    return (0,_data_concat_js__WEBPACK_IMPORTED_MODULE_1__.concatHex)(data);\n}\nfunction encode(type, value, isArray = false) {\n    if (type === 'address') {\n        const address = value;\n        if (!(0,_address_isAddress_js__WEBPACK_IMPORTED_MODULE_2__.isAddress)(address))\n            throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAddressError({ address });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_4__.pad)(address.toLowerCase(), {\n            size: isArray ? 32 : null,\n        });\n    }\n    if (type === 'string')\n        return (0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_5__.stringToHex)(value);\n    if (type === 'bytes')\n        return value;\n    if (type === 'bool')\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_4__.pad)((0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_5__.boolToHex)(value), { size: isArray ? 32 : 1 });\n    const intMatch = type.match(_regex_js__WEBPACK_IMPORTED_MODULE_6__.integerRegex);\n    if (intMatch) {\n        const [_type, baseType, bits = '256'] = intMatch;\n        const size = Number.parseInt(bits, 10) / 8;\n        return (0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_5__.numberToHex)(value, {\n            size: isArray ? 32 : size,\n            signed: baseType === 'int',\n        });\n    }\n    const bytesMatch = type.match(_regex_js__WEBPACK_IMPORTED_MODULE_6__.bytesRegex);\n    if (bytesMatch) {\n        const [_type, size] = bytesMatch;\n        if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n            throw new _errors_abi_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                givenSize: (value.length - 2) / 2,\n            });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_4__.pad)(value, { dir: 'right', size: isArray ? 32 : null });\n    }\n    const arrayMatch = type.match(_regex_js__WEBPACK_IMPORTED_MODULE_6__.arrayRegex);\n    if (arrayMatch && Array.isArray(value)) {\n        const [_type, childType] = arrayMatch;\n        const data = [];\n        for (let i = 0; i < value.length; i++) {\n            data.push(encode(childType, value[i], true));\n        }\n        if (data.length === 0)\n            return '0x';\n        return (0,_data_concat_js__WEBPACK_IMPORTED_MODULE_1__.concatHex)(data);\n    }\n    throw new _errors_abi_js__WEBPACK_IMPORTED_MODULE_0__.UnsupportedPackedAbiType(type);\n}\n//# sourceMappingURL=encodePacked.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZVBhY2tlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF3SDtBQUN6RDtBQUNYO0FBQ047QUFDVDtBQUN1QztBQUNUO0FBQzVEO0FBQ1A7QUFDQSxrQkFBa0IsMEVBQThCO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQVM7QUFDdEIsc0JBQXNCLG1FQUFtQixHQUFHLFNBQVM7QUFDckQsZUFBZSxpREFBRztBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFHLENBQUMsNkRBQVMsV0FBVyx3QkFBd0I7QUFDL0QsZ0NBQWdDLG1EQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVc7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxpREFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQXNCO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZUFBZSxpREFBRyxVQUFVLHlDQUF5QztBQUNyRTtBQUNBLGtDQUFrQyxpREFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBUztBQUN4QjtBQUNBLGNBQWMsb0VBQXdCO0FBQ3RDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlUGFja2VkLmpzPzFlMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yLCBCeXRlc1NpemVNaXNtYXRjaEVycm9yLCBVbnN1cHBvcnRlZFBhY2tlZEFiaVR5cGUsIH0gZnJvbSAnLi4vLi4vZXJyb3JzL2FiaS5qcyc7XG5pbXBvcnQgeyBJbnZhbGlkQWRkcmVzc0Vycm9yLCB9IGZyb20gJy4uLy4uL2Vycm9ycy9hZGRyZXNzLmpzJztcbmltcG9ydCB7IGlzQWRkcmVzcyB9IGZyb20gJy4uL2FkZHJlc3MvaXNBZGRyZXNzLmpzJztcbmltcG9ydCB7IGNvbmNhdEhleCB9IGZyb20gJy4uL2RhdGEvY29uY2F0LmpzJztcbmltcG9ydCB7IHBhZCB9IGZyb20gJy4uL2RhdGEvcGFkLmpzJztcbmltcG9ydCB7IGJvb2xUb0hleCwgbnVtYmVyVG9IZXgsIHN0cmluZ1RvSGV4LCB9IGZyb20gJy4uL2VuY29kaW5nL3RvSGV4LmpzJztcbmltcG9ydCB7IGFycmF5UmVnZXgsIGJ5dGVzUmVnZXgsIGludGVnZXJSZWdleCB9IGZyb20gJy4uL3JlZ2V4LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVQYWNrZWQodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlFbmNvZGluZ0xlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHR5cGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBkYXRhLnB1c2goZW5jb2RlKHR5cGUsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRIZXgoZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGUodHlwZSwgdmFsdWUsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzcyB9KTtcbiAgICAgICAgcmV0dXJuIHBhZChhZGRyZXNzLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgIHNpemU6IGlzQXJyYXkgPyAzMiA6IG51bGwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBzdHJpbmdUb0hleCh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICByZXR1cm4gcGFkKGJvb2xUb0hleCh2YWx1ZSksIHsgc2l6ZTogaXNBcnJheSA/IDMyIDogMSB9KTtcbiAgICBjb25zdCBpbnRNYXRjaCA9IHR5cGUubWF0Y2goaW50ZWdlclJlZ2V4KTtcbiAgICBpZiAoaW50TWF0Y2gpIHtcbiAgICAgICAgY29uc3QgW190eXBlLCBiYXNlVHlwZSwgYml0cyA9ICcyNTYnXSA9IGludE1hdGNoO1xuICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KGJpdHMsIDEwKSAvIDg7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0hleCh2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogc2l6ZSxcbiAgICAgICAgICAgIHNpZ25lZDogYmFzZVR5cGUgPT09ICdpbnQnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goYnl0ZXNSZWdleCk7XG4gICAgaWYgKGJ5dGVzTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgW190eXBlLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApICE9PSAodmFsdWUubGVuZ3RoIC0gMikgLyAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSxcbiAgICAgICAgICAgICAgICBnaXZlblNpemU6ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemU6IGlzQXJyYXkgPyAzMiA6IG51bGwgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKGFycmF5UmVnZXgpO1xuICAgIGlmIChhcnJheU1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IFtfdHlwZSwgY2hpbGRUeXBlXSA9IGFycmF5TWF0Y2g7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKGVuY29kZShjaGlsZFR5cGUsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgIHJldHVybiBjb25jYXRIZXgoZGF0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFBhY2tlZEFiaVR5cGUodHlwZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGVQYWNrZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/viem/_esm/utils/abi/encodePacked.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/viem/_esm/utils/address/getContractAddress.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_esm/utils/address/getContractAddress.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContractAddress: function() { return /* binding */ getContractAddress; },\n/* harmony export */   getCreate2Address: function() { return /* binding */ getCreate2Address; },\n/* harmony export */   getCreateAddress: function() { return /* binding */ getCreateAddress; }\n/* harmony export */ });\n/* harmony import */ var _data_concat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/concat.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/concat.js\");\n/* harmony import */ var _data_isBytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/isBytes.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/isBytes.js\");\n/* harmony import */ var _data_pad_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/pad.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var _data_slice_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data/slice.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/data/slice.js\");\n/* harmony import */ var _encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/toBytes.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var _encoding_toRlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../encoding/toRlp.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/encoding/toRlp.js\");\n/* harmony import */ var _hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/keccak256.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var _getAddress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getAddress.js */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/address/getAddress.js\");\n\n\n\n\n\n\n\n\nfunction getContractAddress(opts) {\n    if (opts.opcode === 'CREATE2')\n        return getCreate2Address(opts);\n    return getCreateAddress(opts);\n}\nfunction getCreateAddress(opts) {\n    const from = (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)((0,_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(opts.from));\n    let nonce = (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(opts.nonce);\n    if (nonce[0] === 0)\n        nonce = new Uint8Array([]);\n    return (0,_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(`0x${(0,_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_encoding_toRlp_js__WEBPACK_IMPORTED_MODULE_3__.toRlp)([from, nonce], 'bytes')).slice(26)}`);\n}\nfunction getCreate2Address(opts) {\n    const from = (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)((0,_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(opts.from));\n    const salt = (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_4__.pad)((0,_data_isBytes_js__WEBPACK_IMPORTED_MODULE_5__.isBytes)(opts.salt) ? opts.salt : (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(opts.salt), {\n        size: 32,\n    });\n    const bytecodeHash = (() => {\n        if ('bytecodeHash' in opts) {\n            if ((0,_data_isBytes_js__WEBPACK_IMPORTED_MODULE_5__.isBytes)(opts.bytecodeHash))\n                return opts.bytecodeHash;\n            return (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(opts.bytecodeHash);\n        }\n        return (0,_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(opts.bytecode, 'bytes');\n    })();\n    return (0,_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_data_slice_js__WEBPACK_IMPORTED_MODULE_6__.slice)((0,_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_data_concat_js__WEBPACK_IMPORTED_MODULE_7__.concat)([(0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)('0xff'), from, salt, bytecodeHash])), 12));\n}\n//# sourceMappingURL=getContractAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWRkcmVzcy9nZXRDb250cmFjdEFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDRTtBQUNSO0FBQ0k7QUFDUTtBQUNKO0FBQ0k7QUFDSjtBQUN0QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsNkRBQU8sQ0FBQywwREFBVTtBQUNuQyxnQkFBZ0IsNkRBQU87QUFDdkI7QUFDQTtBQUNBLFdBQVcsMERBQVUsTUFBTSw2REFBUyxDQUFDLHlEQUFLLG9DQUFvQztBQUM5RTtBQUNPO0FBQ1AsaUJBQWlCLDZEQUFPLENBQUMsMERBQVU7QUFDbkMsaUJBQWlCLGlEQUFHLENBQUMseURBQU8sMEJBQTBCLDZEQUFPO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IseURBQU87QUFDdkI7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQSxlQUFlLDZEQUFTO0FBQ3hCLEtBQUs7QUFDTCxXQUFXLDBEQUFVLENBQUMscURBQUssQ0FBQyw2REFBUyxDQUFDLHVEQUFNLEVBQUUsNkRBQU87QUFDckQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvZ2V0Q29udHJhY3RBZGRyZXNzLmpzPzkzNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAnLi4vZGF0YS9jb25jYXQuanMnO1xuaW1wb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4uL2RhdGEvaXNCeXRlcy5qcyc7XG5pbXBvcnQgeyBwYWQgfSBmcm9tICcuLi9kYXRhL3BhZC5qcyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4uL2RhdGEvc2xpY2UuanMnO1xuaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJy4uL2VuY29kaW5nL3RvQnl0ZXMuanMnO1xuaW1wb3J0IHsgdG9SbHAgfSBmcm9tICcuLi9lbmNvZGluZy90b1JscC5qcyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tICcuLi9oYXNoL2tlY2NhazI1Ni5qcyc7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSAnLi9nZXRBZGRyZXNzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3Mob3B0cykge1xuICAgIGlmIChvcHRzLm9wY29kZSA9PT0gJ0NSRUFURTInKVxuICAgICAgICByZXR1cm4gZ2V0Q3JlYXRlMkFkZHJlc3Mob3B0cyk7XG4gICAgcmV0dXJuIGdldENyZWF0ZUFkZHJlc3Mob3B0cyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyhvcHRzKSB7XG4gICAgY29uc3QgZnJvbSA9IHRvQnl0ZXMoZ2V0QWRkcmVzcyhvcHRzLmZyb20pKTtcbiAgICBsZXQgbm9uY2UgPSB0b0J5dGVzKG9wdHMubm9uY2UpO1xuICAgIGlmIChub25jZVswXSA9PT0gMClcbiAgICAgICAgbm9uY2UgPSBuZXcgVWludDhBcnJheShbXSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoYDB4JHtrZWNjYWsyNTYodG9SbHAoW2Zyb20sIG5vbmNlXSwgJ2J5dGVzJykpLnNsaWNlKDI2KX1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhvcHRzKSB7XG4gICAgY29uc3QgZnJvbSA9IHRvQnl0ZXMoZ2V0QWRkcmVzcyhvcHRzLmZyb20pKTtcbiAgICBjb25zdCBzYWx0ID0gcGFkKGlzQnl0ZXMob3B0cy5zYWx0KSA/IG9wdHMuc2FsdCA6IHRvQnl0ZXMob3B0cy5zYWx0KSwge1xuICAgICAgICBzaXplOiAzMixcbiAgICB9KTtcbiAgICBjb25zdCBieXRlY29kZUhhc2ggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoJ2J5dGVjb2RlSGFzaCcgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXMob3B0cy5ieXRlY29kZUhhc2gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLmJ5dGVjb2RlSGFzaDtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKG9wdHMuYnl0ZWNvZGVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KG9wdHMuYnl0ZWNvZGUsICdieXRlcycpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3Moc2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbdG9CeXRlcygnMHhmZicpLCBmcm9tLCBzYWx0LCBieXRlY29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDb250cmFjdEFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/viem/_esm/utils/address/getContractAddress.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/viem/_esm/utils/data/isBytes.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_esm/utils/data/isBytes.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; }\n/* harmony export */ });\nfunction isBytes(value) {\n    if (!value)\n        return false;\n    if (typeof value !== 'object')\n        return false;\n    if (!('BYTES_PER_ELEMENT' in value))\n        return false;\n    return (value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array');\n}\n//# sourceMappingURL=isBytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9pc0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNCeXRlcy5qcz9lZGE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCEoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAxICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0J5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/viem/_esm/utils/data/isBytes.js\n"));

/***/ })

}]);