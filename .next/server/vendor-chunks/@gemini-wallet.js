"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@gemini-wallet";
exports.ids = ["vendor-chunks/@gemini-wallet"];
exports.modules = {

/***/ "(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2M1MjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@gemini-wallet/core/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Communicator: () => (/* binding */ Communicator),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* binding */ DEFAULT_CHAIN_ID),\n/* harmony export */   GeminiSdkEvent: () => (/* binding */ GeminiSdkEvent),\n/* harmony export */   GeminiStorage: () => (/* binding */ GeminiStorage),\n/* harmony export */   GeminiWallet: () => (/* binding */ GeminiWallet),\n/* harmony export */   GeminiWalletProvider: () => (/* binding */ GeminiWalletProvider),\n/* harmony export */   POPUP_HEIGHT: () => (/* binding */ POPUP_HEIGHT),\n/* harmony export */   POPUP_WIDTH: () => (/* binding */ POPUP_WIDTH),\n/* harmony export */   PlatformType: () => (/* binding */ PlatformType),\n/* harmony export */   ProviderEventEmitter: () => (/* binding */ ProviderEventEmitter),\n/* harmony export */   SDK_BACKEND_URL: () => (/* binding */ SDK_BACKEND_URL),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   STORAGE_CALL_BATCHES_KEY: () => (/* binding */ STORAGE_CALL_BATCHES_KEY),\n/* harmony export */   STORAGE_ETH_ACCOUNTS_KEY: () => (/* binding */ STORAGE_ETH_ACCOUNTS_KEY),\n/* harmony export */   STORAGE_ETH_ACTIVE_CHAIN_KEY: () => (/* binding */ STORAGE_ETH_ACTIVE_CHAIN_KEY),\n/* harmony export */   STORAGE_PASSKEY_CREDENTIAL_KEY: () => (/* binding */ STORAGE_PASSKEY_CREDENTIAL_KEY),\n/* harmony export */   STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY: () => (/* binding */ STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY),\n/* harmony export */   STORAGE_SETTINGS_KEY: () => (/* binding */ STORAGE_SETTINGS_KEY),\n/* harmony export */   STORAGE_SMART_ACCOUNT_KEY: () => (/* binding */ STORAGE_SMART_ACCOUNT_KEY),\n/* harmony export */   STORAGE_WC_REQUESTS_KEY: () => (/* binding */ STORAGE_WC_REQUESTS_KEY),\n/* harmony export */   base64ToHex: () => (/* binding */ base64ToHex),\n/* harmony export */   bufferToBase64URLString: () => (/* binding */ bufferToBase64URLString),\n/* harmony export */   calculateV1Address: () => (/* binding */ calculateV1Address),\n/* harmony export */   calculateWalletAddress: () => (/* binding */ calculateWalletAddress),\n/* harmony export */   closePopup: () => (/* binding */ closePopup),\n/* harmony export */   convertSendValuesToBigInt: () => (/* binding */ convertSendValuesToBigInt),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   fetchRpcRequest: () => (/* binding */ fetchRpcRequest),\n/* harmony export */   generateAuthenticatorIdHash: () => (/* binding */ generateAuthenticatorIdHash),\n/* harmony export */   hexStringFromNumber: () => (/* binding */ hexStringFromNumber),\n/* harmony export */   isChainSupportedByGeminiSw: () => (/* binding */ isChainSupportedByGeminiSw),\n/* harmony export */   openPopup: () => (/* binding */ openPopup),\n/* harmony export */   reverseResolveEns: () => (/* binding */ reverseResolveEns),\n/* harmony export */   safeJsonStringify: () => (/* binding */ safeJsonStringify),\n/* harmony export */   utf8StringToBuffer: () => (/* binding */ utf8StringToBuffer),\n/* harmony export */   validateRpcRequestArgs: () => (/* binding */ validateRpcRequestArgs),\n/* harmony export */   validateWebAuthnKey: () => (/* binding */ validateWebAuthnKey)\n/* harmony export */ });\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/errors.mjs\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/mainnet.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/arbitrum.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/optimism.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/base.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/polygon.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/optimismSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_esm/chains/definitions/polygonAmoy.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/abi/encodePacked.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/address/getContractAddress.js\");\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.mjs\");\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/data/isHex.js\");\n// src/communicator.ts\n\n\n// src/constants.ts\n\n\n// package.json\nvar package_default = {\n  name: \"@gemini-wallet/core\",\n  version: \"0.3.2\",\n  description: \"Core SDK for Gemini Wallet integration with popup communication\",\n  main: \"./dist/index.cjs\",\n  types: \"./dist/index.d.ts\",\n  type: \"module\",\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/gemini/gemini-wallet-core.git\"\n  },\n  homepage: \"https://keys.gemini.com\",\n  bugs: {\n    url: \"https://github.com/gemini/gemini-wallet-core/issues\"\n  },\n  license: \"MIT\",\n  author: \"Gemini\",\n  files: [\n    \"dist\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  exports: {\n    \".\": {\n      types: \"./dist/index.d.ts\",\n      import: \"./dist/index.js\",\n      require: \"./dist/index.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  scripts: {\n    build: \"dotenv -e .env.production -- tsup\",\n    dev: \"dotenv -e .env.local -- tsup --watch\",\n    typecheck: \"tsc --noEmit\",\n    lint: \"eslint ./src\",\n    \"lint:ci\": \"eslint --max-warnings 0 ./src\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    test: \"bun test\"\n  },\n  dependencies: {\n    \"@metamask/rpc-errors\": \"7.0.2\",\n    eventemitter3: \"5.0.1\"\n  },\n  devDependencies: {\n    \"@eslint/eslintrc\": \"3.3.1\",\n    \"@eslint/js\": \"9.38.0\",\n    \"@types/node\": \"22.13.0\",\n    \"dotenv-cli\": \"10.0.0\",\n    \"esbuild-plugin-replace\": \"1.4.0\",\n    eslint: \"9.38.0\",\n    \"eslint-config-prettier\": \"10.1.8\",\n    \"eslint-config-turbo\": \"2.5.6\",\n    \"eslint-plugin-import\": \"2.32.0\",\n    \"eslint-plugin-only-warn\": \"1.1.0\",\n    \"eslint-plugin-prettier\": \"5.5.4\",\n    \"eslint-plugin-simple-import-sort\": \"12.1.1\",\n    \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n    globals: \"16.4.0\",\n    prettier: \"3.6.2\",\n    tsup: \"8.5.0\",\n    typescript: \"5.5.3\",\n    \"typescript-eslint\": \"8.40.0\",\n    vitest: \"3.2.4\"\n  },\n  peerDependencies: {\n    viem: \">=2.0.0\"\n  },\n  keywords: [\n    \"gemini\",\n    \"wallet\",\n    \"sdk\",\n    \"ethereum\",\n    \"web3\",\n    \"crypto\"\n  ],\n  module: \"./dist/index.js\"\n};\n\n// src/constants.ts\nvar DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\nvar SDK_BACKEND_URL = DEFAULT_BACKEND_URL;\nvar ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nvar SDK_VERSION = package_default.version;\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111\n};\nvar SUPPORTED_CHAIN_IDS = [...Object.values(MAINNET_CHAIN_IDS), ...Object.values(TESTNET_CHAIN_IDS)];\nfunction getDefaultRpcUrl(chainId) {\n  const chainMap = {\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_1__.arbitrum.id]: viem_chains__WEBPACK_IMPORTED_MODULE_1__.arbitrum.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimism.id]: viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimism.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_3__.base.id]: viem_chains__WEBPACK_IMPORTED_MODULE_3__.base.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_4__.polygon.id]: viem_chains__WEBPACK_IMPORTED_MODULE_4__.polygon.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_5__.sepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_5__.sepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_6__.arbitrumSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_6__.arbitrumSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_7__.optimismSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_7__.optimismSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_8__.baseSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_8__.baseSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_9__.polygonAmoy.id]: viem_chains__WEBPACK_IMPORTED_MODULE_9__.polygonAmoy.rpcUrls.default.http[0]\n  };\n  return chainMap[chainId];\n}\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/types.ts\n\nvar GeminiSdkEvent = /* @__PURE__ */ ((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n  GeminiSdkEvent2[\"SDK_CURRENT_ACCOUNT\"] = \"SDK_CURRENT_ACCOUNT\";\n  GeminiSdkEvent2[\"SDK_SEND_BATCH_CALLS\"] = \"SDK_SEND_BATCH_CALLS\";\n  GeminiSdkEvent2[\"SDK_GET_CAPABILITIES\"] = \"SDK_GET_CAPABILITIES\";\n  GeminiSdkEvent2[\"SDK_GET_CALLS_STATUS\"] = \"SDK_GET_CALLS_STATUS\";\n  GeminiSdkEvent2[\"SDK_SHOW_CALLS_STATUS\"] = \"SDK_SHOW_CALLS_STATUS\";\n  return GeminiSdkEvent2;\n})(GeminiSdkEvent || {});\nvar PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\"\n};\nvar ProviderEventEmitter = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_10__.EventEmitter {\n};\n\n// src/utils/base64.ts\nfunction encodeBase64(array) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    base64 = btoa(\n      Array.from(array).map((b) => String.fromCharCode(b)).join(\"\")\n    );\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n// src/utils/calculateWalletAddress.ts\n\nvar SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\",\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\",\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\"\n};\nvar V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\",\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\",\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\"\n};\nvar V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\",\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\",\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\"\n};\nfunction processWalletAddressParams(params, contractAddresses) {\n  const { publicKey, credentialId, index = 0n } = params;\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\"Invalid public key: must be 64-byte hex string (0x + 128 chars)\");\n  }\n  const pubKeyX = `0x${publicKey.slice(2, 66)}`;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}`;\n  const webAuthnData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY)\n  };\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\"Invalid WebAuthn key: coordinates are not on secp256r1 curve\");\n  }\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData\n  });\n}\nfunction calculateWalletAddress(params) {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\nfunction calculateV1Address(params) {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\nfunction generateAuthenticatorIdHash(credentialId) {\n  const padding = \"=\".repeat((4 - credentialId.length % 4) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)(bytes);\n}\nfunction validateWebAuthnKey(webAuthnData) {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n  const { pubKeyX, pubKeyY } = webAuthnData;\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n  const ySquared = pubKeyY * pubKeyY % SECP256R1_P;\n  const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;\n  const threeX = 3n * pubKeyX % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n  return ySquared === rightSide;\n}\nfunction calculateAddressInternal(params) {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n  const salt = (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)(\n    (0,viem__WEBPACK_IMPORTED_MODULE_12__.encodePacked)(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index]\n    )\n  );\n  const validatorInitData = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" }\n        ],\n        type: \"tuple\"\n      },\n      { type: \"bytes32\" }\n    ],\n    [webAuthnData, authenticatorIdHash]\n  );\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n\n  };\n  const bootstrapCall = (0,viem__WEBPACK_IMPORTED_MODULE_14__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" }\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\"\n          }\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\"\n      }\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\"\n  });\n  const initData = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)([{ type: \"address\" }, { type: \"bytes\" }], [bootstrapper, bootstrapCall]);\n  return predictProxyAddress(accountImplementation, salt, initData, factoryAddress);\n}\nfunction predictProxyAddress(implementation, salt, initData, deployer) {\n  const initializeCall = (0,viem__WEBPACK_IMPORTED_MODULE_14__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\"\n      }\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\"\n  });\n  const constructorArgs = (0,viem__WEBPACK_IMPORTED_MODULE_13__.encodeAbiParameters)(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall]\n  );\n  const nexusProxyCreationCode = \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\";\n  const initCodeHash = (0,viem__WEBPACK_IMPORTED_MODULE_11__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_12__.encodePacked)([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs]));\n  return (0,viem__WEBPACK_IMPORTED_MODULE_15__.getCreate2Address)({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt\n  });\n}\n\n// src/utils/ens.ts\nasync function reverseResolveEns(address) {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n    if (!response.ok) {\n      throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    return {\n      address: data.address,\n      name: data.name || null\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null\n    };\n  }\n}\n\n// src/utils/popup.ts\n\nvar POPUP_WIDTH2 = 420;\nvar POPUP_HEIGHT2 = 650;\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(url, popupId, `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left}, top=${top}`);\n  popup?.focus();\n  if (!popup) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => {\n  return `0x${BigInt(num).toString(16)}`;\n};\nvar safeJsonStringify = (obj) => JSON.stringify(obj, (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value, 2);\n\n// src/communicator.ts\nvar Communicator = class {\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.popup = null;\n    this.listeners = /* @__PURE__ */ new Map();\n    // posts a message to the popup window\n    this.postMessage = async (message) => {\n      const popup = await this.waitForPopupLoaded();\n      popup.postMessage(message, this.url.origin);\n    };\n    // posts a request to the popup window and waits for a response\n    this.postRequestAndWaitForResponse = async (request) => {\n      const responsePromise = this.onMessage(({ requestId }) => requestId === request.requestId);\n      this.postMessage(request);\n      return await responsePromise;\n    };\n    // listens for messages from the popup window that match a given predicate\n    this.onMessage = (predicate) => {\n      return new Promise((resolve, reject) => {\n        const listener = (event) => {\n          if (event.origin !== this.url.origin) return;\n          const message = event.data;\n          if (predicate(message)) {\n            resolve(message);\n            window.removeEventListener(\"message\", listener);\n            this.listeners.delete(listener);\n          }\n        };\n        window.addEventListener(\"message\", listener);\n        this.listeners.set(listener, { reject });\n      });\n    };\n    // closes the popup, rejects all requests and clears event listeners\n    this.onRequestCancelled = () => {\n      closePopup(this.popup);\n      this.popup = null;\n      this.listeners.forEach(({ reject }, listener) => {\n        reject(_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.userRejectedRequest());\n        window.removeEventListener(\"message\", listener);\n      });\n      this.listeners.clear();\n    };\n    // waits for the popup window to fully load and then sends a version message\n    this.waitForPopupLoaded = () => {\n      if (this.popup && !this.popup.closed) {\n        this.popup.focus();\n        return Promise.resolve(this.popup);\n      }\n      this.popup = openPopup(this.url);\n      this.onMessage(({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */).then(this.onRequestCancelled).catch(() => {\n      });\n      this.onMessage(({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */).then(() => {\n        this.onDisconnectCallback?.();\n        this.onRequestCancelled();\n      }).catch(() => {\n      });\n      return this.onMessage(\n        ({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */\n      ).then((message) => {\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION\n          },\n          event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n          origin: window.location.origin,\n          requestId: message.requestId\n        });\n      }).then(() => {\n        if (!this.popup) throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal();\n        return this.popup;\n      });\n    };\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n};\n\n// src/provider/provider.ts\n\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nvar GeminiStorage = class {\n  constructor({ scope = \"@gemini\", module = \"wallet\" } = {}) {\n    this.scope = scope;\n    this.module = module;\n  }\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      memoryStorage[scoped] = value;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return localStorage.getItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      return memoryStorage[scoped] || null;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      delete memoryStorage[scoped];\n    }\n  }\n  async removeItems(keys) {\n    await Promise.all(keys.map((key) => this.removeItem(key)));\n  }\n};\n\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = \"preserved-passkey-credentials\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\nvar STORAGE_WC_REQUESTS_KEY = \"wc-requests\";\nvar STORAGE_CALL_BATCHES_KEY = \"call-batches\";\n\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(chainId);\n}\nvar GeminiWallet = class {\n  constructor({ appMetadata, chain, onDisconnectCallback, storage }) {\n    this.accounts = [];\n    this.chain = { id: DEFAULT_CHAIN_ID };\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage();\n    const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;\n    const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);\n    const defaultChain = {\n      id: fallbackChainId,\n      rpcUrl: fallbackRpcUrl\n    };\n    this.initPromise = this.initializeFromStorage(defaultChain);\n  }\n  async initializeFromStorage(defaultChain) {\n    const fallbackChain = {\n      ...defaultChain,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),\n      this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)\n    ]);\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)\n    };\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = response.data.address ? [response.data.address] : [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async disconnect() {\n    await this.ensureInitialized();\n    this.accounts = [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n  }\n  async switchChain({ id }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id)\n      };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      return null;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error ?? \"Unsupported chain.\";\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({ message }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  // EIP-5792 Wallet Call API Methods\n  getCapabilities(requestedChainIds) {\n    const capabilities = {};\n    const chainIds = requestedChainIds?.map((id) => parseInt(id, 16)) || [this.chain.id];\n    for (const chainId of chainIds) {\n      const chainIdHex = hexStringFromNumber(chainId);\n      capabilities[chainIdHex] = {\n        atomic: {\n          status: \"supported\"\n          // Smart accounts support atomic batch execution\n        },\n        paymasterService: {\n          supported: true\n        }\n      };\n    }\n    return capabilities;\n  }\n  async sendCalls(params) {\n    await this.ensureInitialized();\n    const batchId = window?.crypto?.randomUUID() || `batch-${Date.now()}-${Math.random()}`;\n    const requestedChainId = parseInt(params.chainId, 16);\n    if (requestedChainId !== this.chain.id) {\n      throw new Error(`Chain mismatch. Expected ${this.chain.id}, got ${requestedChainId}`);\n    }\n    if (!params.calls || params.calls.length === 0) {\n      throw new Error(\"No calls provided\");\n    }\n    const batchMetadata = {\n      calls: params.calls,\n      capabilities: params.capabilities,\n      chainId: params.chainId,\n      from: params.from,\n      id: batchId,\n      status: \"pending\",\n      timestamp: Date.now()\n    };\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    batches[batchId] = batchMetadata;\n    await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n    try {\n      const response = await this.sendMessageToPopup({\n        chainId: this.chain.id,\n        data: {\n          calls: params.calls\n        },\n        event: \"SDK_SEND_BATCH_CALLS\" /* SDK_SEND_BATCH_CALLS */,\n        origin: window.location.origin\n      });\n      if (response.data.error) {\n        throw new Error(response.data.error);\n      }\n      batchMetadata.transactionHash = response.data.hash;\n      batchMetadata.status = \"pending\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n      return {\n        capabilities: {\n          caip345: {\n            caip2: `eip155:${requestedChainId}`,\n            transactionHashes: [response.data.hash]\n          }\n        },\n        id: batchId\n      };\n    } catch (error) {\n      batchMetadata.status = \"failed\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n      throw error;\n    }\n  }\n  async getCallsStatus(batchId) {\n    await this.ensureInitialized();\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n    if (batch.transactionHash && this.chain.rpcUrl) {\n      try {\n        const response = await fetch(this.chain.rpcUrl, {\n          body: JSON.stringify({\n            id: 1,\n            jsonrpc: \"2.0\",\n            method: \"eth_getTransactionReceipt\",\n            params: [batch.transactionHash]\n          }),\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\"\n        });\n        const json = await response.json();\n        const receipt = json.result;\n        if (receipt) {\n          const receiptStatus = receipt.status === \"0x1\" ? \"confirmed\" : \"reverted\";\n          batch.status = receiptStatus;\n          batches[batchId] = batch;\n          await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n          return {\n            atomic: true,\n            chainId: batch.chainId,\n            id: batchId,\n            receipts: [\n              {\n                blockHash: receipt.blockHash,\n                blockNumber: receipt.blockNumber,\n                gasUsed: receipt.gasUsed,\n                logs: receipt.logs.map((log) => ({\n                  address: log.address,\n                  data: log.data,\n                  topics: log.topics\n                })),\n                status: receiptStatus === \"confirmed\" ? \"success\" : \"reverted\",\n                transactionHash: receipt.transactionHash\n              }\n            ],\n            status: receiptStatus === \"confirmed\" ? 200 : 500,\n            version: \"2.0.0\"\n          };\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch transaction receipt:\", error);\n      }\n    }\n    let statusCode;\n    switch (batch.status) {\n      case \"pending\":\n        statusCode = 100;\n        break;\n      case \"confirmed\":\n        statusCode = 200;\n        break;\n      case \"failed\":\n        statusCode = 400;\n        break;\n      case \"reverted\":\n        statusCode = 500;\n        break;\n      default:\n        statusCode = 100;\n    }\n    return {\n      atomic: true,\n      chainId: batch.chainId,\n      id: batchId,\n      status: statusCode,\n      version: \"2.0.0\"\n    };\n  }\n  async showCallsStatus(batchId) {\n    await this.ensureInitialized();\n    const batches = await this.storage.loadObject(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n};\n\n// src/provider/provider.utils.ts\n\n\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) throw error;\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== void 0 && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) continue;\n    const value = tx[field];\n    if (typeof value === \"bigint\") continue;\n    if ((0,viem__WEBPACK_IMPORTED_MODULE_17__.isHex)(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nvar GeminiWalletProvider = class extends ProviderEventEmitter {\n  constructor(providerConfig) {\n    super();\n    this.wallet = null;\n    this.config = providerConfig;\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        userDisconnectCallback?.();\n        this.disconnect();\n      }\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            if (!this.wallet) {\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  userDisconnectCallback?.();\n                  this.disconnect();\n                }\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(\n              \"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\"\n            );\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(requestParams[1]);\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        // EIP-5792 Wallet Call API\n        case \"wallet_getCapabilities\": {\n          const capabilityParams = Array.isArray(args.params) ? args.params : void 0;\n          response = this.getCapabilities(capabilityParams);\n          break;\n        }\n        case \"wallet_sendCalls\": {\n          requestParams = args.params;\n          response = await this.sendCalls(requestParams[0]);\n          break;\n        }\n        case \"wallet_getCallsStatus\": {\n          requestParams = args.params;\n          response = await this.getCallsStatus(requestParams[0]);\n          break;\n        }\n        case \"wallet_showCallsStatus\": {\n          requestParams = args.params;\n          await this.showCallsStatus(requestParams[0]);\n          response = null;\n          break;\n        }\n        // TODO: not yet implemented or unclear if we support\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_grantPermissions\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.methodNotSupported(\"Not yet implemented.\");\n        // not supported\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.methodNotSupported();\n        // call rpc directly for everything else\n        default:\n          if (!this.wallet.chain.rpcUrl)\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_18__.errorCodes.provider.unauthorized) this.disconnect();\n      return Promise.reject((0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_19__.serializeError)(error));\n    }\n  }\n  // custom wallet function to open settings page\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  // EIP-5792 Implementation Methods - delegating to wallet\n  getCapabilities(params) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    const requestedChainIds = params?.[0];\n    return this.wallet.getCapabilities(requestedChainIds);\n  }\n  async sendCalls(params) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.sendCalls(params);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.transactionRejected(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async getCallsStatus(batchId) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.getCallsStatus(batchId);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async showCallsStatus(batchId) {\n    if (!this.wallet) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.providerErrors.unauthorized();\n    }\n    try {\n      await this.wallet.showCallsStatus(batchId);\n    } catch (error) {\n      throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_16__.rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n  async disconnect() {\n    if (this.wallet) {\n      const storage = this.config.storage || new GeminiStorage();\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = null;\n    this.config.onDisconnectCallback?.();\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n    await this.emit(\"accountsChanged\", []);\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMrRTs7QUFFL0U7QUFZcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnREFBTyxNQUFNLGdEQUFPO0FBQ3pCLEtBQUssaURBQVEsTUFBTSxpREFBUTtBQUMzQixLQUFLLGlEQUFRLE1BQU0saURBQVE7QUFDM0IsS0FBSyw2Q0FBSSxNQUFNLDZDQUFJO0FBQ25CLEtBQUssZ0RBQU8sTUFBTSxnREFBTztBQUN6QixLQUFLLGdEQUFPLE1BQU0sZ0RBQU87QUFDekIs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TixjQUFjLE9BQU87QUFDckIsbUJBQW1CLDZEQUFVO0FBQzdCLDRCQUE0QixxRUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVksNERBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLDREQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSw0REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9kaXN0L2luZGV4LmpzPzBmNDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbW11bmljYXRvci50c1xuaW1wb3J0IHsgcHJvdmlkZXJFcnJvcnMsIHJwY0Vycm9ycyBhcyBycGNFcnJvcnMyIH0gZnJvbSBcIkBtZXRhbWFzay9ycGMtZXJyb3JzXCI7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbmltcG9ydCB7XG4gIGFyYml0cnVtLFxuICBhcmJpdHJ1bVNlcG9saWEsXG4gIGJhc2UsXG4gIGJhc2VTZXBvbGlhLFxuICBtYWlubmV0LFxuICBvcHRpbWlzbSxcbiAgb3B0aW1pc21TZXBvbGlhLFxuICBwb2x5Z29uLFxuICBwb2x5Z29uQW1veSxcbiAgc2Vwb2xpYVxufSBmcm9tIFwidmllbS9jaGFpbnNcIjtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgcGFja2FnZV9kZWZhdWx0ID0ge1xuICBuYW1lOiBcIkBnZW1pbmktd2FsbGV0L2NvcmVcIixcbiAgdmVyc2lvbjogXCIwLjMuMlwiLFxuICBkZXNjcmlwdGlvbjogXCJDb3JlIFNESyBmb3IgR2VtaW5pIFdhbGxldCBpbnRlZ3JhdGlvbiB3aXRoIHBvcHVwIGNvbW11bmljYXRpb25cIixcbiAgbWFpbjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIHR5cGVzOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gIHR5cGU6IFwibW9kdWxlXCIsXG4gIHJlcG9zaXRvcnk6IHtcbiAgICB0eXBlOiBcImdpdFwiLFxuICAgIHVybDogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2dlbWluaS9nZW1pbmktd2FsbGV0LWNvcmUuZ2l0XCJcbiAgfSxcbiAgaG9tZXBhZ2U6IFwiaHR0cHM6Ly9rZXlzLmdlbWluaS5jb21cIixcbiAgYnVnczoge1xuICAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vZ2VtaW5pL2dlbWluaS13YWxsZXQtY29yZS9pc3N1ZXNcIlxuICB9LFxuICBsaWNlbnNlOiBcIk1JVFwiLFxuICBhdXRob3I6IFwiR2VtaW5pXCIsXG4gIGZpbGVzOiBbXG4gICAgXCJkaXN0XCIsXG4gICAgXCJzcmNcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiTElDRU5TRVwiXG4gIF0sXG4gIGV4cG9ydHM6IHtcbiAgICBcIi5cIjoge1xuICAgICAgdHlwZXM6IFwiLi9kaXN0L2luZGV4LmQudHNcIixcbiAgICAgIGltcG9ydDogXCIuL2Rpc3QvaW5kZXguanNcIixcbiAgICAgIHJlcXVpcmU6IFwiLi9kaXN0L2luZGV4LmNqc1wiXG4gICAgfSxcbiAgICBcIi4vcGFja2FnZS5qc29uXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICB9LFxuICBzY3JpcHRzOiB7XG4gICAgYnVpbGQ6IFwiZG90ZW52IC1lIC5lbnYucHJvZHVjdGlvbiAtLSB0c3VwXCIsXG4gICAgZGV2OiBcImRvdGVudiAtZSAuZW52LmxvY2FsIC0tIHRzdXAgLS13YXRjaFwiLFxuICAgIHR5cGVjaGVjazogXCJ0c2MgLS1ub0VtaXRcIixcbiAgICBsaW50OiBcImVzbGludCAuL3NyY1wiLFxuICAgIFwibGludDpjaVwiOiBcImVzbGludCAtLW1heC13YXJuaW5ncyAwIC4vc3JjXCIsXG4gICAgXCJsaW50OmZpeFwiOiBcImVzbGludCAuL3NyYyAtLWZpeFwiLFxuICAgIHRlc3Q6IFwiYnVuIHRlc3RcIlxuICB9LFxuICBkZXBlbmRlbmNpZXM6IHtcbiAgICBcIkBtZXRhbWFzay9ycGMtZXJyb3JzXCI6IFwiNy4wLjJcIixcbiAgICBldmVudGVtaXR0ZXIzOiBcIjUuMC4xXCJcbiAgfSxcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAZXNsaW50L2VzbGludHJjXCI6IFwiMy4zLjFcIixcbiAgICBcIkBlc2xpbnQvanNcIjogXCI5LjM4LjBcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiMjIuMTMuMFwiLFxuICAgIFwiZG90ZW52LWNsaVwiOiBcIjEwLjAuMFwiLFxuICAgIFwiZXNidWlsZC1wbHVnaW4tcmVwbGFjZVwiOiBcIjEuNC4wXCIsXG4gICAgZXNsaW50OiBcIjkuMzguMFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1wcmV0dGllclwiOiBcIjEwLjEuOFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10dXJib1wiOiBcIjIuNS42XCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIjIuMzIuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1vbmx5LXdhcm5cIjogXCIxLjEuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcmV0dGllclwiOiBcIjUuNS40XCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXNpbXBsZS1pbXBvcnQtc29ydFwiOiBcIjEyLjEuMVwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zb3J0LWtleXMtZml4XCI6IFwiMS4xLjJcIixcbiAgICBnbG9iYWxzOiBcIjE2LjQuMFwiLFxuICAgIHByZXR0aWVyOiBcIjMuNi4yXCIsXG4gICAgdHN1cDogXCI4LjUuMFwiLFxuICAgIHR5cGVzY3JpcHQ6IFwiNS41LjNcIixcbiAgICBcInR5cGVzY3JpcHQtZXNsaW50XCI6IFwiOC40MC4wXCIsXG4gICAgdml0ZXN0OiBcIjMuMi40XCJcbiAgfSxcbiAgcGVlckRlcGVuZGVuY2llczoge1xuICAgIHZpZW06IFwiPj0yLjAuMFwiXG4gIH0sXG4gIGtleXdvcmRzOiBbXG4gICAgXCJnZW1pbmlcIixcbiAgICBcIndhbGxldFwiLFxuICAgIFwic2RrXCIsXG4gICAgXCJldGhlcmV1bVwiLFxuICAgIFwid2ViM1wiLFxuICAgIFwiY3J5cHRvXCJcbiAgXSxcbiAgbW9kdWxlOiBcIi4vZGlzdC9pbmRleC5qc1wiXG59O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQUNLRU5EX1VSTCA9IFwiaHR0cHM6Ly9rZXlzLmdlbWluaS5jb21cIjtcbnZhciBTREtfQkFDS0VORF9VUkwgPSBERUZBVUxUX0JBQ0tFTkRfVVJMO1xudmFyIEVOU19BUElfVVJMID0gXCJodHRwczovL2hvcml6b24tYXBpLmdlbWluaS5jb20vYXBpL2Vuc1wiO1xudmFyIFNES19WRVJTSU9OID0gcGFja2FnZV9kZWZhdWx0LnZlcnNpb247XG52YXIgREVGQVVMVF9DSEFJTl9JRCA9IDQyMTYxO1xudmFyIE1BSU5ORVRfQ0hBSU5fSURTID0ge1xuICBBUkJJVFJVTV9PTkU6IDQyMTYxLFxuICBCQVNFOiA4NDUzLFxuICBFVEhFUkVVTTogMSxcbiAgT1BfTUFJTk5FVDogMTAsXG4gIFBPTFlHT046IDEzN1xufTtcbnZhciBURVNUTkVUX0NIQUlOX0lEUyA9IHtcbiAgQVJCSVRSVU1fU0VQT0xJQTogNDIxNjE0LFxuICBCQVNFX1NFUE9MSUE6IDg0NTMyLFxuICBPUF9TRVBPTElBOiAxMTE1NTQyMCxcbiAgUE9MWUdPTl9BTU9ZOiA4MDAwMixcbiAgU0VQT0xJQTogMTExNTUxMTFcbn07XG52YXIgU1VQUE9SVEVEX0NIQUlOX0lEUyA9IFsuLi5PYmplY3QudmFsdWVzKE1BSU5ORVRfQ0hBSU5fSURTKSwgLi4uT2JqZWN0LnZhbHVlcyhURVNUTkVUX0NIQUlOX0lEUyldO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJwY1VybChjaGFpbklkKSB7XG4gIGNvbnN0IGNoYWluTWFwID0ge1xuICAgIFttYWlubmV0LmlkXTogbWFpbm5ldC5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYXJiaXRydW0uaWRdOiBhcmJpdHJ1bS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbb3B0aW1pc20uaWRdOiBvcHRpbWlzbS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYmFzZS5pZF06IGJhc2UucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW3BvbHlnb24uaWRdOiBwb2x5Z29uLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtzZXBvbGlhLmlkXTogc2Vwb2xpYS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYXJiaXRydW1TZXBvbGlhLmlkXTogYXJiaXRydW1TZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtvcHRpbWlzbVNlcG9saWEuaWRdOiBvcHRpbWlzbVNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2Jhc2VTZXBvbGlhLmlkXTogYmFzZVNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW3BvbHlnb25BbW95LmlkXTogcG9seWdvbkFtb3kucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF1cbiAgfTtcbiAgcmV0dXJuIGNoYWluTWFwW2NoYWluSWRdO1xufVxudmFyIFBPUFVQX1dJRFRIID0gNDIwO1xudmFyIFBPUFVQX0hFSUdIVCA9IDY1MDtcblxuLy8gc3JjL3R5cGVzLnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xudmFyIEdlbWluaVNka0V2ZW50ID0gLyogQF9fUFVSRV9fICovICgoR2VtaW5pU2RrRXZlbnQyKSA9PiB7XG4gIEdlbWluaVNka0V2ZW50MltcIlBPUFVQX0xPQURFRFwiXSA9IFwiUE9QVVBfTE9BREVEXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlBPUFVQX1VOTE9BREVEXCJdID0gXCJQT1BVUF9VTkxPQURFRFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9BUFBfQ09OVEVYVFwiXSA9IFwiUE9QVVBfQVBQX0NPTlRFWFRcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX0NPTk5FQ1RcIl0gPSBcIlNES19DT05ORUNUXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19ESVNDT05ORUNUXCJdID0gXCJTREtfRElTQ09OTkVDVFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU0VORF9UUkFOU0FDVElPTlwiXSA9IFwiU0RLX1NFTkRfVFJBTlNBQ1RJT05cIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NJR05fREFUQVwiXSA9IFwiU0RLX1NJR05fREFUQVwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU0lHTl9UWVBFRF9EQVRBXCJdID0gXCJTREtfU0lHTl9UWVBFRF9EQVRBXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TV0lUQ0hfQ0hBSU5cIl0gPSBcIlNES19TV0lUQ0hfQ0hBSU5cIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX09QRU5fU0VUVElOR1NcIl0gPSBcIlNES19PUEVOX1NFVFRJTkdTXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19DVVJSRU5UX0FDQ09VTlRcIl0gPSBcIlNES19DVVJSRU5UX0FDQ09VTlRcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NFTkRfQkFUQ0hfQ0FMTFNcIl0gPSBcIlNES19TRU5EX0JBVENIX0NBTExTXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19HRVRfQ0FQQUJJTElUSUVTXCJdID0gXCJTREtfR0VUX0NBUEFCSUxJVElFU1wiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfR0VUX0NBTExTX1NUQVRVU1wiXSA9IFwiU0RLX0dFVF9DQUxMU19TVEFUVVNcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NIT1dfQ0FMTFNfU1RBVFVTXCJdID0gXCJTREtfU0hPV19DQUxMU19TVEFUVVNcIjtcbiAgcmV0dXJuIEdlbWluaVNka0V2ZW50Mjtcbn0pKEdlbWluaVNka0V2ZW50IHx8IHt9KTtcbnZhciBQbGF0Zm9ybVR5cGUgPSB7XG4gIFJFQUNUX05BVElWRTogXCJSRUFDVF9OQVRJVkVcIixcbiAgV0VCOiBcIldFQlwiXG59O1xudmFyIFByb3ZpZGVyRXZlbnRFbWl0dGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xufTtcblxuLy8gc3JjL3V0aWxzL2Jhc2U2NC50c1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0KGFycmF5KSB7XG4gIGxldCBiYXNlNjQ7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYmFzZTY0ID0gQnVmZmVyLmZyb20oYXJyYXkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9IGVsc2Uge1xuICAgIGJhc2U2NCA9IGJ0b2EoXG4gICAgICBBcnJheS5mcm9tKGFycmF5KS5tYXAoKGIpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oXCJcIilcbiAgICApO1xuICB9XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGJhc2U2NHVybCkge1xuICBsZXQgYmFzZTY0ID0gYmFzZTY0dXJsLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICB3aGlsZSAoYmFzZTY0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBiYXNlNjQgKz0gXCI9XCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oYmFzZTY0LCBcImJhc2U2NFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxufVxuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcoYnVmZmVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHJldHVybiBlbmNvZGVCYXNlNjQoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvQnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHZhbHVlLCBcInV0ZjhcIikpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxufVxuZnVuY3Rpb24gYmFzZTY0VG9IZXgoYmFzZTY0KSB7XG4gIGNvbnN0IGJ5dGVzID0gZGVjb2RlQmFzZTY0KGJhc2U2NCk7XG4gIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKS5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGN1bGF0ZVdhbGxldEFkZHJlc3MudHNcbmltcG9ydCB7XG4gIGVuY29kZUFiaVBhcmFtZXRlcnMsXG4gIGVuY29kZUZ1bmN0aW9uRGF0YSxcbiAgZW5jb2RlUGFja2VkLFxuICBnZXRDcmVhdGUyQWRkcmVzcyxcbiAga2VjY2FrMjU2XG59IGZyb20gXCJ2aWVtXCI7XG52YXIgU0hBUkVEX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgQVRURVNURVI6IFwiMHgwMDA0NzQzOTJhOWNkODZhNDY4NzM1NGYxQ2UyOTY0QjUyZTk3NDg0XCIsXG4gIEJPT1RTVFJBUFBFUjogXCIweDAwMDAwMDAwRDMyNTQ0NTJhOTA5RTRlZUQ0NzQ1NUFmN0UyN0MyODlcIixcbiAgUkVHSVNUUlk6IFwiMHgwMDAwMDAwMDAwNjlFMmExODdBRUZGYjg1MmJGM2NDZEM5NTE1MUIyXCJcbn07XG52YXIgVjJfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xuICAuLi5TSEFSRURfQ09OVFJBQ1RfQUREUkVTU0VTLFxuICBBQ0NPVU5UX0lNUExFTUVOVEFUSU9OOiBcIjB4MDAwMDAwMDAwMjlkOWM4Yjg2NERENTFkNmJiMGQ5OUZCNzJENjUwYlwiLFxuICBGQUNUT1JZOiBcIjB4MDAwMDAwMDAwNDUyMzc3ZTFCZDllNzJFOTM5ODU1RUNiOTM2M0NhYlwiLFxuICBXRUJBVVRITl9WQUxJREFUT1I6IFwiMHg3YWIxNkZmMzU0QWNCMzI4NDUyRjFENDQ1YjNEZGVlOWE5MWU5ZTY5XCJcbn07XG52YXIgVjFfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xuICAuLi5TSEFSRURfQ09OVFJBQ1RfQUREUkVTU0VTLFxuICBBQ0NPVU5UX0lNUExFTUVOVEFUSU9OOiBcIjB4MDAwNjA1MDE2OERFMjU1YTg2NzJBQ2FENDgyMWU3MjFDQkE0NDMzN1wiLFxuICBGQUNUT1JZOiBcIjB4MDBFNThERjcwRmFCOTgzYTMyNGM0QzA2OGM4MmQyMDQwNzU3OUZhQ1wiLFxuICBXRUJBVVRITl9WQUxJREFUT1I6IFwiMHhiQTQ1YTJCRmI4RGUzRDI0Y0E5RDdGMUI1NTFFMTRkRkY1ZDY5MEZkXCJcbn07XG5mdW5jdGlvbiBwcm9jZXNzV2FsbGV0QWRkcmVzc1BhcmFtcyhwYXJhbXMsIGNvbnRyYWN0QWRkcmVzc2VzKSB7XG4gIGNvbnN0IHsgcHVibGljS2V5LCBjcmVkZW50aWFsSWQsIGluZGV4ID0gMG4gfSA9IHBhcmFtcztcbiAgaWYgKCFwdWJsaWNLZXkuc3RhcnRzV2l0aChcIjB4XCIpIHx8IHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHVibGljIGtleTogbXVzdCBiZSA2NC1ieXRlIGhleCBzdHJpbmcgKDB4ICsgMTI4IGNoYXJzKVwiKTtcbiAgfVxuICBjb25zdCBwdWJLZXlYID0gYDB4JHtwdWJsaWNLZXkuc2xpY2UoMiwgNjYpfWA7XG4gIGNvbnN0IHB1YktleVkgPSBgMHgke3B1YmxpY0tleS5zbGljZSg2NiwgMTMwKX1gO1xuICBjb25zdCB3ZWJBdXRobkRhdGEgPSB7XG4gICAgcHViS2V5WDogQmlnSW50KHB1YktleVgpLFxuICAgIHB1YktleVk6IEJpZ0ludChwdWJLZXlZKVxuICB9O1xuICBpZiAoIXZhbGlkYXRlV2ViQXV0aG5LZXkod2ViQXV0aG5EYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgV2ViQXV0aG4ga2V5OiBjb29yZGluYXRlcyBhcmUgbm90IG9uIHNlY3AyNTZyMSBjdXJ2ZVwiKTtcbiAgfVxuICBjb25zdCBhdXRoZW50aWNhdG9ySWRIYXNoID0gZ2VuZXJhdGVBdXRoZW50aWNhdG9ySWRIYXNoKGNyZWRlbnRpYWxJZCk7XG4gIHJldHVybiBjYWxjdWxhdGVBZGRyZXNzSW50ZXJuYWwoe1xuICAgIGF1dGhlbnRpY2F0b3JJZEhhc2gsXG4gICAgY29udHJhY3RBZGRyZXNzZXMsXG4gICAgaW5kZXgsXG4gICAgd2ViQXV0aG5EYXRhXG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlV2FsbGV0QWRkcmVzcyhwYXJhbXMpIHtcbiAgcmV0dXJuIHByb2Nlc3NXYWxsZXRBZGRyZXNzUGFyYW1zKHBhcmFtcywgVjJfQ09OVFJBQ1RfQUREUkVTU0VTKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVYxQWRkcmVzcyhwYXJhbXMpIHtcbiAgcmV0dXJuIHByb2Nlc3NXYWxsZXRBZGRyZXNzUGFyYW1zKHBhcmFtcywgVjFfQ09OVFJBQ1RfQUREUkVTU0VTKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaChjcmVkZW50aWFsSWQpIHtcbiAgY29uc3QgcGFkZGluZyA9IFwiPVwiLnJlcGVhdCgoNCAtIGNyZWRlbnRpYWxJZC5sZW5ndGggJSA0KSAlIDQpO1xuICBjb25zdCBiYXNlNjQgPSBjcmVkZW50aWFsSWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikgKyBwYWRkaW5nO1xuICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4ga2VjY2FrMjU2KGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlV2ViQXV0aG5LZXkod2ViQXV0aG5EYXRhKSB7XG4gIGNvbnN0IFNFQ1AyNTZSMV9QID0gMHhmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbjtcbiAgY29uc3QgU0VDUDI1NlIxX0IgPSAweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGJuO1xuICBjb25zdCB7IHB1YktleVgsIHB1YktleVkgfSA9IHdlYkF1dGhuRGF0YTtcbiAgaWYgKHB1YktleVggPT09IDBuIHx8IHB1YktleVkgPT09IDBuIHx8IHB1YktleVggPj0gU0VDUDI1NlIxX1AgfHwgcHViS2V5WSA+PSBTRUNQMjU2UjFfUCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB5U3F1YXJlZCA9IHB1YktleVkgKiBwdWJLZXlZICUgU0VDUDI1NlIxX1A7XG4gIGNvbnN0IHhDdWJlZCA9IHB1YktleVggKiBwdWJLZXlYICogcHViS2V5WCAlIFNFQ1AyNTZSMV9QO1xuICBjb25zdCB0aHJlZVggPSAzbiAqIHB1YktleVggJSBTRUNQMjU2UjFfUDtcbiAgY29uc3QgcmlnaHRTaWRlID0gKHhDdWJlZCArIFNFQ1AyNTZSMV9QIC0gdGhyZWVYICsgU0VDUDI1NlIxX0IpICUgU0VDUDI1NlIxX1A7XG4gIHJldHVybiB5U3F1YXJlZCA9PT0gcmlnaHRTaWRlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQWRkcmVzc0ludGVybmFsKHBhcmFtcykge1xuICBjb25zdCB7IHdlYkF1dGhuRGF0YSwgYXV0aGVudGljYXRvcklkSGFzaCwgaW5kZXgsIGNvbnRyYWN0QWRkcmVzc2VzIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGZhY3RvcnlBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzZXMuRkFDVE9SWTtcbiAgY29uc3QgYWNjb3VudEltcGxlbWVudGF0aW9uID0gY29udHJhY3RBZGRyZXNzZXMuQUNDT1VOVF9JTVBMRU1FTlRBVElPTjtcbiAgY29uc3Qgd2ViQXV0aG5WYWxpZGF0b3IgPSBjb250cmFjdEFkZHJlc3Nlcy5XRUJBVVRITl9WQUxJREFUT1I7XG4gIGNvbnN0IGF0dGVzdGVyID0gY29udHJhY3RBZGRyZXNzZXMuQVRURVNURVI7XG4gIGNvbnN0IGJvb3RzdHJhcHBlciA9IGNvbnRyYWN0QWRkcmVzc2VzLkJPT1RTVFJBUFBFUjtcbiAgY29uc3QgcmVnaXN0cnkgPSBjb250cmFjdEFkZHJlc3Nlcy5SRUdJU1RSWTtcbiAgY29uc3Qgc2FsdCA9IGtlY2NhazI1NihcbiAgICBlbmNvZGVQYWNrZWQoXG4gICAgICBbXCJ1aW50MjU2XCIsIFwidWludDI1NlwiLCBcImJ5dGVzMzJcIiwgXCJ1aW50MjU2XCJdLFxuICAgICAgW3dlYkF1dGhuRGF0YS5wdWJLZXlYLCB3ZWJBdXRobkRhdGEucHViS2V5WSwgYXV0aGVudGljYXRvcklkSGFzaCwgaW5kZXhdXG4gICAgKVxuICApO1xuICBjb25zdCB2YWxpZGF0b3JJbml0RGF0YSA9IGVuY29kZUFiaVBhcmFtZXRlcnMoXG4gICAgW1xuICAgICAge1xuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcInB1YktleVhcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICB7IG5hbWU6IFwicHViS2V5WVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IFwidHVwbGVcIlxuICAgICAgfSxcbiAgICAgIHsgdHlwZTogXCJieXRlczMyXCIgfVxuICAgIF0sXG4gICAgW3dlYkF1dGhuRGF0YSwgYXV0aGVudGljYXRvcklkSGFzaF1cbiAgKTtcbiAgY29uc3QgcmVnaXN0cnlDb25maWcgPSB7XG4gICAgYXR0ZXN0ZXJzOiBbYXR0ZXN0ZXJdLFxuICAgIHJlZ2lzdHJ5LFxuICAgIHRocmVzaG9sZDogMW5cbiAgfTtcbiAgY29uc3QgYm9vdHN0cmFwQ2FsbCA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgYWJpOiBbXG4gICAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgIHsgbmFtZTogXCJ2YWxpZGF0b3JcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICB7IG5hbWU6IFwidmFsaWRhdG9ySW5pdERhdGFcIiwgdHlwZTogXCJieXRlc1wiIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwicmVnaXN0cnlcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImF0dGVzdGVyc1wiLCB0eXBlOiBcImFkZHJlc3NbXVwiIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aHJlc2hvbGRcIiwgdHlwZTogXCJ1aW50OFwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBuYW1lOiBcInJlZ2lzdHJ5Q29uZmlnXCIsXG4gICAgICAgICAgICB0eXBlOiBcInR1cGxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiaW5pdE5leHVzV2l0aFNpbmdsZVZhbGlkYXRvclwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGFyZ3M6IFt3ZWJBdXRoblZhbGlkYXRvciwgdmFsaWRhdG9ySW5pdERhdGEsIHJlZ2lzdHJ5Q29uZmlnXSxcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdE5leHVzV2l0aFNpbmdsZVZhbGlkYXRvclwiXG4gIH0pO1xuICBjb25zdCBpbml0RGF0YSA9IGVuY29kZUFiaVBhcmFtZXRlcnMoW3sgdHlwZTogXCJhZGRyZXNzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfV0sIFtib290c3RyYXBwZXIsIGJvb3RzdHJhcENhbGxdKTtcbiAgcmV0dXJuIHByZWRpY3RQcm94eUFkZHJlc3MoYWNjb3VudEltcGxlbWVudGF0aW9uLCBzYWx0LCBpbml0RGF0YSwgZmFjdG9yeUFkZHJlc3MpO1xufVxuZnVuY3Rpb24gcHJlZGljdFByb3h5QWRkcmVzcyhpbXBsZW1lbnRhdGlvbiwgc2FsdCwgaW5pdERhdGEsIGRlcGxveWVyKSB7XG4gIGNvbnN0IGluaXRpYWxpemVDYWxsID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICBhYmk6IFtcbiAgICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImRhdGFcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBuYW1lOiBcImluaXRpYWxpemVBY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgYXJnczogW2luaXREYXRhXSxcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdGlhbGl6ZUFjY291bnRcIlxuICB9KTtcbiAgY29uc3QgY29uc3RydWN0b3JBcmdzID0gZW5jb2RlQWJpUGFyYW1ldGVycyhcbiAgICBbeyB0eXBlOiBcImFkZHJlc3NcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICBbaW1wbGVtZW50YXRpb24sIGluaXRpYWxpemVDYWxsXVxuICApO1xuICBjb25zdCBuZXh1c1Byb3h5Q3JlYXRpb25Db2RlID0gXCIweDYwODA2MDQwNTI2MTAyYzg4MDM4MDM4MDYxMDAxNDgxNjEwMThjNTY1YjkyODMzOTgxMDE2MDQwODI4MjAzMTI2MTAxODg1NzgxNTE2MDAxNjAwMTYwYTAxYjAzODExNjkyOTA5MTkwODM4MzAzNjEwMTg4NTc2MDIwODEwMTUxOTA2MDAxNjAwMTYwNDAxYjAzODIxMTYxMDE4ODU3MDE5MjgxNjAxZjg1MDExMjE1NjEwMTg4NTc4MzUxNjEwMDZlNjEwMDY5ODI2MTAxYzU1NjViNjEwMThjNTY1Yjk0ODE4NjUyNjAyMDg2MDE5MzYwMjA4MzgzMDEwMTExNjEwMTg4NTc4MTVmOTI2MDIwODA5MzAxODY1ZTg2MDEwMTUyNjAwMTdmOTBiNzcyYzJjYjhhNTFhYTdhOGE2NWZjMjM1NDNjNmQwMjJkNWIzZjhlMmI5MmVlZDc5ZmJhN2VlZjgyOTMwMDVkODIzYjE1NjEwMTc2NTc3ZjM2MDg5NGExM2JhMWEzMjEwNjY3YzgyODQ5MmRiOThkY2EzZTIwNzZjYzM3MzVhOTIwYTNjYTUwNWQzODJiYmM4MDU0NjAwMTYwMDE2MGEwMWIwMzE5MTY4MjE3OTA1NTdmYmM3Y2Q3NWEyMGVlMjdmZDlhZGViYWIzMjA0MWY3NTUyMTRkYmM2YmZmYTkwY2MwMjI1YjM5ZGEyZTVjMmQzYjVmODBhMjgyNTExNTYxMDE1ZTU3NWY4MDkxNjEwMTQ2OTQ1MTkwODQ1YWY0M2QxNTYxMDE1NjU3M2Q5MTYxMDEzNzYxMDA2OTg0NjEwMWM1NTY1YjkyODM1MjNkNWY2MDIwODUwMTNlNjEwMWUwNTY1YjUwNWI2MDQwNTE2MDg5OTA4MTYxMDIzZjgyMzlmMzViNjA2MDkxNjEwMWUwNTY1YjUwNTA1MDM0MTU2MTAxNDg1NzYzYjM5ODk3OWY2MGUwMWI1ZjUyNjAwNDVmZmQ1YjYzNGM5YzhjZTM2MGUwMWI1ZjUyNjAwNDUyNjAyNDVmZmQ1YjVmODBmZDViNjA0MDUxOTE5MDYwMWYwMTYwMWYxOTE2ODIwMTYwMDE2MDAxNjA0MDFiMDM4MTExODM4MjEwMTc2MTAxYjE1NzYwNDA1MjU2NWI2MzRlNDg3YjcxNjBlMDFiNWY1MjYwNDE2MDA0NTI2MDI0NWZmZDViNjAwMTYwMDE2MDQwMWIwMzgxMTE2MTAxYjE1NzYwMWYwMTYwMWYxOTE2NjAyMDAxOTA1NjViOTA2MTAyMDQ1NzUwODA1MTE1NjEwMWY1NTc4MDUxOTA2MDIwMDFmZDViNjNkNmJkYTI3NTYwZTAxYjVmNTI2MDA0NWZmZDViODE1MTE1ODA2MTAyMzU1NzViNjEwMjE1NTc1MDkwNTY1YjYzOTk5NmIzMTU2MGUwMWI1ZjkwODE1MjYwMDE2MDAxNjBhMDFiMDM5MTkwOTExNjYwMDQ1MjYwMjQ5MGZkNWI1MDgwM2IxNTYxMDIwZDU2ZmU2MDgwNjA0MDUyMzYxNTYwNTE1NzdmMzYwODk0YTEzYmExYTMyMTA2NjdjODI4NDkyZGI5OGRjYTNlMjA3NmNjMzczNWE5MjBhM2NhNTA1ZDM4MmJiYzU0NWY5MDgxOTA2MDAxNjAwMTYwYTAxYjAzMTYzNjgyODAzNzgxMzY5MTVhZjQzZDVmODAzZTE1NjA0ZDU3M2Q1ZmYzNWIzZDVmZmQ1YjAwZmVhMjY0Njk3MDY2NzM1ODIyMTIyMDQxYjVmNzBhMzUxOTUyMTQyMjIzZjIyNTA0Y2E3YjRlNmQ5NzVmM2EzMDJkMTE0ZmY4MjA0NDJmY2Y4MTVhYzI2NDczNmY2YzYzNDMwMDA4MWIwMDMzXCI7XG4gIGNvbnN0IGluaXRDb2RlSGFzaCA9IGtlY2NhazI1NihlbmNvZGVQYWNrZWQoW1wiYnl0ZXNcIiwgXCJieXRlc1wiXSwgW25leHVzUHJveHlDcmVhdGlvbkNvZGUsIGNvbnN0cnVjdG9yQXJnc10pKTtcbiAgcmV0dXJuIGdldENyZWF0ZTJBZGRyZXNzKHtcbiAgICBieXRlY29kZUhhc2g6IGluaXRDb2RlSGFzaCxcbiAgICBmcm9tOiBkZXBsb3llcixcbiAgICBzYWx0XG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvZW5zLnRzXG5hc3luYyBmdW5jdGlvbiByZXZlcnNlUmVzb2x2ZUVucyhhZGRyZXNzKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtFTlNfQVBJX1VSTH0vcmV2ZXJzZS8ke2FkZHJlc3N9YCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFTlMgQVBJIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBkYXRhLmFkZHJlc3MsXG4gICAgICBuYW1lOiBkYXRhLm5hbWUgfHwgbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZXNvbHZlIEVOUyBuYW1lOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvcG9wdXAudHNcbmltcG9ydCB7IHJwY0Vycm9ycyB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xudmFyIFBPUFVQX1dJRFRIMiA9IDQyMDtcbnZhciBQT1BVUF9IRUlHSFQyID0gNjUwO1xudmFyIG9wZW5Qb3B1cCA9ICh1cmwpID0+IHtcbiAgY29uc3QgbGVmdCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIFBPUFVQX1dJRFRIMikgLyAyICsgd2luZG93LnNjcmVlblg7XG4gIGNvbnN0IHRvcCA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBQT1BVUF9IRUlHSFQyKSAvIDIgKyB3aW5kb3cuc2NyZWVuWTtcbiAgY29uc3QgcG9wdXBJZCA9IGB3YWxsZXRfJHt3aW5kb3c/LmNyeXB0bz8ucmFuZG9tVVVJRCgpfWA7XG4gIGNvbnN0IHBvcHVwID0gd2luZG93Lm9wZW4odXJsLCBwb3B1cElkLCBgd2lkdGg9JHtQT1BVUF9XSURUSDJ9LCBoZWlnaHQ9JHtQT1BVUF9IRUlHSFQyfSwgbGVmdD0ke2xlZnR9LCB0b3A9JHt0b3B9YCk7XG4gIHBvcHVwPy5mb2N1cygpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKFwiUG9wIHVwIHdpbmRvdyBmYWlsZWQgdG8gb3BlblwiKTtcbiAgfVxuICByZXR1cm4gcG9wdXA7XG59O1xudmFyIGNsb3NlUG9wdXAgPSAocG9wdXApID0+IHtcbiAgaWYgKHBvcHVwICYmICFwb3B1cC5jbG9zZWQpIHtcbiAgICBwb3B1cC5vcGVuZXI/LmZvY3VzKCk7XG4gICAgcG9wdXAuY2xvc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3N0cmluZ3MudHNcbnZhciBoZXhTdHJpbmdGcm9tTnVtYmVyID0gKG51bSkgPT4ge1xuICByZXR1cm4gYDB4JHtCaWdJbnQobnVtKS50b1N0cmluZygxNil9YDtcbn07XG52YXIgc2FmZUpzb25TdHJpbmdpZnkgPSAob2JqKSA9PiBKU09OLnN0cmluZ2lmeShvYmosIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gdmFsdWUudG9TdHJpbmcoKSArIFwiblwiIDogdmFsdWUsIDIpO1xuXG4vLyBzcmMvY29tbXVuaWNhdG9yLnRzXG52YXIgQ29tbXVuaWNhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGFwcE1ldGFkYXRhLCBvbkRpc2Nvbm5lY3RDYWxsYmFjayB9KSB7XG4gICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIHBvc3RzIGEgbWVzc2FnZSB0byB0aGUgcG9wdXAgd2luZG93XG4gICAgdGhpcy5wb3N0TWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBwb3B1cCA9IGF3YWl0IHRoaXMud2FpdEZvclBvcHVwTG9hZGVkKCk7XG4gICAgICBwb3B1cC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0aGlzLnVybC5vcmlnaW4pO1xuICAgIH07XG4gICAgLy8gcG9zdHMgYSByZXF1ZXN0IHRvIHRoZSBwb3B1cCB3aW5kb3cgYW5kIHdhaXRzIGZvciBhIHJlc3BvbnNlXG4gICAgdGhpcy5wb3N0UmVxdWVzdEFuZFdhaXRGb3JSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm9uTWVzc2FnZSgoeyByZXF1ZXN0SWQgfSkgPT4gcmVxdWVzdElkID09PSByZXF1ZXN0LnJlcXVlc3RJZCk7XG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9O1xuICAgIC8vIGxpc3RlbnMgZm9yIG1lc3NhZ2VzIGZyb20gdGhlIHBvcHVwIHdpbmRvdyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJlZGljYXRlXG4gICAgdGhpcy5vbk1lc3NhZ2UgPSAocHJlZGljYXRlKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnNldChsaXN0ZW5lciwgeyByZWplY3QgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGNsb3NlcyB0aGUgcG9wdXAsIHJlamVjdHMgYWxsIHJlcXVlc3RzIGFuZCBjbGVhcnMgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5vblJlcXVlc3RDYW5jZWxsZWQgPSAoKSA9PiB7XG4gICAgICBjbG9zZVBvcHVwKHRoaXMucG9wdXApO1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7IHJlamVjdCB9LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICByZWplY3QocHJvdmlkZXJFcnJvcnMudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8vIHdhaXRzIGZvciB0aGUgcG9wdXAgd2luZG93IHRvIGZ1bGx5IGxvYWQgYW5kIHRoZW4gc2VuZHMgYSB2ZXJzaW9uIG1lc3NhZ2VcbiAgICB0aGlzLndhaXRGb3JQb3B1cExvYWRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBvcHVwICYmICF0aGlzLnBvcHVwLmNsb3NlZCkge1xuICAgICAgICB0aGlzLnBvcHVwLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5wb3B1cCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcHVwID0gb3BlblBvcHVwKHRoaXMudXJsKTtcbiAgICAgIHRoaXMub25NZXNzYWdlKCh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlBPUFVQX1VOTE9BREVEXCIgLyogUE9QVVBfVU5MT0FERUQgKi8pLnRoZW4odGhpcy5vblJlcXVlc3RDYW5jZWxsZWQpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbk1lc3NhZ2UoKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IFwiU0RLX0RJU0NPTk5FQ1RcIiAvKiBTREtfRElTQ09OTkVDVCAqLykudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgICAgICB0aGlzLm9uUmVxdWVzdENhbmNlbGxlZCgpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbk1lc3NhZ2UoXG4gICAgICAgICh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlBPUFVQX0xPQURFRFwiIC8qIFBPUFVQX0xPQURFRCAqL1xuICAgICAgKS50aGVuKChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNoYWluSWQ6IERFRkFVTFRfQ0hBSU5fSUQsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgYXBwTWV0YWRhdGE6IHRoaXMuYXBwTWV0YWRhdGEsXG4gICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBTREtfVkVSU0lPTlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnQ6IFwiUE9QVVBfQVBQX0NPTlRFWFRcIiAvKiBQT1BVUF9BUFBfQ09OVEVYVCAqLyxcbiAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXApIHRocm93IHJwY0Vycm9yczIuaW50ZXJuYWwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudXJsID0gbmV3IFVSTChTREtfQkFDS0VORF9VUkwpO1xuICAgIHRoaXMuYXBwTWV0YWRhdGEgPSBhcHBNZXRhZGF0YTtcbiAgICB0aGlzLm9uRGlzY29ubmVjdENhbGxiYWNrID0gb25EaXNjb25uZWN0Q2FsbGJhY2s7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9wcm92aWRlci50c1xuaW1wb3J0IHsgZXJyb3JDb2RlcywgcHJvdmlkZXJFcnJvcnMgYXMgcHJvdmlkZXJFcnJvcnMyLCBycGNFcnJvcnMgYXMgcnBjRXJyb3JzNCwgc2VyaWFsaXplRXJyb3IgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcblxuLy8gc3JjL3N0b3JhZ2Uvc3RvcmFnZS50c1xudmFyIG1lbW9yeVN0b3JhZ2UgPSB7fTtcbnZhciBHZW1pbmlTdG9yYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHNjb3BlID0gXCJAZ2VtaW5pXCIsIG1vZHVsZSA9IFwid2FsbGV0XCIgfSA9IHt9KSB7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICB9XG4gIHNjb3BlZEtleShrZXkpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zY29wZX0uJHt0aGlzLm1vZHVsZX0uJHtrZXl9YDtcbiAgfVxuICBhc3luYyBzdG9yZU9iamVjdChrZXksIGl0ZW0pIHtcbiAgICBjb25zdCBqc29uID0gc2FmZUpzb25TdHJpbmdpZnkoaXRlbSk7XG4gICAgYXdhaXQgdGhpcy5zZXRJdGVtKGtleSwganNvbik7XG4gIH1cbiAgYXN5bmMgbG9hZE9iamVjdChrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgYXdhaXQgdGhpcy5zdG9yZU9iamVjdChrZXksIGZhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGl0ZW0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwYXJzaW5nIEpTT04gZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzY29wZWQgPSB0aGlzLnNjb3BlZEtleShrZXkpO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzY29wZWQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgdXNpbmcgbWVtb3J5IHN0b3JhZ2VcIiwgZSk7XG4gICAgICBtZW1vcnlTdG9yYWdlW3Njb3BlZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgZ2V0SXRlbShrZXkpIHtcbiAgICBjb25zdCBzY29wZWQgPSB0aGlzLnNjb3BlZEtleShrZXkpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc2NvcGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgdXNpbmcgbWVtb3J5IHN0b3JhZ2VcIiwgZSk7XG4gICAgICByZXR1cm4gbWVtb3J5U3RvcmFnZVtzY29wZWRdIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc2NvcGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgdXNpbmcgbWVtb3J5IHN0b3JhZ2VcIiwgZSk7XG4gICAgICBkZWxldGUgbWVtb3J5U3RvcmFnZVtzY29wZWRdO1xuICAgIH1cbiAgfVxuICBhc3luYyByZW1vdmVJdGVtcyhrZXlzKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoa2V5cy5tYXAoKGtleSkgPT4gdGhpcy5yZW1vdmVJdGVtKGtleSkpKTtcbiAgfVxufTtcblxuLy8gc3JjL3N0b3JhZ2Uvc3RvcmFnZUludGVyZmFjZS50c1xudmFyIFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSA9IFwiZXRoLWFjY291bnRzXCI7XG52YXIgU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSA9IFwiZXRoLWFjdGl2ZS1jaGFpblwiO1xudmFyIFNUT1JBR0VfUEFTU0tFWV9DUkVERU5USUFMX0tFWSA9IFwicGFzc2tleS1jcmVkZW50aWFsXCI7XG52YXIgU1RPUkFHRV9QUkVTRVJWRURfUEFTU0tFWV9DUkVERU5USUFMU19LRVkgPSBcInByZXNlcnZlZC1wYXNza2V5LWNyZWRlbnRpYWxzXCI7XG52YXIgU1RPUkFHRV9TTUFSVF9BQ0NPVU5UX0tFWSA9IFwic21hcnQtYWNjb3VudFwiO1xudmFyIFNUT1JBR0VfU0VUVElOR1NfS0VZID0gXCJzZXR0aW5nc1wiO1xudmFyIFNUT1JBR0VfV0NfUkVRVUVTVFNfS0VZID0gXCJ3Yy1yZXF1ZXN0c1wiO1xudmFyIFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSA9IFwiY2FsbC1iYXRjaGVzXCI7XG5cbi8vIHNyYy93YWxsZXRzL3dhbGxldC50c1xuZnVuY3Rpb24gaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3coY2hhaW5JZCkge1xuICByZXR1cm4gU1VQUE9SVEVEX0NIQUlOX0lEUy5pbmNsdWRlcyhjaGFpbklkKTtcbn1cbnZhciBHZW1pbmlXYWxsZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgYXBwTWV0YWRhdGEsIGNoYWluLCBvbkRpc2Nvbm5lY3RDYWxsYmFjaywgc3RvcmFnZSB9KSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY2hhaW4gPSB7IGlkOiBERUZBVUxUX0NIQUlOX0lEIH07XG4gICAgdGhpcy5jb21tdW5pY2F0b3IgPSBuZXcgQ29tbXVuaWNhdG9yKHtcbiAgICAgIGFwcE1ldGFkYXRhLFxuICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2tcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlIHx8IG5ldyBHZW1pbmlTdG9yYWdlKCk7XG4gICAgY29uc3QgZmFsbGJhY2tDaGFpbklkID0gY2hhaW4/LmlkID8/IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgY29uc3QgZmFsbGJhY2tScGNVcmwgPSBjaGFpbj8ucnBjVXJsID8/IGdldERlZmF1bHRScGNVcmwoZmFsbGJhY2tDaGFpbklkKTtcbiAgICBjb25zdCBkZWZhdWx0Q2hhaW4gPSB7XG4gICAgICBpZDogZmFsbGJhY2tDaGFpbklkLFxuICAgICAgcnBjVXJsOiBmYWxsYmFja1JwY1VybFxuICAgIH07XG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuaW5pdGlhbGl6ZUZyb21TdG9yYWdlKGRlZmF1bHRDaGFpbik7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZUZyb21TdG9yYWdlKGRlZmF1bHRDaGFpbikge1xuICAgIGNvbnN0IGZhbGxiYWNrQ2hhaW4gPSB7XG4gICAgICAuLi5kZWZhdWx0Q2hhaW4sXG4gICAgICBycGNVcmw6IGRlZmF1bHRDaGFpbi5ycGNVcmwgfHwgZ2V0RGVmYXVsdFJwY1VybChkZWZhdWx0Q2hhaW4uaWQpXG4gICAgfTtcbiAgICBjb25zdCBbc3RvcmVkQ2hhaW4sIHN0b3JlZEFjY291bnRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuc3RvcmFnZS5sb2FkT2JqZWN0KFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVksIGZhbGxiYWNrQ2hhaW4pLFxuICAgICAgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9FVEhfQUNDT1VOVFNfS0VZLCB0aGlzLmFjY291bnRzKVxuICAgIF0pO1xuICAgIHRoaXMuY2hhaW4gPSB7XG4gICAgICAuLi5zdG9yZWRDaGFpbixcbiAgICAgIHJwY1VybDogc3RvcmVkQ2hhaW4ucnBjVXJsIHx8IGdldERlZmF1bHRScGNVcmwoc3RvcmVkQ2hhaW4uaWQpXG4gICAgfTtcbiAgICB0aGlzLmFjY291bnRzID0gc3RvcmVkQWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgZW5zdXJlSW5pdGlhbGl6ZWQoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBldmVudDogXCJTREtfQ09OTkVDVFwiIC8qIFNES19DT05ORUNUICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgdGhpcy5hY2NvdW50cyA9IHJlc3BvbnNlLmRhdGEuYWRkcmVzcyA/IFtyZXNwb25zZS5kYXRhLmFkZHJlc3NdIDogW107XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSwgdGhpcy5hY2NvdW50cyk7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksIHRoaXMuYWNjb3VudHMpO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKHsgaWQgfSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBpZiAoaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3coaWQpKSB7XG4gICAgICB0aGlzLmNoYWluID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgcnBjVXJsOiBnZXREZWZhdWx0UnBjVXJsKGlkKVxuICAgICAgfTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLCB0aGlzLmNoYWluKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiBpZCxcbiAgICAgIGV2ZW50OiBcIlNES19TV0lUQ0hfQ0hBSU5cIiAvKiBTREtfU1dJVENIX0NIQUlOICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZXJyb3IgPz8gXCJVbnN1cHBvcnRlZCBjaGFpbi5cIjtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHhEYXRhKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHR4RGF0YSxcbiAgICAgIGV2ZW50OiBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCIgLyogU0RLX1NFTkRfVFJBTlNBQ1RJT04gKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzaWduRGF0YSh7IG1lc3NhZ2UgfSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiB7IG1lc3NhZ2UgfSxcbiAgICAgIGV2ZW50OiBcIlNES19TSUdOX0RBVEFcIiAvKiBTREtfU0lHTl9EQVRBICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgYXN5bmMgc2lnblR5cGVkRGF0YSh7XG4gICAgbWVzc2FnZSxcbiAgICB0eXBlcyxcbiAgICBwcmltYXJ5VHlwZSxcbiAgICBkb21haW5cbiAgfSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgIHR5cGVzXG4gICAgICB9LFxuICAgICAgZXZlbnQ6IFwiU0RLX1NJR05fVFlQRURfREFUQVwiIC8qIFNES19TSUdOX1RZUEVEX0RBVEEgKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBvcGVuU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiB7fSxcbiAgICAgIGV2ZW50OiBcIlNES19PUEVOX1NFVFRJTkdTXCIgLyogU0RLX09QRU5fU0VUVElOR1MgKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgfVxuICAvLyBFSVAtNTc5MiBXYWxsZXQgQ2FsbCBBUEkgTWV0aG9kc1xuICBnZXRDYXBhYmlsaXRpZXMocmVxdWVzdGVkQ2hhaW5JZHMpIHtcbiAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSB7fTtcbiAgICBjb25zdCBjaGFpbklkcyA9IHJlcXVlc3RlZENoYWluSWRzPy5tYXAoKGlkKSA9PiBwYXJzZUludChpZCwgMTYpKSB8fCBbdGhpcy5jaGFpbi5pZF07XG4gICAgZm9yIChjb25zdCBjaGFpbklkIG9mIGNoYWluSWRzKSB7XG4gICAgICBjb25zdCBjaGFpbklkSGV4ID0gaGV4U3RyaW5nRnJvbU51bWJlcihjaGFpbklkKTtcbiAgICAgIGNhcGFiaWxpdGllc1tjaGFpbklkSGV4XSA9IHtcbiAgICAgICAgYXRvbWljOiB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1cHBvcnRlZFwiXG4gICAgICAgICAgLy8gU21hcnQgYWNjb3VudHMgc3VwcG9ydCBhdG9taWMgYmF0Y2ggZXhlY3V0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIHBheW1hc3RlclNlcnZpY2U6IHtcbiAgICAgICAgICBzdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcGFiaWxpdGllcztcbiAgfVxuICBhc3luYyBzZW5kQ2FsbHMocGFyYW1zKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IGJhdGNoSWQgPSB3aW5kb3c/LmNyeXB0bz8ucmFuZG9tVVVJRCgpIHx8IGBiYXRjaC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKX1gO1xuICAgIGNvbnN0IHJlcXVlc3RlZENoYWluSWQgPSBwYXJzZUludChwYXJhbXMuY2hhaW5JZCwgMTYpO1xuICAgIGlmIChyZXF1ZXN0ZWRDaGFpbklkICE9PSB0aGlzLmNoYWluLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWluIG1pc21hdGNoLiBFeHBlY3RlZCAke3RoaXMuY2hhaW4uaWR9LCBnb3QgJHtyZXF1ZXN0ZWRDaGFpbklkfWApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5jYWxscyB8fCBwYXJhbXMuY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjYWxscyBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYmF0Y2hNZXRhZGF0YSA9IHtcbiAgICAgIGNhbGxzOiBwYXJhbXMuY2FsbHMsXG4gICAgICBjYXBhYmlsaXRpZXM6IHBhcmFtcy5jYXBhYmlsaXRpZXMsXG4gICAgICBjaGFpbklkOiBwYXJhbXMuY2hhaW5JZCxcbiAgICAgIGZyb206IHBhcmFtcy5mcm9tLFxuICAgICAgaWQ6IGJhdGNoSWQsXG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgfTtcbiAgICBjb25zdCBiYXRjaGVzID0gYXdhaXQgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9DQUxMX0JBVENIRVNfS0VZLCB7fSk7XG4gICAgYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoTWV0YWRhdGE7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSwgYmF0Y2hlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY2FsbHM6IHBhcmFtcy5jYWxsc1xuICAgICAgICB9LFxuICAgICAgICBldmVudDogXCJTREtfU0VORF9CQVRDSF9DQUxMU1wiIC8qIFNES19TRU5EX0JBVENIX0NBTExTICovLFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEuZXJyb3IpO1xuICAgICAgfVxuICAgICAgYmF0Y2hNZXRhZGF0YS50cmFuc2FjdGlvbkhhc2ggPSByZXNwb25zZS5kYXRhLmhhc2g7XG4gICAgICBiYXRjaE1ldGFkYXRhLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoTWV0YWRhdGE7XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9DQUxMX0JBVENIRVNfS0VZLCBiYXRjaGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAgIGNhaXAzNDU6IHtcbiAgICAgICAgICAgIGNhaXAyOiBgZWlwMTU1OiR7cmVxdWVzdGVkQ2hhaW5JZH1gLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoZXM6IFtyZXNwb25zZS5kYXRhLmhhc2hdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpZDogYmF0Y2hJZFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYmF0Y2hNZXRhZGF0YS5zdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgICAgYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoTWV0YWRhdGE7XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9DQUxMX0JBVENIRVNfS0VZLCBiYXRjaGVzKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDYWxsc1N0YXR1cyhiYXRjaElkKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IGJhdGNoZXMgPSBhd2FpdCB0aGlzLnN0b3JhZ2UubG9hZE9iamVjdChTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVksIHt9KTtcbiAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbYmF0Y2hJZF07XG4gICAgaWYgKCFiYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJ1bmRsZSBJRDogJHtiYXRjaElkfWApO1xuICAgIH1cbiAgICBpZiAoYmF0Y2gudHJhbnNhY3Rpb25IYXNoICYmIHRoaXMuY2hhaW4ucnBjVXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuY2hhaW4ucnBjVXJsLCB7XG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIHBhcmFtczogW2JhdGNoLnRyYW5zYWN0aW9uSGFzaF1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGpzb24ucmVzdWx0O1xuICAgICAgICBpZiAocmVjZWlwdCkge1xuICAgICAgICAgIGNvbnN0IHJlY2VpcHRTdGF0dXMgPSByZWNlaXB0LnN0YXR1cyA9PT0gXCIweDFcIiA/IFwiY29uZmlybWVkXCIgOiBcInJldmVydGVkXCI7XG4gICAgICAgICAgYmF0Y2guc3RhdHVzID0gcmVjZWlwdFN0YXR1cztcbiAgICAgICAgICBiYXRjaGVzW2JhdGNoSWRdID0gYmF0Y2g7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSwgYmF0Y2hlcyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0b21pYzogdHJ1ZSxcbiAgICAgICAgICAgIGNoYWluSWQ6IGJhdGNoLmNoYWluSWQsXG4gICAgICAgICAgICBpZDogYmF0Y2hJZCxcbiAgICAgICAgICAgIHJlY2VpcHRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBibG9ja0hhc2g6IHJlY2VpcHQuYmxvY2tIYXNoLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiByZWNlaXB0LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgIGdhc1VzZWQ6IHJlY2VpcHQuZ2FzVXNlZCxcbiAgICAgICAgICAgICAgICBsb2dzOiByZWNlaXB0LmxvZ3MubWFwKChsb2cpID0+ICh7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVjZWlwdFN0YXR1cyA9PT0gXCJjb25maXJtZWRcIiA/IFwic3VjY2Vzc1wiIDogXCJyZXZlcnRlZFwiLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogcmVjZWlwdC50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN0YXR1czogcmVjZWlwdFN0YXR1cyA9PT0gXCJjb25maXJtZWRcIiA/IDIwMCA6IDUwMCxcbiAgICAgICAgICAgIHZlcnNpb246IFwiMi4wLjBcIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdHJhbnNhY3Rpb24gcmVjZWlwdDpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhdHVzQ29kZTtcbiAgICBzd2l0Y2ggKGJhdGNoLnN0YXR1cykge1xuICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgc3RhdHVzQ29kZSA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29uZmlybWVkXCI6XG4gICAgICAgIHN0YXR1c0NvZGUgPSAyMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICBzdGF0dXNDb2RlID0gNDAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZXZlcnRlZFwiOlxuICAgICAgICBzdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0YXR1c0NvZGUgPSAxMDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdG9taWM6IHRydWUsXG4gICAgICBjaGFpbklkOiBiYXRjaC5jaGFpbklkLFxuICAgICAgaWQ6IGJhdGNoSWQsXG4gICAgICBzdGF0dXM6IHN0YXR1c0NvZGUsXG4gICAgICB2ZXJzaW9uOiBcIjIuMC4wXCJcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNob3dDYWxsc1N0YXR1cyhiYXRjaElkKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IGJhdGNoZXMgPSBhd2FpdCB0aGlzLnN0b3JhZ2UubG9hZE9iamVjdChTVE9SQUdFX0NBTExfQkFUQ0hFU19LRVksIHt9KTtcbiAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbYmF0Y2hJZF07XG4gICAgaWYgKCFiYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJ1bmRsZSBJRDogJHtiYXRjaElkfWApO1xuICAgIH1cbiAgfVxuICBzZW5kTWVzc2FnZVRvUG9wdXAocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLmNvbW11bmljYXRvci5wb3N0UmVxdWVzdEFuZFdhaXRGb3JSZXNwb25zZSh7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgcmVxdWVzdElkOiB3aW5kb3c/LmNyeXB0bz8ucmFuZG9tVVVJRCgpXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9wcm92aWRlci51dGlscy50c1xuaW1wb3J0IHsgcnBjRXJyb3JzIGFzIHJwY0Vycm9yczMgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcbmltcG9ydCB7IGlzSGV4IH0gZnJvbSBcInZpZW1cIjtcbnZhciBmZXRjaFJwY1JlcXVlc3QgPSBhc3luYyAocmVxdWVzdCwgcnBjVXJsKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgaWQ6IHdpbmRvdz8uY3J5cHRvPy5yYW5kb21VVUlEKCksXG4gICAganNvbnJwYzogXCIyLjBcIlxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCB3aW5kb3cuZmV0Y2gocnBjVXJsLCB7XG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIG1vZGU6IFwiY29yc1wiXG4gIH0pO1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVScGNSZXF1ZXN0QXJncyhhcmdzKSB7XG4gIGlmICghYXJncyB8fCB0eXBlb2YgYXJncyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzMy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiRXhwZWN0ZWQgYSBzaW5nbGUsIG5vbi1hcnJheSwgb2JqZWN0IGFyZ3VtZW50LlwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgeyBtZXRob2QsIHBhcmFtcyB9ID0gYXJncztcbiAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwic3RyaW5nXCIgfHwgbWV0aG9kLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IHJwY0Vycm9yczMuaW52YWxpZFBhcmFtcyh7XG4gICAgICBtZXNzYWdlOiBcIidhcmdzLm1ldGhvZCcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocGFyYW1zICE9PSB2b2lkIDAgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSAmJiAodHlwZW9mIHBhcmFtcyAhPT0gXCJvYmplY3RcIiB8fCBwYXJhbXMgPT09IG51bGwpKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzMy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiJ2FyZ3MucGFyYW1zJyBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheSBpZiBwcm92aWRlZC5cIlxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50KHR4KSB7XG4gIGNvbnN0IEZJRUxEU19UT19OT1JNQUxJWkUgPSBbXCJ2YWx1ZVwiLCBcImdhc1wiLCBcImdhc1ByaWNlXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJtYXhGZWVQZXJHYXNcIl07XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7IC4uLnR4IH07XG4gIGZvciAoY29uc3QgZmllbGQgb2YgRklFTERTX1RPX05PUk1BTElaRSkge1xuICAgIGlmICghKGZpZWxkIGluIHR4KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSB0eFtmaWVsZF07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikgY29udGludWU7XG4gICAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgICAgbm9ybWFsaXplZFtmaWVsZF0gPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3Byb3ZpZGVyLnRzXG52YXIgR2VtaW5pV2FsbGV0UHJvdmlkZXIgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVyRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJDb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMud2FsbGV0ID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IHByb3ZpZGVyQ29uZmlnO1xuICAgIGNvbnN0IHVzZXJEaXNjb25uZWN0Q2FsbGJhY2sgPSBwcm92aWRlckNvbmZpZy5vbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgICB0aGlzLndhbGxldCA9IG5ldyBHZW1pbmlXYWxsZXQoe1xuICAgICAgLi4ucHJvdmlkZXJDb25maWcsXG4gICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjazogKCkgPT4ge1xuICAgICAgICB1c2VyRGlzY29ubmVjdENhbGxiYWNrPy4oKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MoYXJncyk7XG4gICAgICBpZiAoIXRoaXMud2FsbGV0Py5hY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5tZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiOiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJEaXNjb25uZWN0Q2FsbGJhY2sgPSB0aGlzLmNvbmZpZy5vbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgICAgICAgICAgICAgdGhpcy53YWxsZXQgPSBuZXcgR2VtaW5pV2FsbGV0KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdXNlckRpc2Nvbm5lY3RDYWxsYmFjaz8uKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWxsZXQuY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHRoaXMud2FsbGV0LmFjY291bnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmV0X3ZlcnNpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0NIQUlOX0lEO1xuICAgICAgICAgIGNhc2UgXCJldGhfY2hhaW5JZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGhleFN0cmluZ0Zyb21OdW1iZXIoREVGQVVMVF9DSEFJTl9JRCk7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMyLnVuYXV0aG9yaXplZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgbGV0IHJlcXVlc3RQYXJhbXM7XG4gICAgICBzd2l0Y2ggKGFyZ3MubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJldGhfcmVxdWVzdEFjY291bnRzXCI6XG4gICAgICAgIGNhc2UgXCJldGhfYWNjb3VudHNcIjpcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMud2FsbGV0LmFjY291bnRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV0X3ZlcnNpb25cIjpcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMud2FsbGV0LmNoYWluLmlkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXRoX2NoYWluSWRcIjpcbiAgICAgICAgICByZXNwb25zZSA9IGhleFN0cmluZ0Zyb21OdW1iZXIodGhpcy53YWxsZXQuY2hhaW4uaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGVyc29uYWxfc2lnblwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3NpZ25cIjpcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zaWduRGF0YSh7XG4gICAgICAgICAgICBhY2NvdW50OiByZXF1ZXN0UGFyYW1zWzFdLFxuICAgICAgICAgICAgbWVzc2FnZTogcmVxdWVzdFBhcmFtc1swXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9zZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGNvbnZlcnRTZW5kVmFsdWVzVG9CaWdJbnQocmVxdWVzdFBhcmFtc1swXSk7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zZW5kVHJhbnNhY3Rpb24ocmVxdWVzdFBhcmFtcyk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0LnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIjoge1xuICAgICAgICAgIGNvbnN0IHJhd1BhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIGxldCBjaGFpbklkO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1BhcmFtcykgJiYgcmF3UGFyYW1zWzBdPy5jaGFpbklkKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQocmF3UGFyYW1zWzBdLmNoYWluSWQsIDE2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhd1BhcmFtcyAmJiB0eXBlb2YgcmF3UGFyYW1zID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiByYXdQYXJhbXMgJiYgTnVtYmVyLmlzSW50ZWdlcihyYXdQYXJhbXMuaWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gcmF3UGFyYW1zLmlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0LmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBjaGFpbiBpZCBhcmd1bWVudC4gRXhwZWN0ZWQgW3sgY2hhaW5JZDogaGV4X3N0cmluZyB9XSBvciB7IGlkOiBudW1iZXIgfS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zd2l0Y2hDaGFpbih7IGlkOiBjaGFpbklkIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMyLmN1c3RvbSh7IGNvZGU6IDQ5MDIsIG1lc3NhZ2U6IHJlc3BvbnNlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgaGV4U3RyaW5nRnJvbU51bWJlcihjaGFpbklkKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3YxXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92MlwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjNcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3Y0XCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YVwiOiB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIGNvbnN0IHNpZ25lZFR5cGVkRGF0YVBhcmFtcyA9IEpTT04ucGFyc2UocmVxdWVzdFBhcmFtc1sxXSk7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQ6IHJlcXVlc3RQYXJhbXNbMF0sXG4gICAgICAgICAgICBkb21haW46IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy5kb21haW4sXG4gICAgICAgICAgICBtZXNzYWdlOiBzaWduZWRUeXBlZERhdGFQYXJhbXMubWVzc2FnZSxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBzaWduZWRUeXBlZERhdGFQYXJhbXMucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICB0eXBlczogc2lnbmVkVHlwZWREYXRhUGFyYW1zLnR5cGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0LnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVJUC01NzkyIFdhbGxldCBDYWxsIEFQSVxuICAgICAgICBjYXNlIFwid2FsbGV0X2dldENhcGFiaWxpdGllc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2FwYWJpbGl0eVBhcmFtcyA9IEFycmF5LmlzQXJyYXkoYXJncy5wYXJhbXMpID8gYXJncy5wYXJhbXMgOiB2b2lkIDA7XG4gICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmdldENhcGFiaWxpdGllcyhjYXBhYmlsaXR5UGFyYW1zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwid2FsbGV0X3NlbmRDYWxsc1wiOiB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kQ2FsbHMocmVxdWVzdFBhcmFtc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndhbGxldF9nZXRDYWxsc1N0YXR1c1wiOiB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRDYWxsc1N0YXR1cyhyZXF1ZXN0UGFyYW1zWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwid2FsbGV0X3Nob3dDYWxsc1N0YXR1c1wiOiB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2hvd0NhbGxzU3RhdHVzKHJlcXVlc3RQYXJhbXNbMF0pO1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBub3QgeWV0IGltcGxlbWVudGVkIG9yIHVuY2xlYXIgaWYgd2Ugc3VwcG9ydFxuICAgICAgICBjYXNlIFwiZXRoX2VjUmVjb3ZlclwiOlxuICAgICAgICBjYXNlIFwiZXRoX3N1YnNjcmliZVwiOlxuICAgICAgICBjYXNlIFwiZXRoX3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgIGNhc2UgXCJwZXJzb25hbF9lY1JlY292ZXJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF93YXRjaEFzc2V0XCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfZ3JhbnRQZXJtaXNzaW9uc1wiOlxuICAgICAgICAgIHRocm93IHJwY0Vycm9yczQubWV0aG9kTm90U3VwcG9ydGVkKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgY2FzZSBcImV0aF9zaWduXCI6XG4gICAgICAgIGNhc2UgXCJldGhfY29pbmJhc2VcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9hZGRFdGhlcmV1bUNoYWluXCI6XG4gICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgLy8gY2FsbCBycGMgZGlyZWN0bHkgZm9yIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghdGhpcy53YWxsZXQuY2hhaW4ucnBjVXJsKVxuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC5pbnRlcm5hbChgUlBDIFVSTCBtaXNzaW5nIGZvciBjdXJyZW50IGNoYWluICgke3RoaXMud2FsbGV0LmNoYWluLmlkfSlgKTtcbiAgICAgICAgICByZXR1cm4gZmV0Y2hScGNSZXF1ZXN0KGFyZ3MsIHRoaXMud2FsbGV0LmNoYWluLnJwY1VybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICBpZiAoY29kZSA9PT0gZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQpIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG4gICAgfVxuICB9XG4gIC8vIGN1c3RvbSB3YWxsZXQgZnVuY3Rpb24gdG8gb3BlbiBzZXR0aW5ncyBwYWdlXG4gIGFzeW5jIG9wZW5TZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLndhbGxldD8ub3BlblNldHRpbmdzKCk7XG4gIH1cbiAgLy8gRUlQLTU3OTIgSW1wbGVtZW50YXRpb24gTWV0aG9kcyAtIGRlbGVnYXRpbmcgdG8gd2FsbGV0XG4gIGdldENhcGFiaWxpdGllcyhwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBwcm92aWRlckVycm9yczIudW5hdXRob3JpemVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RlZENoYWluSWRzID0gcGFyYW1zPy5bMF07XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0LmdldENhcGFiaWxpdGllcyhyZXF1ZXN0ZWRDaGFpbklkcyk7XG4gIH1cbiAgYXN5bmMgc2VuZENhbGxzKHBhcmFtcykge1xuICAgIGlmICghdGhpcy53YWxsZXQpIHtcbiAgICAgIHRocm93IHByb3ZpZGVyRXJyb3JzMi51bmF1dGhvcml6ZWQoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLndhbGxldC5zZW5kQ2FsbHMocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgcnBjRXJyb3JzNC50cmFuc2FjdGlvblJlamVjdGVkKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENhbGxzU3RhdHVzKGJhdGNoSWQpIHtcbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBwcm92aWRlckVycm9yczIudW5hdXRob3JpemVkKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy53YWxsZXQuZ2V0Q2FsbHNTdGF0dXMoYmF0Y2hJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHJwY0Vycm9yczQuaW52YWxpZFBhcmFtcyhlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaG93Q2FsbHNTdGF0dXMoYmF0Y2hJZCkge1xuICAgIGlmICghdGhpcy53YWxsZXQpIHtcbiAgICAgIHRocm93IHByb3ZpZGVyRXJyb3JzMi51bmF1dGhvcml6ZWQoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud2FsbGV0LnNob3dDYWxsc1N0YXR1cyhiYXRjaElkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgcnBjRXJyb3JzNC5pbnZhbGlkUGFyYW1zKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMud2FsbGV0KSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5jb25maWcuc3RvcmFnZSB8fCBuZXcgR2VtaW5pU3RvcmFnZSgpO1xuICAgICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSk7XG4gICAgfVxuICAgIHRoaXMud2FsbGV0ID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZy5vbkRpc2Nvbm5lY3RDYWxsYmFjaz8uKCk7XG4gICAgYXdhaXQgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBcIlVzZXIgaW5pdGlhdGVkIGRpc2Nvbm5lY3Rpb25cIik7XG4gICAgYXdhaXQgdGhpcy5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIFtdKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvbW11bmljYXRvcixcbiAgREVGQVVMVF9DSEFJTl9JRCxcbiAgR2VtaW5pU2RrRXZlbnQsXG4gIEdlbWluaVN0b3JhZ2UsXG4gIEdlbWluaVdhbGxldCxcbiAgR2VtaW5pV2FsbGV0UHJvdmlkZXIsXG4gIFBPUFVQX0hFSUdIVCxcbiAgUE9QVVBfV0lEVEgsXG4gIFBsYXRmb3JtVHlwZSxcbiAgUHJvdmlkZXJFdmVudEVtaXR0ZXIsXG4gIFNES19CQUNLRU5EX1VSTCxcbiAgU0RLX1ZFUlNJT04sXG4gIFNUT1JBR0VfQ0FMTF9CQVRDSEVTX0tFWSxcbiAgU1RPUkFHRV9FVEhfQUNDT1VOVFNfS0VZLFxuICBTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLFxuICBTVE9SQUdFX1BBU1NLRVlfQ1JFREVOVElBTF9LRVksXG4gIFNUT1JBR0VfUFJFU0VSVkVEX1BBU1NLRVlfQ1JFREVOVElBTFNfS0VZLFxuICBTVE9SQUdFX1NFVFRJTkdTX0tFWSxcbiAgU1RPUkFHRV9TTUFSVF9BQ0NPVU5UX0tFWSxcbiAgU1RPUkFHRV9XQ19SRVFVRVNUU19LRVksXG4gIGJhc2U2NFRvSGV4LFxuICBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyxcbiAgY2FsY3VsYXRlVjFBZGRyZXNzLFxuICBjYWxjdWxhdGVXYWxsZXRBZGRyZXNzLFxuICBjbG9zZVBvcHVwLFxuICBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50LFxuICBkZWNvZGVCYXNlNjQsXG4gIGVuY29kZUJhc2U2NCxcbiAgZmV0Y2hScGNSZXF1ZXN0LFxuICBnZW5lcmF0ZUF1dGhlbnRpY2F0b3JJZEhhc2gsXG4gIGhleFN0cmluZ0Zyb21OdW1iZXIsXG4gIGlzQ2hhaW5TdXBwb3J0ZWRCeUdlbWluaVN3LFxuICBvcGVuUG9wdXAsXG4gIHJldmVyc2VSZXNvbHZlRW5zLFxuICBzYWZlSnNvblN0cmluZ2lmeSxcbiAgdXRmOFN0cmluZ1RvQnVmZmVyLFxuICB2YWxpZGF0ZVJwY1JlcXVlc3RBcmdzLFxuICB2YWxpZGF0ZVdlYkF1dGhuS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@gemini-wallet/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDOztBQUVkO0FBQ3ZCLGlFQUFlLHNDQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnZW1pbmktd2FsbGV0L2NvcmUvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzP2JjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2luZGV4LmpzJ1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@gemini-wallet/core/node_modules/eventemitter3/index.mjs\n");

/***/ })

};
;